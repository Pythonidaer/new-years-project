[
  {
    "id": 19,
    "title": "What a Good React Testing Library Test Looks Like",
    "date": "January 11, 2026",
    "excerpt": "What makes a React Testing Library test maintainable: user-visible assertions, accessible queries, boundary mocking, deterministic async handling, and resilience to refactors.",
    "category": "Testing & Code Quality",
    "image": "https://picsum.photos/367/197?random=56",
    "link": "/blog/what-a-good-react-testing-library-test-looks-like",
    "slug": "what-a-good-react-testing-library-test-looks-like",
    "author": "Senior Engineer",
    "tags": [
      "React",
      "Testing",
      "React Testing Library",
      "Jest",
      "MSW",
      "Frontend",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cWhat does a \u201cgood\u201d React Testing Library test look like to you?\u201d</p>\n<p>A \u201cgood\u201d React Testing Library test proves user-visible behavior with minimal coupling to implementation details. It reads like a short script of what a user does and what the user sees, while staying deterministic (no real network, no flaky timers) and focused (one behavior per test whenever practical).</p>\n\n<h2>What makes a test \u201cgood\u201d in React Testing Library specifically</h2>\n<p>React Testing Library is designed around the idea that tests should interact with the UI the way a user would: by accessible roles, labels, and text. A good test uses those queries to avoid brittle selectors and to encourage accessible markup.</p>\n<p><strong>The best tests survive refactors.</strong> If a component changes its internal structure but the user experience stays the same, a good RTL test should keep passing without rewrites.</p>\n\n<div class=\"explanation\">\n  <p><strong>A reliable rule is: test behavior, not wiring.</strong> Instead of asserting that a function was called, assert that the screen changed in the way a user would observe (a success message appears, a button disables, a row is added).</p>\n</div>\n\n<h2>Key characteristics of a strong RTL test</h2>\n<p>Strong tests tend to share a few traits. These are not rigid rules, but they correlate with tests that stay maintainable over time.</p>\n\n<ul>\n  <li><strong>Queries match accessibility:</strong> <code>getByRole</code>, <code>findByLabelText</code>, <code>getByText</code> are preferred over <code>querySelector</code>.</li>\n  <li><strong>User interactions are realistic:</strong> prefer <code>userEvent</code> over <code>fireEvent</code> for typing and clicking.</li>\n  <li><strong>Async waits are purposeful:</strong> wait for the UI state the user cares about, not arbitrary timeouts.</li>\n  <li><strong>Mocks are at the boundary:</strong> mock the network and time, not internal implementation details.</li>\n  <li><strong>Assertions are minimal but meaningful:</strong> assert only what proves the behavior; avoid asserting every intermediate step.</li>\n</ul>\n\n<h2>A concrete \u201cgood\u201d example</h2>\n<p>This example tests a realistic user workflow: load initial data, edit a field, click save, and see confirmation. The network is mocked at the boundary with MSW, so the component can run through its real async behavior.</p>\n\n<div class=\"example\">\n  <p><strong>Good test:</strong> user-oriented queries, boundary mocking, and assertions on observable UI.</p>\n  <pre><code>import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { ProfileEditor } from \"./ProfileEditor\";\nimport { server } from \"../test/msw/server\";\nimport { http, HttpResponse } from \"msw\";\n\ntest(\"saves the updated display name\", async () =&gt; {\n  server.use(\n    http.get(\"/api/users/123\", () =&gt; HttpResponse.json({ id: \"123\", name: \"Johnny\" })),\n    http.patch(\"/api/users/123\", async ({ request }) =&gt; {\n      const body = await request.json();\n      return HttpResponse.json({ id: \"123\", name: body.name });\n    })\n  );\n\n  render(&lt;ProfileEditor userId=\"123\" /&gt;);\n\n  // Assert on user-visible behavior, not implementation details\n  const nameInput = await screen.findByLabelText(/display name/i);\n  await userEvent.clear(nameInput);\n  await userEvent.type(nameInput, \"John\");\n\n  await userEvent.click(screen.getByRole(\"button\", { name: /save/i }));\n\n  // Prefer waiting for the final state the user sees\n  expect(await screen.findByText(/saved/i)).toBeInTheDocument();\n});</code></pre>\n</div>\n\n<h2>A concrete \u201cbad\u201d example and why it is risky</h2>\n<p>\u201cBad\u201d in this context does not mean useless; it means fragile and tightly coupled. This style often breaks during refactors even when behavior stays correct, and it can produce false confidence because it does not verify what users see.</p>\n\n<div class=\"example\">\n  <p><strong>Bad test:</strong> brittle selector + asserting internal wiring instead of user-visible output.</p>\n  <pre><code>import { render } from \"@testing-library/react\";\nimport { ProfileEditor } from \"./ProfileEditor\";\n\ntest(\"calls saveUser when clicking save\", () =&gt; {\n  const saveUser = jest.fn();\n  const { container } = render(&lt;ProfileEditor saveUser={saveUser} userId=\"123\" /&gt;);\n\n  // brittle selector\n  container.querySelector(\"button.btn-primary\")!.click();\n\n  // tests an internal detail, not what the user experiences\n  expect(saveUser).toHaveBeenCalled();\n});</code></pre>\n</div>\n\n<p>Here, the test depends on a CSS class and a passed-in callback. If the component is refactored to use a different button class or internal handler, the test fails even if the user experience is identical.</p>\n\n<h2>How good RTL tests keep asynchronous behavior deterministic</h2>\n<p>Many frontend bugs are async, so tests should exercise async paths without flakiness. Good RTL tests usually avoid real network calls and rely on deterministic mocks. For HTTP APIs, MSW is a common choice because it models requests at the fetch layer, which keeps tests close to reality.</p>\n<p>For time-based behavior, teams often use fake timers sparingly and prefer waiting for UI states rather than sleeping. A test that waits for a spinner to disappear or a success message to appear is typically more stable than a test that waits 500ms.</p>\n\n<h2>Tradeoffs and what \u201cgood\u201d does not mean</h2>\n<p><strong>\u201cGood\u201d does not mean \u201cintegration test everything.\u201d</strong> Some logic is better tested at a unit level (pure functions, formatters, reducers) to keep UI tests lean and reduce setup cost.</p>\n<p><strong>\u201cGood\u201d also does not mean \u201cassert everything.\u201d</strong> Over-asserting leads to tests that break frequently. The goal is to prove the behavior, not to lock down every DOM detail.</p>\n\n<h2>Conclusion</h2>\n<p>A good React Testing Library test reads like a user story: set up the boundary mocks, render the component, perform realistic interactions, and assert on the final visible outcome. It should be deterministic, accessible-query-driven, and resilient to refactors.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> A good RTL test focuses on user-visible behavior and avoids implementation details. I prefer queries like <code>getByRole</code> and <code>findByLabelText</code>, use <code>userEvent</code> for interactions, and mock at the boundary (for example with MSW) rather than mocking internal functions. For async flows, I wait for the UI state the user cares about instead of using timeouts. The result is tests that are deterministic and survive refactors.</p>\n</div>"
  }
]