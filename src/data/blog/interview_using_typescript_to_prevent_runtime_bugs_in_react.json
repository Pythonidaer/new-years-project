[
  {
    "id": 13,
    "title": "Using TypeScript to Prevent Runtime Bugs in React",
    "date": "January 11, 2026",
    "excerpt": "How TypeScript reduces production bugs in React by modeling impossible states, typing async boundaries, enforcing exhaustiveness, and validating untrusted data at runtime.",
    "category": "JavaScript & TypeScript",
    "image": "https://picsum.photos/367/197?random=50",
    "link": "/blog/using-typescript-to-prevent-runtime-bugs-in-react",
    "slug": "using-typescript-to-prevent-runtime-bugs-in-react",
    "author": "Senior Engineer",
    "tags": [
      "React",
      "TypeScript",
      "Runtime Safety",
      "Typing",
      "Validation",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cHow do you use TypeScript to prevent runtime bugs in a React application?\u201d</p>\n<p>TypeScript prevents runtime bugs in React by shifting many failures from production into development time. The most effective usage focuses on modeling \u201cimpossible states,\u201d making boundaries explicit (props, API responses, and shared utilities), and combining static typing with runtime validation at the edges where untrusted data enters the system.</p>\n\n<h2>Start with the honest limit: TypeScript is not a runtime shield</h2>\n<p>TypeScript only checks code at build time. If a production bug comes from unvalidated API responses, unexpected nulls, or data stored in localStorage, TypeScript cannot magically stop it.</p>\n<p><strong>The senior move is to use TypeScript to make invalid states hard to represent</strong>, and then validate untrusted inputs at runtime when they cross a boundary.</p>\n\n<div class=\"explanation\">\n  <p><strong>\u201cBoundary\u201d is the key term.</strong> Boundaries include component props, API payloads, URL/query params, localStorage, and third-party libraries. Inside the boundary, TypeScript can enforce strong assumptions. At the boundary, those assumptions must be earned.</p>\n</div>\n\n<h2>1) Make component APIs unambiguous with precise props</h2>\n<p>Many runtime bugs in React come from props being loosely typed, optional when they should not be, or coupled incorrectly (for example, \u201cif mode is X, then prop Y must exist\u201d).</p>\n<p>Discriminated unions are one of the most effective tools here because they encode conditional requirements directly into the type system.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> props that prevent invalid combinations at compile time.</p>\n  <pre><code>type UserBadgeProps =\n  | { status: \"guest\" }\n  | { status: \"member\"; name: string };\n\nexport function UserBadge(props: UserBadgeProps) {\n  if (props.status === \"guest\") return &lt;span&gt;Guest&lt;/span&gt;;\n  return &lt;span&gt;Welcome, {props.name}&lt;/span&gt;;\n}\n\n// \u2705 Compile-time protection:\n// &lt;UserBadge status=\"member\" /&gt;        // Error: name is required\n// &lt;UserBadge status=\"guest\" name=\"A\" /&gt; // Error: name not allowed for guest\n</code></pre>\n</div>\n\n<h2>2) Type async data as a result, not as \u201cmaybe undefined\u201d</h2>\n<p>A common anti-pattern is letting API calls return <code>T | undefined</code> and then sprinkling null checks everywhere. This often leads to missed cases and confusing UI states.</p>\n<p>A more maintainable approach is to model the outcome as a typed result (success vs error). This forces callers to handle error paths explicitly instead of implicitly.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a typed API result that makes error handling explicit.</p>\n  <pre><code>type ApiResult&lt;T&gt; =\n  | { ok: true; data: T }\n  | { ok: false; error: { message: string; status?: number } };\n\nasync function getJson&lt;T&gt;(url: string): Promise&lt;ApiResult&lt;T&gt;&gt; {\n  try {\n    const res = await fetch(url);\n    if (!res.ok) return { ok: false, error: { message: \"Request failed\", status: res.status } };\n    return { ok: true, data: (await res.json()) as T };\n  } catch (e) {\n    return { ok: false, error: { message: \"Network error\" } };\n  }\n}\n\ntype User = { id: string; email: string };\n\nexport async function loadUser(userId: string) {\n  const result = await getJson&lt;User&gt;(`/api/users/${userId}`);\n  if (!result.ok) return result; // error path is typed\n  return result;                 // success path is typed\n}\n</code></pre>\n</div>\n\n<h2>3) Use type narrowing to prevent \u201cforgotten cases\u201d</h2>\n<p>UI bugs frequently happen when a new state is added (a new tab, a new status enum) and one code path is not updated. Exhaustive checks turn this into a compile-time failure instead of a runtime surprise.</p>\n<p>This pattern is especially useful for view state (loading/error/ready), reducers, and any business enum that drives rendering.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> exhaustive switching with <code>never</code> so new states cannot be ignored.</p>\n  <pre><code>function assertNever(x: never): never {\n  throw new Error(\"Unexpected value: \" + String(x));\n}\n\ntype ViewState =\n  | { type: \"loading\" }\n  | { type: \"error\"; message: string }\n  | { type: \"ready\"; items: string[] };\n\nexport function View(state: ViewState) {\n  switch (state.type) {\n    case \"loading\":\n      return &lt;Spinner /&gt;;\n    case \"error\":\n      return &lt;ErrorState message={state.message} /&gt;;\n    case \"ready\":\n      return &lt;List items={state.items} /&gt;;\n    default:\n      return assertNever(state); // \u2705 forces exhaustiveness\n  }\n}\n</code></pre>\n</div>\n\n<h2>4) Validate untrusted data at runtime, then infer types from the schema</h2>\n<p>Even in a strongly typed codebase, API responses and persisted storage are still just JSON at runtime. If the backend changes or returns unexpected data, a typed assumption can fail silently until the UI throws.</p>\n<p><strong>Runtime validation solves that gap.</strong> A common approach is to validate with a schema (for example, Zod) and then infer TypeScript types from the schema so runtime and compile-time stay aligned.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> runtime validation with a schema and typed output.</p>\n  <pre><code>import { z } from \"zod\";\n\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n});\n\ntype User = z.infer&lt;typeof UserSchema&gt;;\n\nasync function fetchUser(userId: string): Promise&lt;User&gt; {\n  const res = await fetch(`/api/users/${userId}`);\n  const json = await res.json();\n  // \u2705 runtime validation + typed output\n  return UserSchema.parse(json);\n}\n</code></pre>\n</div>\n\n<h2>Other high-leverage TypeScript practices in React</h2>\n<p>Once the core patterns above are in place, teams often improve reliability further with a few consistent practices.</p>\n<ul>\n  <li><strong>Enable strict mode:</strong> options like <code>strict</code>, <code>noUncheckedIndexedAccess</code>, and <code>exactOptionalPropertyTypes</code> catch edge cases earlier.</li>\n  <li><strong>Prefer \u201cunknown\u201d at boundaries:</strong> treat untrusted inputs as <code>unknown</code> and narrow them safely instead of using <code>any</code>.</li>\n  <li><strong>Type event handlers intentionally:</strong> especially for forms and custom components, to avoid incorrect assumptions about <code>target</code> and value shapes.</li>\n  <li><strong>Keep shared utilities typed:</strong> one well-typed helper can remove dozens of ad-hoc checks across the app.</li>\n</ul>\n\n<h2>Tradeoffs and failure modes</h2>\n<p><strong>TypeScript can create a false sense of security.</strong> If API boundaries are not validated, the types may describe an ideal world rather than the real payloads. This often shows up as \u201cit compiles, but it crashed in prod.\u201d</p>\n<p><strong>Overly clever types can hurt developer experience.</strong> Extremely generic types and advanced conditional typing can make error messages hard to understand for the team. The best types tend to be simple, domain-shaped, and easy to explain.</p>\n\n<h2>Conclusion</h2>\n<p>TypeScript prevents runtime bugs in React by making invalid UI states and invalid prop combinations impossible to express, and by forcing explicit handling of async success and failure paths. The most robust approach treats TypeScript as a tool for internal correctness and pairs it with runtime validation at the boundaries where untrusted data enters the app.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I use TypeScript to model \u201cimpossible states\u201d so the compiler catches mistakes before they ship. For React, that means precise prop types (often with discriminated unions), typed result objects for async work so error paths are handled explicitly, and exhaustive checks so new states can\u2019t be forgotten. At API and storage boundaries, I validate runtime data (for example with a schema) and infer types from that schema, because TypeScript alone doesn\u2019t protect against bad JSON at runtime.</p>\n</div>"
  }
]