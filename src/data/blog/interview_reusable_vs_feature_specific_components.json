[
  {
    "id": 2,
    "title": "Reusable vs Feature-Specific Components",
    "date": "January 11, 2026",
    "excerpt": "A practical way to decide between reusable UI components and feature-specific components by optimizing for change, stable responsibilities, and maintainable APIs.",
    "category": "Frontend Architecture",
    "image": "https://picsum.photos/367/197?random=39",
    "link": "/blog/reusable-vs-feature-specific-components",
    "slug": "reusable-vs-feature-specific-components",
    "author": "LLM Writer",
    "tags": [
      "React",
      "Component Design",
      "Frontend Architecture",
      "Design Systems",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cHow do you decide when to create reusable components versus feature-specific components?\u201d</p><p>This question comes up frequently in frontend and UI architecture interviews because it reveals how a candidate balances code reuse, clarity, and long-term maintainability. The short version of the answer is that reusable components are most effective when they reduce the cost of change across multiple features, while feature-specific components tend to be safer when requirements are still evolving.</p><h2>What the decision is really about</h2><p>At first glance, this decision looks like a debate about duplication versus reuse. In practice, senior engineers frame it as a question about change and coupling. A reusable component becomes a shared dependency, which means every change has a wider blast radius.</p><p>Feature-specific components, on the other hand, localize complexity. They may duplicate some code, but they are easier to reason about and cheaper to modify when a feature is still in flux.</p><div class=\"explanation\"><p><strong>A feature-specific component</strong> is one whose boundaries match a single domain concept or product feature. For example, a <code>&lt;BillingPlanPicker /&gt;</code> component is allowed to know about billing rules, pricing tiers, and edge cases specific to that domain.</p><p><strong>A reusable component</strong> should have a stable responsibility that makes sense across contexts. It should not need to understand billing, onboarding, or workouts in order to be useful.</p></div><h2>A practical decision framework</h2><p>Senior engineers often rely on a small set of guiding questions rather than strict rules. These questions help avoid premature abstraction while still encouraging reuse when it is genuinely valuable.</p><ul><li><strong>Is there real duplication today?</strong> Multiple features already implementing the same structure or behavior.</li><li><strong>Is the shared responsibility stable?</strong> Layout and accessibility tend to change slowly; business rules usually do not.</li><li><strong>Are the differences shallow or deep?</strong> Shallow differences fit reuse; deep differences often do not.</li><li><strong>Can the API stay small?</strong> A growing prop surface is a warning sign.</li><li><strong>Does consistency matter here?</strong> Core UI elements benefit from standardization.</li></ul><h2>The cost of getting it wrong</h2><p><strong>The most common failure mode is premature reuse.</strong> Teams extract a component too early and attempt to make it flexible enough for every imagined use case.</p><p>Over time, this leads to complex APIs, higher onboarding costs, and fear of change. The abstraction meant to reduce duplication ends up creating it.</p><div class=\"example\"><p><strong>Real-world scenario:</strong> two pages need an editable card, one for profile settings and one for billing.</p><pre><code>// Too generic too early\nfunction EditableCard({ variant, layout, mode, onSave, renderHeader, renderBody, footerActions }) {\n  // multiple modes, layout switches, feature assumptions leaking in\n}</code></pre><p>This component appears reusable but quickly turns into a mini framework.</p></div><h2>Reusing at the right level</h2><p>A common senior-level approach is to reuse only the stable parts of the UI and keep feature logic separate.</p><div class=\"example\"><p><strong>A more maintainable approach</strong> is to share layout and styling primitives.</p><pre><code>// Reusable building blocks\nfunction Card({ children }) { return &lt;div className=\"card\"&gt;{children}&lt;/div&gt;; }\nfunction CardHeader({ children }) { return &lt;div className=\"card__header\"&gt;{children}&lt;/div&gt;; }\nfunction CardBody({ children }) { return &lt;div className=\"card__body\"&gt;{children}&lt;/div&gt;; }\n\n// Feature-specific composition\nfunction BillingEditableCard() {\n  return (\n    &lt;Card&gt;\n      &lt;CardHeader&gt;Billing&lt;/CardHeader&gt;\n      &lt;CardBody&gt;{/* billing-specific form and rules */}&lt;/CardBody&gt;\n    &lt;/Card&gt;\n  );\n}</code></pre><p>This keeps consistency without forcing unrelated features to share a complex API.</p></div><h2>Conclusion</h2><p>Reusable components are most effective when they standardize something stable. Feature-specific components are often the better choice when logic is tightly coupled to a domain.</p><div class=\"takeaway\"><p><strong>Interview-ready answer:</strong> \u201cI usually start with feature-specific components and extract reuse once I see real duplication and stable shared behavior. I try to extract at the lowest stable level so I get consistency without over-coupling features.\u201d</p></div>"
  }
]