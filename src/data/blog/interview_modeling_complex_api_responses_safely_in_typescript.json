[
  {
    "id": 15,
    "title": "Modeling Complex API Responses Safely in TypeScript",
    "date": "January 11, 2026",
    "excerpt": "A safe, scalable way to model complex API responses: validate at runtime, infer types from schemas, use discriminated unions for polymorphic data, and standardize success/error results.",
    "category": "JavaScript & TypeScript",
    "image": "https://picsum.photos/367/197?random=52",
    "link": "/blog/modeling-complex-api-responses-safely-in-typescript",
    "slug": "modeling-complex-api-responses-safely-in-typescript",
    "author": "LLM Writer",
    "tags": [
      "TypeScript",
      "React",
      "API Modeling",
      "Validation",
      "Zod",
      "Runtime Safety",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cHow do you model complex API responses safely in TypeScript?\u201d</p>\n<p>Safe modeling of complex API responses in TypeScript starts with a simple truth: API payloads are untrusted at runtime. A robust approach uses TypeScript to describe the <em>intended</em> shape, but also validates the <em>actual</em> payload at the boundary so the application does not rely on wishful casting. Once payloads are validated, discriminated unions and well-named domain types make complex responses easier to work with and harder to misuse.</p>\n\n<h2>The core risk: \u201ctyped\u201d JSON is still just JSON</h2>\n<p>A large category of frontend runtime bugs come from assuming the backend always matches interfaces. A type assertion like <code>as User</code> can silence the compiler while leaving the runtime completely unprotected.</p>\n<p>When responses are complex (nested objects, arrays, nullable fields, polymorphic items), this risk grows because it only takes one missing field or wrong union branch to break rendering in production.</p>\n\n<div class=\"example\">\n  <p><strong>Example of the common anti-pattern:</strong> casting the JSON into a TypeScript type without validation.</p>\n  <pre><code>// \u201cLooks typed\u201d but unsafe: assumes backend always matches the interface\ntype User = {\n  id: string;\n  email: string;\n  role: \"admin\" | \"member\";\n};\n\nasync function fetchUser(userId: string): Promise&lt;User&gt; {\n  const res = await fetch(`/api/users/${userId}`);\n  return (await res.json()) as User; // \u26a0\ufe0f no runtime validation\n}</code></pre>\n</div>\n\n<h2>A boundary-first strategy: validate, then type</h2>\n<p>Senior engineers typically treat API responses as a boundary problem. The boundary is where unknown data becomes trusted data. The safest pattern is to validate at runtime using a schema and then infer TypeScript types from that schema, so there is a single source of truth.</p>\n<p>This approach also improves maintainability. When the API changes, the schema fails loudly, and the compiler guides updates throughout the codebase.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> runtime schema validation with types inferred from the schema.</p>\n  <pre><code>import { z } from \"zod\";\n\n// 1) Start with runtime schemas for untrusted payloads\nconst UserSchema = z.object({\n  id: z.string(),\n  email: z.string().email(),\n  role: z.enum([\"admin\", \"member\"]),\n});\n\n// 2) Infer TypeScript types from the schema (single source of truth)\nexport type User = z.infer&lt;typeof UserSchema&gt;;\n\nexport async function fetchUser(userId: string): Promise&lt;User&gt; {\n  const res = await fetch(`/api/users/${userId}`);\n  const json = await res.json();\n  return UserSchema.parse(json); // \u2705 validates at runtime\n}</code></pre>\n</div>\n\n<h2>Model complexity explicitly: nested objects, nullability, and unions</h2>\n<p>\u201cComplex response\u201d usually means multiple kinds of complexity at once: nesting, pagination, nullable fields, and lists containing multiple item types. The maintainable approach is to model each piece with small types and compose them, instead of defining one massive interface.</p>\n<p><strong>Discriminated unions are especially valuable</strong> when an array contains multiple shapes (for example, activity feed items). They preserve type safety while keeping rendering logic straightforward.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a complex response with pagination, nullability, and a discriminated union for items.</p>\n  <pre><code>import { z } from \"zod\";\n\n// Example: a \u201ccomplex\u201d response with nested objects, nullable fields,\n// pagination metadata, and a union for \u201ckind\u201d of item.\n\nconst MoneySchema = z.object({\n  currency: z.string(),\n  amount: z.number(),\n});\n\nconst InvoiceSchema = z.object({\n  kind: z.literal(\"invoice\"),\n  id: z.string(),\n  status: z.enum([\"draft\", \"sent\", \"paid\"]),\n  total: MoneySchema,\n  // nullable fields are common in real APIs\n  paidAt: z.string().datetime().nullable(),\n});\n\nconst RefundSchema = z.object({\n  kind: z.literal(\"refund\"),\n  id: z.string(),\n  reason: z.string(),\n  amount: MoneySchema,\n});\n\nconst ActivityItemSchema = z.discriminatedUnion(\"kind\", [InvoiceSchema, RefundSchema]);\n\nconst PaginationSchema = z.object({\n  cursor: z.string().nullable(),\n  hasMore: z.boolean(),\n});\n\nexport const BillingActivityResponseSchema = z.object({\n  items: z.array(ActivityItemSchema),\n  pagination: PaginationSchema,\n});\n\nexport type BillingActivityResponse = z.infer&lt;typeof BillingActivityResponseSchema&gt;;</code></pre>\n</div>\n\n<h2>Make \u201cimpossible states\u201d unrepresentable in the UI layer</h2>\n<p>Once a payload is validated, the goal is to make it hard for components to misuse it. This usually means narrowing types at the right level: keep parsing at the boundary, keep domain decisions in domain modules, and have components consume well-shaped types.</p>\n<p>If a response has polymorphic items, the UI should switch on the discriminant (like <code>kind</code>) rather than probing optional fields and hoping they exist.</p>\n\n<div class=\"explanation\">\n  <p><strong>Type narrowing should be a feature, not a workaround.</strong> Hand-written type guards can help, but discriminated unions are typically cleaner because they make \u201cwhich shape is this?\u201d explicit in the data model.</p>\n</div>\n\n<div class=\"example\">\n  <p><strong>Illustration:</strong> manual narrowing exists, but discriminated unions usually remove the need for custom guards.</p>\n  <pre><code>function renderItem(item: { kind: \"invoice\" | \"refund\" } &amp; Record&lt;string, any&gt;) {\n  // In real code, the item would already be typed from the schema inference.\n}\n\nfunction isInvoice(item: { kind: string }): item is { kind: \"invoice\"; status: string } {\n  return item.kind === \"invoice\";\n}\n\nfunction formatActivity(item: { kind: \"invoice\" | \"refund\" } &amp; Record&lt;string, any&gt;) {\n  if (isInvoice(item)) {\n    return `Invoice (${item.status})`;\n  }\n  return \"Refund\";\n}\n\n// Better: discriminated unions do this automatically, without custom type guards.\n</code></pre>\n</div>\n\n<h2>Standardize error handling with a typed result wrapper</h2>\n<p>Complex responses are often paired with complex failure modes: partial errors, 404 vs 500 differences, validation failures, and network errors. A typed \u201cresult\u201d wrapper forces callers to handle error paths explicitly and avoids sprinkling <code>try/catch</code> and <code>undefined</code> checks across the UI.</p>\n<p>This is also a reliability win: it becomes easier to build consistent loading/error states and to attach telemetry to failures.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a validated fetch helper that returns a typed success/error result.</p>\n  <pre><code>type ApiOk&lt;T&gt; = { ok: true; data: T; receivedAt: number };\ntype ApiErr = {\n  ok: false;\n  error: { message: string; status?: number; code?: string };\n  receivedAt: number;\n};\n\ntype ApiResult&lt;T&gt; = ApiOk&lt;T&gt; | ApiErr;\n\nasync function getValidated&lt;T&gt;(\n  url: string,\n  schema: { parse: (x: unknown) =&gt; T }\n): Promise&lt;ApiResult&lt;T&gt;&gt; {\n  const receivedAt = Date.now();\n  try {\n    const res = await fetch(url);\n    if (!res.ok) {\n      return { ok: false, error: { message: \"Request failed\", status: res.status }, receivedAt };\n    }\n    const json = await res.json();\n    return { ok: true, data: schema.parse(json), receivedAt };\n  } catch {\n    return { ok: false, error: { message: \"Network error\" }, receivedAt };\n  }\n}</code></pre>\n</div>\n\n<h2>Tradeoffs and practical downsides</h2>\n<p><strong>Runtime validation adds overhead.</strong> There is development cost to writing schemas, and there is runtime cost to parsing. In most UI applications that cost is small compared to the cost of production incidents and debugging time, but it is still real.</p>\n<p><strong>Schema drift can become a problem</strong> if schemas are duplicated across frontend and backend manually. Teams often mitigate this by generating types from an API contract (OpenAPI/GraphQL) or sharing schemas when possible, while still keeping runtime validation at the boundary.</p>\n\n<h2>Conclusion</h2>\n<p>Safe modeling of complex API responses is less about clever typing tricks and more about disciplined boundaries. Validate untrusted payloads at runtime, infer TypeScript types from the validation source, and model complexity explicitly with small domain types and discriminated unions. Once those patterns are consistent, the UI becomes simpler because it consumes trusted, well-shaped data rather than defensive \u201cmaybe\u201d objects.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I treat API responses as untrusted at runtime, so I validate them at the boundary (often with a schema like Zod) and infer TypeScript types from that schema. For complex payloads, I model nested objects and pagination as small types and use discriminated unions for polymorphic arrays, so rendering code can switch on a stable <code>kind</code> field. I also standardize error handling with a typed result wrapper, and I invalidate or refetch after mutations so the UI stays correct.</p>\n</div>"
  }
]