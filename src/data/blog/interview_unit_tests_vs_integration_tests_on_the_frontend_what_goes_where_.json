[
  {
    "id": 18,
    "title": "Unit Tests vs Integration Tests on the Frontend: What Goes Where",
    "date": "January 11, 2026",
    "excerpt": "A practical decision framework for frontend testing: use unit tests for pure logic and boundary mapping, and integration tests for user-visible behavior across components, hooks, and async data.",
    "category": "Testing & Code Quality",
    "image": "https://picsum.photos/367/197?random=55",
    "link": "/blog/unit-tests-vs-integration-tests-on-the-frontend-what-goes-where",
    "slug": "unit-tests-vs-integration-tests-on-the-frontend-what-goes-where",
    "author": "LLM Writer",
    "tags": [
      "React",
      "Testing",
      "Unit Tests",
      "Integration Tests",
      "Jest",
      "Testing Library",
      "MSW",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cHow do you decide what belongs in unit tests vs integration tests on the frontend?\u201d</p>\n<p>On the frontend, the unit vs integration test decision is mostly a question of <em>what kind of failure is being prevented</em> and <em>how expensive the test will be to maintain</em>. Unit tests are best for deterministic logic and edge cases in isolation, while integration tests are best for user-visible behavior across components, hooks, and data boundaries\u2014where most real bugs actually occur.</p>\n\n<h2>Clarify the terms in a frontend context</h2>\n<p>\u201cUnit test\u201d usually means testing a small unit of code in isolation with minimal dependencies. On the frontend, that often maps to pure functions, reducers, selectors, and small mapping utilities.</p>\n<p>\u201cIntegration test\u201d typically means multiple units working together: a component rendering, user interactions, network behavior (mocked), routing, and state updates. These tests cost more to write, but they catch bugs that unit tests often miss.</p>\n\n<div class=\"explanation\">\n  <p><strong>A useful way to decide is to follow the bug.</strong> If bugs tend to happen because logic is tricky or edge-case heavy, unit tests provide fast feedback. If bugs tend to happen because pieces don\u2019t cooperate correctly (UI + state + API + async), integration tests provide better confidence.</p>\n</div>\n\n<h2>What belongs in unit tests</h2>\n<p>Unit tests pay off when the code is stable, deterministic, and easy to exercise without a browser-like environment. They are also excellent when the goal is to document tricky business rules or prevent regressions in transformation logic.</p>\n<p>Common candidates include formatting, validation, domain calculations, reducers, and \u201ccontract\u201d logic that turns untrusted API payloads into trusted domain models.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a unit test for pure formatting logic.</p>\n  <pre><code>// Unit test: pure logic (fast, deterministic)\nimport { formatMoney } from \"../formatMoney\";\n\ntest(\"formatMoney formats cents as USD\", () =&gt; {\n  expect(formatMoney({ currency: \"USD\", amountCents: 1234 })).toBe(\"$12.34\");\n});</code></pre>\n</div>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a boundary/contract unit test that prevents runtime crashes from malformed payloads.</p>\n  <pre><code>// Contract-style unit test: mapping API payload -&gt; domain model\nimport { UserSchema, toUser } from \"../domain/user\";\n\ntest(\"toUser rejects invalid payloads\", () =&gt; {\n  const bad = { id: 123, name: null };\n  expect(() =&gt; UserSchema.parse(bad)).toThrow();\n});\n\ntest(\"toUser maps valid payload\", () =&gt; {\n  const ok = { id: \"1\", name: \"A\" };\n  expect(toUser(ok)).toEqual({ id: \"1\", name: \"A\" });\n});</code></pre>\n</div>\n\n<h2>What belongs in integration tests</h2>\n<p>Integration tests are the best fit for user journeys and cross-module behavior: rendering a screen, fetching data, handling loading/error states, and responding to user interactions. These tests are especially important for async workflows, because timing issues and stale state are common sources of production bugs.</p>\n<p>They also reduce \u201ctesting the implementation\u201d and instead test observable behavior. That tends to survive refactors better, which is a major maintainability advantage in React apps.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a user flow test with mocked network requests (MSW), covering fetch + edit + save.</p>\n  <pre><code>// Integration test: component + hooks + mocked network + user events\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { server } from \"../test/msw/server\";\nimport { http, HttpResponse } from \"msw\";\nimport { ProfileEditor } from \"./ProfileEditor\";\n\ntest(\"user can update name and sees success state\", async () =&gt; {\n  server.use(\n    http.get(\"/api/users/123\", () =&gt; HttpResponse.json({ id: \"123\", name: \"Johnny\" })),\n    http.patch(\"/api/users/123\", async ({ request }) =&gt; {\n      const body = await request.json();\n      return HttpResponse.json({ id: \"123\", name: body.name });\n    })\n  );\n\n  render(&lt;ProfileEditor userId=\"123\" /&gt;);\n\n  await screen.findByDisplayValue(\"Johnny\");\n  await userEvent.clear(screen.getByLabelText(/name/i));\n  await userEvent.type(screen.getByLabelText(/name/i), \"John\");\n\n  await userEvent.click(screen.getByRole(\"button\", { name: /save/i }));\n\n  expect(await screen.findByText(/saved/i)).toBeInTheDocument();\n});</code></pre>\n</div>\n\n<h2>A practical framework senior engineers use</h2>\n<p>A maintainable testing strategy typically uses a small number of integration tests for the critical paths and a larger number of unit tests for tricky logic that would otherwise be duplicated across those integration tests.</p>\n<ul>\n  <li><strong>Test behavior at the highest level that is still stable.</strong> If the UI contract is stable, prefer integration tests.</li>\n  <li><strong>Unit test pure logic to avoid repetitive integration setups.</strong> If five integration tests would need the same edge-case rules, unit test the rule once.</li>\n  <li><strong>Prefer integration tests for async and wiring bugs.</strong> These are frequently missed by unit tests and are common in production.</li>\n  <li><strong>Keep integration tests close to user language.</strong> Use queries like \u201cgetByRole\u201d and assertions on what the user can observe.</li>\n</ul>\n\n<h2>Tradeoffs and honest downsides</h2>\n<p><strong>Unit tests can create false confidence.</strong> A codebase can have high unit test coverage and still ship broken experiences if the integration between components and data fetching is not tested. This often happens when tests over-mock internals and never render real UI.</p>\n<p><strong>Integration tests can become slow and flaky.</strong> If tests depend on real timeouts, unstable selectors, or global shared state, they can reduce velocity. Teams usually mitigate this by mocking the network deterministically (for example with MSW), avoiding real timers, and keeping test fixtures minimal.</p>\n\n<h2>A balanced testing \u201cshape\u201d that scales</h2>\n<p>Many frontend teams converge on a pyramid-like shape: lots of fast unit tests for core logic, a moderate number of integration tests for key flows, and a small number of end-to-end tests for true cross-system confidence. The exact proportions vary, but the principle is consistent: expensive tests should be fewer and more valuable.</p>\n<p>The best strategies also evolve over time. Early in a feature, a couple of integration tests can stabilize behavior. Later, recurring edge cases can be pushed down into unit-tested utilities to keep the integration tests lean.</p>\n\n<h2>Conclusion</h2>\n<p>Deciding between unit and integration tests is about maximizing confidence per minute of maintenance cost. Unit tests are ideal for deterministic logic and boundary mapping. Integration tests are ideal for user-visible behavior and async wiring, where many real frontend bugs live. A scalable strategy uses both: unit tests to lock down rules, and integration tests to prove that the UI works when those rules meet real user interactions.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I put pure, deterministic logic in unit tests\u2014formatting, validation, reducers, and API-to-domain mapping\u2014because they\u2019re fast and make edge cases explicit. I use integration tests for the user-visible workflows that commonly break: rendering a screen, fetching data, handling loading/error, and user interactions that cross components and hooks. The goal is confidence per maintenance cost, so I keep integration tests focused on critical paths and use unit tests to keep those paths from needing repeated setup.</p>\n</div>"
  }
]