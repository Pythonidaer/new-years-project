[
  {
    "id": 1,
    "title": "Reusable vs Feature-Specific Components: A Practical Decision Framework",
    "date": "January 10, 2026",
    "excerpt": "Decide whether a UI component should be reusable or feature-specific by optimizing for change and extracting only when reuse is proven.",
    "category": "Frontend Architecture",
    "image": "https://picsum.photos/367/197?random=37",
    "link": "/blog/reusable-vs-feature-specific-components-a-practical-decision-framework",
    "author": "Senior Engineer",
    "tags": [
      "react",
      "component-design",
      "frontend-architecture",
      "design-systems",
      "interview-prep"
    ],
    "content": "<h2>The short rule</h2>\n<p>Default to <strong>feature-specific</strong>. Promote to <strong>reusable</strong> only when you have evidence that reuse will reduce total cost <em>without</em> forcing a leaky, over-configurable API.</p>\n<p>In practice: <strong>start local, extract later</strong>.</p>\n\n<hr />\n\n<h2>What you\u2019re optimizing for</h2>\n<p>This decision is primarily about <strong>change</strong>:</p>\n<ul>\n  <li>Where will this component change most often?</li>\n  <li>How many places will that change need to be applied?</li>\n  <li>How expensive is it if the API is slightly wrong?</li>\n</ul>\n<p>Reusable components reduce duplicate changes, but they introduce additional costs:</p>\n<ul>\n  <li><strong>API design cost</strong> (props, states, edge cases)</li>\n  <li><strong>Coupling cost</strong> (one change can break many call sites)</li>\n  <li><strong>Complexity cost</strong> (\u201cjust add one more prop\u2026\u201d)</li>\n</ul>\n\n<hr />\n\n<h2>A simple decision framework</h2>\n\n<h3>1) Is there real duplication today?</h3>\n<ul>\n  <li><strong>No</strong> \u2192 keep it feature-specific.</li>\n  <li><strong>Yes</strong> \u2192 continue evaluating.</li>\n</ul>\n<p>Real duplication means the same structure and behavior appearing in multiple places, not just a similar idea.</p>\n\n<h3>2) Is the shared responsibility stable?</h3>\n<p>If the common responsibility is stable (for example, a Button or Modal layout), it is a good candidate for reuse. If it changes frequently, keeping it feature-specific is often cheaper.</p>\n\n<h3>3) Are the variations shallow or deep?</h3>\n<ul>\n  <li><strong>Shallow variation</strong> (text, icon, size, disabled state) \u2192 reusable components work well.</li>\n  <li><strong>Deep variation</strong> (different layouts, interactions, or data models) \u2192 extraction often creates an overly complex \u201cGod component\u201d.</li>\n</ul>\n<p>A warning sign is needing many configuration props like <code>variant</code>, <code>mode</code>, <code>layout</code>, or multiple render callbacks.</p>\n\n<h3>4) Would reuse force you to expose internal assumptions?</h3>\n<p>If reusability requires exposing internal implementation details as props, the extraction is likely happening at the wrong level or too early.</p>\n\n<h3>5) Does it need to be consistent across the product?</h3>\n<p>Some components should be reusable to enforce consistency, such as buttons, inputs, modals, accessibility patterns, and analytics hooks.</p>\n\n<hr />\n\n<h2>The \u201clevels\u201d model</h2>\n<ol>\n  <li><strong>Primitives</strong>: highly reusable (Button, Text, Icon)</li>\n  <li><strong>Patterns</strong>: reusable with constraints (ModalShell, FormField)</li>\n  <li><strong>Feature components</strong>: domain-specific (BillingPlanPicker)</li>\n  <li><strong>Screens / routes</strong>: page-level components</li>\n</ol>\n<p>Most architectural tension occurs between patterns and feature components.</p>\n\n<hr />\n\n<h2>A concrete example</h2>\n<p><strong>Bad extraction (too early):</strong></p>\n<pre><code>&lt;EditableCard variant=\"billing\" mode=\"inline\" showFooter onSave={...} /&gt;\n</code></pre>\n\n<p><strong>Better extraction (right level):</strong></p>\n<ul>\n  <li>Reusable layout primitives: Card, CardHeader, CardBody, CardFooter</li>\n  <li>Feature components compose these primitives and own their logic</li>\n</ul>\n\n<hr />\n\n<h2>Practical rules of thumb</h2>\n<p>Promote a component to reusable when:</p>\n<ul>\n  <li>There are two or three real usages</li>\n  <li>The shared behavior is stable</li>\n  <li>The API is small and hard to misuse</li>\n  <li>It enforces consistency or accessibility</li>\n</ul>\n\n<p>Keep it feature-specific when:</p>\n<ul>\n  <li>Reuse is speculative</li>\n  <li>The feature is evolving rapidly</li>\n  <li>Reusability requires many escape hatches</li>\n  <li>The component is tightly coupled to a domain</li>\n</ul>\n\n<hr />\n\n<h2>Extraction strategy</h2>\n<ol>\n  <li>Build the component feature-specific first.</li>\n  <li>Duplicate it when a second real use appears.</li>\n  <li>Compare versions to identify truly shared behavior.</li>\n  <li>Extract stable primitives or patterns.</li>\n  <li>Keep feature components thin and compositional.</li>\n</ol>\n\n<hr />\n\n<h2>Interview-ready closer</h2>\n<p>I default to feature-specific components and extract reuse when real duplication appears. I extract at the lowest stable level to avoid over-configurable components. Reuse is worth it when it reduces the cost of change and enforces consistency.</p>"
  }
]