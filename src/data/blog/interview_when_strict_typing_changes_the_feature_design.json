[
  {
    "id": 14,
    "title": "When Strict Typing Changes the Feature Design",
    "date": "January 11, 2026",
    "excerpt": "A concrete example of strict typing reshaping feature design: modeling a multi-step flow as explicit states and transitions to make invalid UI states impossible.",
    "category": "JavaScript & TypeScript",
    "image": "https://picsum.photos/367/197?random=51",
    "link": "/blog/when-strict-typing-changes-the-feature-design",
    "slug": "when-strict-typing-changes-the-feature-design",
    "author": "LLM Writer",
    "tags": [
      "React",
      "TypeScript",
      "State Modeling",
      "Runtime Safety",
      "Architecture",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cDescribe a situation where strict typing significantly changed how you designed a feature.\u201d</p>\n<p>A strong example is one where types did not just \u201cadd safety,\u201d but actively reshaped the feature so invalid states could not exist. In practice, strict typing most often changes the design of multi-step flows, permission-driven UIs, and any feature where \u201cthis field is required only when X is true\u201d shows up repeatedly.</p>\n\n<h2>A realistic scenario: a multi-step checkout wizard</h2>\n<p>Consider a checkout flow with steps like shipping, payment, and review. Early versions of these flows are often built with a single \u201cwizard state\u201d object and a handful of optional fields. The UI works until edge cases accumulate: users jump steps, refresh mid-flow, or a partial response arrives and leaves the state half-populated.</p>\n<p>In that style of implementation, runtime bugs typically come from assumptions like \u201cpaymentToken exists by the time review renders,\u201d even though the type system still allows it to be undefined.</p>\n\n<div class=\"example\">\n  <p><strong>Before:</strong> a single object with optional fields forces the UI to constantly guess what is safe.</p>\n  <pre><code>// Before: loosely typed wizard state (bugs show up at runtime)\ntype WizardState = {\n  step: string;                 // \"shipping\" | \"payment\" | \"review\" (but not enforced)\n  shippingAddress?: Address;    // required for \"review\" but optional here\n  paymentToken?: string;        // required for \"review\" but optional here\n  error?: string;\n};\n\nfunction canSubmit(state: WizardState) {\n  return !!state.shippingAddress &amp;&amp; !!state.paymentToken;\n}</code></pre>\n</div>\n\n<h2>How strict typing changes the design</h2>\n<p>With strict typing enabled, the most valuable question becomes: \u201cWhy is the type system allowing impossible combinations?\u201d If review cannot exist without both a shipping address and a payment token, the state model can encode that truth directly.</p>\n<p><strong>The design shift is from \u2018optional fields + checks everywhere\u2019 to \u2018explicit states + controlled transitions.\u2019</strong> This turns a bug-prone flow into a small state machine where the current step determines what data must be present.</p>\n\n<div class=\"explanation\">\n  <p><strong>This approach prevents a category of runtime bugs by construction.</strong> If the review step requires a token, the type system can make it impossible to build a review state without one. That eliminates \u201cundefined access\u201d bugs and reduces defensive coding in UI components.</p>\n</div>\n\n<div class=\"example\">\n  <p><strong>After:</strong> discriminated unions make invalid combinations unrepresentable, and transitions encode rules.</p>\n  <pre><code>// After: discriminated union makes invalid states unrepresentable\ntype ShippingStep = {\n  step: \"shipping\";\n  shippingAddress?: Address;\n};\n\ntype PaymentStep = {\n  step: \"payment\";\n  shippingAddress: Address;     // guaranteed once shipping is complete\n  paymentToken?: string;\n};\n\ntype ReviewStep = {\n  step: \"review\";\n  shippingAddress: Address;\n  paymentToken: string;         // required to reach review\n};\n\ntype WizardState = ShippingStep | PaymentStep | ReviewStep;\n\nfunction canSubmit(state: WizardState): state is ReviewStep {\n  return state.step === \"review\";\n}\n\nfunction next(state: WizardState): WizardState {\n  switch (state.step) {\n    case \"shipping\":\n      if (!state.shippingAddress) return state;\n      return { step: \"payment\", shippingAddress: state.shippingAddress };\n    case \"payment\":\n      if (!state.paymentToken) return state;\n      return { step: \"review\", shippingAddress: state.shippingAddress, paymentToken: state.paymentToken };\n    case \"review\":\n      return state;\n  }\n}</code></pre>\n</div>\n\n<h2>What changes in the React component layer</h2>\n<p>Once the state model becomes explicit, the UI gets simpler. Rendering becomes a straight switch on the step, and the compiler guarantees that required data is available in the branches where it should be available.</p>\n<p>This also tends to improve developer experience: components no longer need repeated null checks, and reviewers can trust that the model enforces key invariants.</p>\n\n<div class=\"example\">\n  <p><strong>UI impact:</strong> the review screen can safely rely on required fields with no defensive checks.</p>\n  <pre><code>function CheckoutWizard({ state }: { state: WizardState }) {\n  switch (state.step) {\n    case \"shipping\":\n      return &lt;ShippingForm defaultAddress={state.shippingAddress} /&gt;;\n    case \"payment\":\n      return &lt;PaymentForm shippingAddress={state.shippingAddress} defaultToken={state.paymentToken} /&gt;;\n    case \"review\":\n      // \u2705 compile-time: shippingAddress and paymentToken are guaranteed here\n      return &lt;Review shippingAddress={state.shippingAddress} paymentToken={state.paymentToken} /&gt;;\n  }\n}</code></pre>\n</div>\n\n<h2>Secondary benefits that show up as the feature evolves</h2>\n<p>Strict typing often pays off more over time than on day one. When a new step is introduced (for example, \u201cdiscounts\u201d or \u201cidentity verification\u201d), the compiler forces updates everywhere the flow is handled. That prevents \u201cforgot to update one screen\u201d regressions.</p>\n<p>It also encourages clearer APIs. Instead of passing a large bag of optional props through many components, the UI can pass the exact state variant the child expects.</p>\n\n<h2>Tradeoffs and what gets harder</h2>\n<p><strong>The biggest tradeoff is upfront modeling work.</strong> Discriminated unions and explicit transitions require more thought than throwing optional fields into an object. That can feel slower early on, especially when requirements are still changing.</p>\n<p><strong>There is also a readability risk.</strong> If the type modeling becomes too clever (deep conditional types, heavy generics), the feature can become harder for the team to maintain. The best outcomes usually come from types that are domain-shaped and easy to explain.</p>\n\n<h2>How to explain this in an interview</h2>\n<p>Interviewers are usually listening for two things: the specific bug class that was eliminated, and the design principle that replaced it. The most compelling explanation names the invariant (\u201creview cannot exist without paymentToken\u201d) and shows how the type system enforced it.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I worked on a multi-step flow where we originally modeled wizard state as one object with lots of optional fields. With strict typing on, it became obvious we were allowing impossible states\u2014like rendering a review step without required data. I redesigned the state as a discriminated union per step and encoded transitions so the compiler guaranteed required fields at each step. That reduced defensive null checks, eliminated a bunch of runtime edge-case bugs, and made later changes safer because adding a new step forced all the right updates at compile time.</p>\n</div>"
  }
]