[
  {
    "id": 9,
    "title": "Async Data Fetching, Caching, and Invalidation in React",
    "date": "January 11, 2026",
    "excerpt": "A practical way to handle server state in React: standardize fetching through a query cache, tune freshness and retention, and keep UI correct with targeted invalidation and occasional optimistic updates.",
    "category": "State Management & Data Flow",
    "image": "https://picsum.photos/367/197?random=46",
    "link": "/blog/async-data-fetching-caching-and-invalidation-in-react",
    "slug": "async-data-fetching-caching-and-invalidation-in-react",
    "author": "Senior Engineer",
    "tags": [
      "React",
      "Data Fetching",
      "Caching",
      "Invalidation",
      "Async",
      "Architecture",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cDescribe how you handle async data fetching, caching, and invalidation in React.\u201d</p>\n<p>In production React apps, async data is usually treated as its own layer: fetching, caching, and invalidation are handled consistently so the UI can stay simple. The common approach is to separate \u201cserver state\u201d (API data) from local UI state, use a query cache with clear keys, and invalidate or update caches in response to mutations so the UI stays correct without manual prop threading.</p>\n\n<h2>Start by separating \u201cserver state\u201d from \u201cUI state\u201d</h2>\n<p>Most complexity comes from mixing concerns. Server state is data that comes from an API and can be stale, refetched, paginated, or invalidated. UI state is transient interaction state like \u201cis a dropdown open?\u201d or \u201cwhat tab is selected?\u201d</p>\n<p>Once this distinction is made, the design becomes clearer: UI state usually belongs in components, while server state benefits from a dedicated caching strategy and standardized patterns.</p>\n\n<div class=\"explanation\">\n  <p><strong>Caching and invalidation are about correctness over time.</strong> A cache is only helpful if there is a reliable way to decide when cached data should be considered out of date and refreshed. Invalidation is the mechanism that tells the system, \u201csomething changed; refetch or recompute.\u201d</p>\n</div>\n\n<h2>A typical modern default: a query cache layer</h2>\n<p>Most teams avoid reinventing caching and invalidation by adopting a query/caching library. The exact library varies, but the core ideas are consistent: identify data with a stable query key, deduplicate in-flight requests, cache results, and provide lifecycle hooks for refresh and mutation.</p>\n<p>This reduces custom \u201cuseEffect fetch\u201d code scattered across the codebase and prevents bugs like double-fetching, race conditions, and inconsistent loading/error behavior.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> a query hook that encodes caching behavior alongside the fetch function.</p>\n  <pre><code>// Example with a query/caching library (pseudo-code shaped like TanStack Query)\nfunction useUser(userId) {\n  return useQuery({\n    queryKey: [\"user\", userId],\n    queryFn: () =&gt; fetch(`/api/users/${userId}`).then((r) =&gt; r.json()),\n    staleTime: 30_000,      // treat data as fresh for 30s\n    gcTime: 10 * 60_000,    // keep in cache for 10m after last use\n    retry: 2,\n  });\n}\n\nfunction UserProfile({ userId }) {\n  const { data, isLoading, error, refetch } = useUser(userId);\n\n  if (isLoading) return &lt;Spinner /&gt;;\n  if (error) return &lt;ErrorState onRetry={refetch} /&gt;;\n\n  return &lt;ProfileCard user={data} /&gt;;\n}</code></pre>\n</div>\n\n<h2>How caching is configured in practice</h2>\n<p>Caching is not a single switch; it is a set of policies. Two of the most important are \u201cfreshness\u201d and \u201cretention.\u201d Freshness answers \u201cwhen should the UI refetch?\u201d Retention answers \u201chow long should unused data stay in memory?\u201d</p>\n<p><strong>A common pattern is \u201cstale-while-revalidate.\u201d</strong> The UI can render cached data immediately (even if slightly stale) and then refresh in the background. This keeps the UI responsive and reduces loading spinners, while still converging toward correctness.</p>\n\n<h2>Invalidation: the core of correctness after mutations</h2>\n<p>Fetching is easy; staying correct after data changes is the harder part. When a mutation happens (create/update/delete), the cache must be updated so other screens reflect the change.</p>\n<p>Most teams do this with targeted invalidation: invalidate the precise queries impacted by the mutation rather than clearing the entire cache. This keeps the app correct without triggering unnecessary network traffic.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> invalidating related queries after a successful update.</p>\n  <pre><code>// Mutation + targeted invalidation\nfunction useUpdateUser(userId) {\n  const qc = useQueryClient();\n\n  return useMutation({\n    mutationFn: (patch) =&gt;\n      fetch(`/api/users/${userId}`, { method: \"PATCH\", body: JSON.stringify(patch) }),\n    onSuccess: async () =&gt; {\n      // invalidate all caches that depend on this user\n      await qc.invalidateQueries({ queryKey: [\"user\", userId] });\n      await qc.invalidateQueries({ queryKey: [\"usersList\"] });\n    },\n  });\n}</code></pre>\n</div>\n\n<h2>When to invalidate vs directly update the cache</h2>\n<p>Invalidation is the safer default because the server remains the source of truth. It is especially appropriate when the mutation has complex side effects or the server returns derived fields.</p>\n<p>Direct cache updates can be better when the change is small and well understood (for example, updating a local count or toggling a flag). This can make the UI feel instant, but it increases the chance of drifting from server truth if the mutation fails or triggers additional server-side changes.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> an optimistic update that updates the UI immediately, then rolls back on error.</p>\n  <pre><code>// Optimistic update sketch\nfunction useToggleFavorite(itemId) {\n  const qc = useQueryClient();\n\n  return useMutation({\n    mutationFn: () =&gt; fetch(`/api/items/${itemId}/favorite`, { method: \"POST\" }),\n    onMutate: async () =&gt; {\n      await qc.cancelQueries({ queryKey: [\"item\", itemId] });\n\n      const prev = qc.getQueryData([\"item\", itemId]);\n      qc.setQueryData([\"item\", itemId], (old) =&gt; ({ ...old, favorite: !old.favorite }));\n\n      return { prev };\n    },\n    onError: (_err, _vars, ctx) =&gt; {\n      if (ctx?.prev) qc.setQueryData([\"item\", itemId], ctx.prev);\n    },\n    onSettled: async () =&gt; {\n      await qc.invalidateQueries({ queryKey: [\"item\", itemId] });\n    },\n  });\n}</code></pre>\n</div>\n\n<h2>Other concerns that appear in \u201creal\u201d apps</h2>\n<p>Large apps typically add a few more practices once the basics are in place. These are not exotic, but they are where teams usually win or lose reliability.</p>\n\n<ul>\n  <li><strong>Request deduplication and cancellation:</strong> prevent multiple components from triggering identical requests and avoid updating state from stale responses.</li>\n  <li><strong>Pagination and infinite lists:</strong> model caches per page or cursor, and be explicit about merge behavior.</li>\n  <li><strong>Prefetching:</strong> preload likely-next data (for example, on hover or on route transition) to reduce perceived latency.</li>\n  <li><strong>Error and retry policy:</strong> decide which endpoints should retry, which should fail fast, and how to surface errors in a consistent UI pattern.</li>\n  <li><strong>Auth and caching boundaries:</strong> ensure caches are cleared or scoped appropriately when users change sessions.</li>\n</ul>\n\n<h2>Tradeoffs and common failure modes</h2>\n<p><strong>The most common failure is inconsistent patterns.</strong> If some parts of the app use ad-hoc <code>useEffect</code> fetching while others use a cache layer, behavior diverges and bugs become hard to reproduce.</p>\n<p><strong>Another failure mode is over-invalidation.</strong> Invalidating too broadly can cause excessive refetching, flickering UI, and wasted bandwidth. The opposite is also risky: missing an invalidation path leads to stale, incorrect screens that look \u201cfine\u201d until a user notices a discrepancy.</p>\n\n<h2>Conclusion</h2>\n<p>Handling async data well in React usually means treating server data as a first-class concern: standardizing fetching through a query layer, using clear query keys, and defining a deliberate invalidation strategy after mutations. When those pieces are consistent, components become simpler because loading, caching, and refresh logic are no longer reinvented per screen.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I treat API data as server state and handle it through a query cache layer with stable query keys, consistent loading/error patterns, and clear freshness policies. For mutations, I either invalidate the specific affected queries or update the cache directly when the change is simple, using optimistic updates with rollback when it improves UX. The goal is correctness after change without over-refetching, so the UI stays fast and predictable.</p>\n</div>"
  }
]