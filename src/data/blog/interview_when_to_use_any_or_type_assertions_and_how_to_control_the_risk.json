[
  {
    "id": 16,
    "title": "When to Use any or Type Assertions and How to Control the Risk",
    "date": "January 11, 2026",
    "excerpt": "A practical policy for using TypeScript escape hatches: when any or assertions are acceptable, and how to contain the blast radius with boundaries, validation, wrappers, and linting.",
    "category": "JavaScript & TypeScript",
    "image": "https://picsum.photos/367/197?random=53",
    "link": "/blog/when-to-use-any-or-type-assertions-and-how-to-control-the-risk",
    "slug": "when-to-use-any-or-type-assertions-and-how-to-control-the-risk",
    "author": "Senior Engineer",
    "tags": [
      "TypeScript",
      "React",
      "Typing",
      "Runtime Safety",
      "Linting",
      "Architecture",
      "Interview Prep"
    ],
    "content": "<p><strong>Interview question:</strong> \u201cWhen do you allow any or type assertions, and how do you control the risk?\u201d</p>\n<p>In strict TypeScript codebases, <code>any</code> and type assertions are treated like sharp tools: allowed in narrow situations, but contained so they do not quietly spread unsafety through the app. Senior engineers typically allow them at system boundaries (untyped third-party libraries, dynamic runtime inputs, legacy code interop) and then control risk by narrowing early, wrapping unsafe APIs, and enforcing lint and architectural guardrails.</p>\n\n<h2>First, name the difference: <code>any</code> vs type assertions</h2>\n<p><code>any</code> disables type checking for a value and everything that touches it, which is why it tends to spread. Type assertions (<code>as Something</code>) keep the rest of the type system intact but tell the compiler \u201ctrust this,\u201d even if it cannot be proven.</p>\n<p><strong>Both bypass safety, but in different ways.</strong> <code>any</code> removes checks; assertions can create false confidence. The risk controls are therefore about minimizing scope and proving the assumption as close to the boundary as possible.</p>\n\n<div class=\"explanation\">\n  <p><strong>A helpful principle is \u201cearn your types.\u201d</strong> If a value comes from outside the type system (network, storage, DOM, third-party libraries), the code should treat it as <code>unknown</code> and narrow it intentionally. If a type must be asserted, it should be backed by a runtime check or a local invariant.</p>\n</div>\n\n<h2>When <code>any</code> is usually acceptable</h2>\n<p>Most mature codebases try to avoid raw <code>any</code> in application logic. The most defensible uses are cases where strong typing is not realistically available, but the integration is still required.</p>\n\n<ul>\n  <li><strong>Third-party libraries with missing or incorrect types</strong>, especially older scripts injected globally.</li>\n  <li><strong>Legacy migration windows</strong>, where a module is being converted incrementally and a temporary bridge is needed.</li>\n  <li><strong>Truly dynamic data</strong> where the shape is not known until runtime and will be validated manually.</li>\n</ul>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> isolate <code>any</code> to a wrapper instead of spreading it through the codebase.</p>\n  <pre><code>// Third-party library with incomplete typings\ndeclare const analytics: any;\n\n// Constrain the blast radius by wrapping it:\ntype TrackProps = { event: string; properties?: Record&lt;string, unknown&lt; };\n\nexport function track({ event, properties }: TrackProps) {\n  // isolate any to one place\n  analytics.track(event, properties);\n}</code></pre>\n</div>\n\n<p>The key is that consumers call a typed wrapper, not the raw <code>any</code> API. This contains the blast radius and makes it obvious where unsafety lives.</p>\n\n<h2>When type assertions are reasonable</h2>\n<p>Assertions can be appropriate when the code has a runtime guarantee that TypeScript cannot express, or when the code has already performed a check that makes the assertion safe.</p>\n<p>Common examples include: asserting a DOM node exists after a null check, asserting a JSON payload matches a schema after validation, or asserting a discriminant field after narrowing.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> assertion after a runtime check, not instead of it.</p>\n  <pre><code>// Sometimes an assertion is reasonable when runtime guarantees exist\n// Example: a DOM element exists because it is rendered conditionally in the same component\n\nconst el = document.getElementById(\"modal-root\");\nif (!el) throw new Error(\"modal-root missing\");\nconst modalRoot = el as HTMLElement; // assertion after runtime check\n</code></pre>\n</div>\n\n<h2>Prefer narrowing and validation over \u201ctrust me\u201d casts</h2>\n<p>A safe pattern is to accept untrusted inputs as <code>unknown</code>, then narrow or validate them immediately. This is both safer and easier to debug because failures happen at the edge, close to the source.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> boundary parsing that returns a typed structure without leaking <code>any</code>.</p>\n  <pre><code>// Boundary pattern: accept unknown, validate/narrow, then return typed data\nfunction parseFeatureFlags(input: unknown): Record&lt;string, boolean&lt; {\n  if (typeof input !== \"object\" || input === null) return {};\n  const obj = input as Record&lt;string, unknown&lt;;\n\n  const flags: Record&lt;string, boolean&lt; = {};\n  for (const [k, v] of Object.entries(obj)) {\n    if (typeof v === \"boolean\") flags[k] = v;\n  }\n  return flags;\n}</code></pre>\n</div>\n\n<h2>Risk controls that keep the codebase healthy</h2>\n<p>Allowing <code>any</code> or assertions without guardrails tends to regress the codebase back to \u201cJavaScript with types sprinkled on top.\u201d Teams usually control the risk with both technical constraints and cultural norms.</p>\n\n<ul>\n  <li><strong>Lint rules:</strong> enforce <code>no-explicit-any</code>, allow it only with an inline comment and a ticket reference, or only in specific directories.</li>\n  <li><strong>Boundary modules:</strong> keep integrations and parsing in a dedicated layer (for example, <code>src/services/</code> or <code>src/shared/lib/</code>).</li>\n  <li><strong>Typed wrappers:</strong> wrap untyped APIs and export safe functions/types.</li>\n  <li><strong>Runtime validation at edges:</strong> validate API and storage inputs before asserting types downstream.</li>\n  <li><strong>Prefer <code>satisfies</code> for constants:</strong> it checks shape without losing inference, reducing the temptation to cast.</li>\n</ul>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> <code>satisfies</code> reduces unnecessary assertions when defining typed constants.</p>\n  <pre><code>// Prefer `satisfies` to preserve inference without widening\nconst routes = {\n  home: \"/\",\n  settings: \"/settings\",\n  billing: \"/billing\",\n} satisfies Record&lt;string, `/${string}`&lt;;\n\n// routes.billing is still the literal \"/billing\", not just string\n</code></pre>\n</div>\n\n<p>Compiler settings also matter. Enabling strictness flags makes it harder for unsafe patterns to sneak in unnoticed.</p>\n\n<div class=\"example\">\n  <p><strong>Example:</strong> strict compiler options that reduce accidental unsafety.</p>\n  <pre><code>// tsconfig.json (conceptual)\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"useUnknownInCatchVariables\": true,\n    \"noUncheckedIndexedAccess\": true\n  }\n}</code></pre>\n</div>\n\n<h2>Tradeoffs and the honest downside</h2>\n<p><strong>Sometimes safety costs time.</strong> Wrapping a third-party integration or modeling a dynamic payload can take longer than casting. The tradeoff is that the time saved now often becomes time lost later in debugging and regressions.</p>\n<p><strong>Overly strict policies can also slow teams down.</strong> If developers cannot ship without perfectly modeling every edge case, they may bypass the system in worse ways. Healthy teams allow escape hatches, but require them to be isolated and justified.</p>\n\n<h2>Conclusion</h2>\n<p><code>any</code> and type assertions are appropriate when reality is messy: untyped dependencies, dynamic runtime inputs, and incremental migrations. The maintainable approach is to keep unsafety at the boundary, validate or narrow as early as possible, and expose typed wrappers so the rest of the app remains strongly typed. Used this way, escape hatches unblock delivery without quietly compromising the whole codebase.</p>\n\n<div class=\"takeaway\">\n  <p><strong>Interview-ready answer (example of what a candidate might say out loud):</strong> I allow <code>any</code> and assertions mainly at boundaries\u2014third-party APIs with poor typings, legacy interop, or truly dynamic inputs. I control risk by isolating them in a wrapper or boundary module, validating/narrowing immediately (often starting from <code>unknown</code>), and exporting a typed interface so the unsafety doesn\u2019t spread. I also enforce lint rules and strict compiler flags so ...\n</div>"
  }
]