{
  "summary": {
    "totalMismatches": 125,
    "totalFunctions": 708,
    "categories": {
      "(none)": 16,
      "under-counting": 42,
      "over-counting": 55,
      "forEach callback": 12,
      "other": 0
    },
    "largestDiscrepancies": {
      "underCounting": [
        {
          "functionName": "processLineInFunctionBody",
          "file": "scripts/function-boundaries.js",
          "line": 736,
          "difference": -18,
          "actualComplexity": 53,
          "calculatedTotal": 35
        },
        {
          "functionName": "logComplexityMismatch",
          "file": "scripts/html-generators.js",
          "line": 1035,
          "difference": -6,
          "actualComplexity": 10,
          "calculatedTotal": 4
        },
        {
          "functionName": "findNamedFunctionEnd",
          "file": "scripts/function-boundaries.js",
          "line": 869,
          "difference": -5,
          "actualComplexity": 9,
          "calculatedTotal": 4
        },
        {
          "functionName": "processSubsequentLine",
          "file": "scripts/decision-points.js",
          "line": 2068,
          "difference": -5,
          "actualComplexity": 9,
          "calculatedTotal": 4
        },
        {
          "functionName": "parseDestructuredAssignments",
          "file": "scripts/decision-points.js",
          "line": 3155,
          "difference": -5,
          "actualComplexity": 9,
          "calculatedTotal": 4
        },
        {
          "functionName": "findBoundaryForFunction",
          "file": "scripts/html-generators.js",
          "line": 996,
          "difference": -5,
          "actualComplexity": 7,
          "calculatedTotal": 2
        },
        {
          "functionName": "AudioControl (useEffect callback)",
          "file": "src/components/AudioControl/AudioControl.tsx",
          "line": 22,
          "difference": -5,
          "actualComplexity": 8,
          "calculatedTotal": 3
        },
        {
          "functionName": "findObjectLiteralClosingParen",
          "file": "scripts/function-boundaries.js",
          "line": 153,
          "difference": -4,
          "actualComplexity": 7,
          "calculatedTotal": 3
        },
        {
          "functionName": "findMatchingColonOnSameLine",
          "file": "scripts/decision-points.js",
          "line": 1842,
          "difference": -4,
          "actualComplexity": 8,
          "calculatedTotal": 4
        },
        {
          "functionName": "handleBackdropClick (useCallback callback)",
          "file": "src/components/ThemePicker/ThemePicker.tsx",
          "line": 704,
          "difference": -4,
          "actualComplexity": 6,
          "calculatedTotal": 2
        }
      ],
      "overCounting": [
        {
          "functionName": "useMetaTags",
          "file": "src/hooks/useMetaTags.ts",
          "line": 132,
          "difference": 3,
          "actualComplexity": 6,
          "calculatedTotal": 9
        },
        {
          "functionName": "BlogFilters (useEffect callback)",
          "file": "src/sections/BlogFilters/index.tsx",
          "line": 26,
          "difference": 3,
          "actualComplexity": 3,
          "calculatedTotal": 6
        },
        {
          "functionName": "findNamedFunctionStart",
          "file": "scripts/function-boundaries.js",
          "line": 993,
          "difference": 2,
          "actualComplexity": 6,
          "calculatedTotal": 8
        },
        {
          "functionName": "processSwitchAndCatch",
          "file": "scripts/decision-points.js",
          "line": 3399,
          "difference": 2,
          "actualComplexity": 9,
          "calculatedTotal": 11
        },
        {
          "functionName": "hasFunctionSignature",
          "file": "scripts/decision-points.js",
          "line": 1008,
          "difference": 2,
          "actualComplexity": 7,
          "calculatedTotal": 9
        },
        {
          "functionName": "handleFunctionDeclaration",
          "file": "scripts/function-extraction.js",
          "line": 236,
          "difference": 2,
          "actualComplexity": 5,
          "calculatedTotal": 7
        },
        {
          "functionName": "getDefaultCallbackLabel",
          "file": "scripts/function-hierarchy.js",
          "line": 416,
          "difference": 2,
          "actualComplexity": 7,
          "calculatedTotal": 9
        },
        {
          "functionName": "determineLineClasses (map callback)",
          "file": "scripts/html-generators.js",
          "line": 1162,
          "difference": 2,
          "actualComplexity": 1,
          "calculatedTotal": 3
        },
        {
          "functionName": "setConditionalMetaTags",
          "file": "src/hooks/useMetaTags.ts",
          "line": 80,
          "difference": 2,
          "actualComplexity": 1,
          "calculatedTotal": 3
        },
        {
          "functionName": "useImagePreload (useEffect callback)",
          "file": "src/hooks/useImagePreload.ts",
          "line": 13,
          "difference": 2,
          "actualComplexity": 3,
          "calculatedTotal": 5
        }
      ]
    }
  },
  "categorized": {
    "(none)": [
      {
        "functionName": "PresetSection",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 282,
        "actualComplexity": 8,
        "calculatedTotal": 1,
        "difference": -7,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 282,
          "end": 301
        },
        "functionCode": [
          {
            "lineNum": 282,
            "content": "function PresetSection({"
          },
          {
            "lineNum": 283,
            "content": "  presets,"
          },
          {
            "lineNum": 284,
            "content": "  currentPresetId,"
          },
          {
            "lineNum": 285,
            "content": "  isPresetsExpanded,"
          },
          {
            "lineNum": 286,
            "content": "  isPresetsHeaderCollapsed,"
          },
          {
            "lineNum": 287,
            "content": "  showSavePreset,"
          },
          {
            "lineNum": 288,
            "content": "  presetName,"
          },
          {
            "lineNum": 289,
            "content": "  onLoadPreset,"
          },
          {
            "lineNum": 290,
            "content": "  onDeletePreset,"
          },
          {
            "lineNum": 291,
            "content": "  onToggleExpanded,"
          },
          {
            "lineNum": 292,
            "content": "  onPresetsHeaderKeyDown,"
          },
          {
            "lineNum": 293,
            "content": "  onShowSavePreset,"
          },
          {
            "lineNum": 294,
            "content": "  onSavePreset,"
          },
          {
            "lineNum": 295,
            "content": "  onSavePresetKeyDown,"
          },
          {
            "lineNum": 296,
            "content": "  onPresetNameChange,"
          },
          {
            "lineNum": 297,
            "content": "  onCancelSavePreset,"
          },
          {
            "lineNum": 298,
            "content": "  styles,"
          },
          {
            "lineNum": 299,
            "content": "}: PresetSectionProps) {"
          },
          {
            "lineNum": 300,
            "content": "  return ("
          },
          {
            "lineNum": 301,
            "content": "    <div className={styles.presetsSection}>"
          }
        ]
      },
      {
        "functionName": "shouldSkipQuestionMark",
        "file": "scripts/decision-points.js",
        "line": 2262,
        "actualComplexity": 6,
        "calculatedTotal": 1,
        "difference": -5,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2262,
          "end": 2284
        },
        "functionCode": [
          {
            "lineNum": 2262,
            "content": "  const shouldSkipQuestionMark = (lineWithoutComments, questionIndex) => {"
          },
          {
            "lineNum": 2263,
            "content": "    // Skip if it's optional chaining (?.)"
          },
          {
            "lineNum": 2264,
            "content": "    if (questionIndex + 1 < lineWithoutComments.length && lineWithoutComments[questionIndex + 1] === '.') {"
          },
          {
            "lineNum": 2265,
            "content": "      return 2;"
          },
          {
            "lineNum": 2266,
            "content": "    }"
          },
          {
            "lineNum": 2267,
            "content": "    "
          },
          {
            "lineNum": 2268,
            "content": "    // Skip if inside a regex pattern (e.g., /(?:export\\s+)?function/)"
          },
          {
            "lineNum": 2269,
            "content": "    if (isInsideRegexPattern(lineWithoutComments, questionIndex)) {"
          },
          {
            "lineNum": 2270,
            "content": "      return 1;"
          },
          {
            "lineNum": 2271,
            "content": "    }"
          },
          {
            "lineNum": 2272,
            "content": "    "
          },
          {
            "lineNum": 2273,
            "content": "    // Skip if inside a regular string literal"
          },
          {
            "lineNum": 2274,
            "content": "    if (isQuestionMarkInRegularString(lineWithoutComments, questionIndex)) {"
          },
          {
            "lineNum": 2275,
            "content": "      return 1;"
          },
          {
            "lineNum": 2276,
            "content": "    }"
          },
          {
            "lineNum": 2277,
            "content": "    "
          },
          {
            "lineNum": 2278,
            "content": "    // Skip if TypeScript optional parameter"
          },
          {
            "lineNum": 2279,
            "content": "    if (isTypeScriptOptionalParameter(lineWithoutComments, questionIndex)) {"
          },
          {
            "lineNum": 2280,
            "content": "      return 1;"
          },
          {
            "lineNum": 2281,
            "content": "    }"
          },
          {
            "lineNum": 2282,
            "content": "    "
          },
          {
            "lineNum": 2283,
            "content": "    return 0;"
          },
          {
            "lineNum": 2284,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "handleHashClick",
        "file": "src/sections/Header/index.tsx",
        "line": 19,
        "actualComplexity": 6,
        "calculatedTotal": 1,
        "difference": -5,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 19,
          "end": 38
        },
        "functionCode": [
          {
            "lineNum": 19,
            "content": "  const handleHashClick = (e: React.MouseEvent<HTMLAnchorElement>) => {"
          },
          {
            "lineNum": 20,
            "content": "    // Close mobile menu if open"
          },
          {
            "lineNum": 21,
            "content": "    setIsMenuOpen(false);"
          },
          {
            "lineNum": 22,
            "content": "    "
          },
          {
            "lineNum": 23,
            "content": "    // If we're already on the home page with the same hash, manually scroll"
          },
          {
            "lineNum": 24,
            "content": "    const hash = (e.currentTarget.getAttribute('href') || '').split('#')[1];"
          },
          {
            "lineNum": 25,
            "content": "    if (hash && location.pathname === \"/\" && location.hash === `#${hash}`) {"
          },
          {
            "lineNum": 26,
            "content": "      e.preventDefault();"
          },
          {
            "lineNum": 27,
            "content": "      const element = document.querySelector(`#${hash}`);"
          },
          {
            "lineNum": 28,
            "content": "      if (element) {"
          },
          {
            "lineNum": 29,
            "content": "        const headerOffset = 110;"
          },
          {
            "lineNum": 30,
            "content": "        const elementPosition = element.getBoundingClientRect().top;"
          },
          {
            "lineNum": 31,
            "content": "        const offsetPosition = elementPosition + window.scrollY - headerOffset;"
          },
          {
            "lineNum": 32,
            "content": "        window.scrollTo({"
          },
          {
            "lineNum": 33,
            "content": "          top: offsetPosition,"
          },
          {
            "lineNum": 34,
            "content": "          behavior: \"smooth\","
          },
          {
            "lineNum": 35,
            "content": "        });"
          },
          {
            "lineNum": 36,
            "content": "      }"
          },
          {
            "lineNum": 37,
            "content": "    }"
          },
          {
            "lineNum": 38,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "handleFunctionBodyStart",
        "file": "scripts/function-boundaries.js",
        "line": 628,
        "actualComplexity": 5,
        "calculatedTotal": 1,
        "difference": -4,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 628,
          "end": 646
        },
        "functionCode": [
          {
            "lineNum": 628,
            "content": "function handleFunctionBodyStart(line, i, lines) {"
          },
          {
            "lineNum": 629,
            "content": "  const hasFunctionBodyPattern = /\\)\\s*[:\\w\\s<>\\[\\]|'\"]*\\s*\\{/.test(line);"
          },
          {
            "lineNum": 630,
            "content": "  const isFunctionDeclaration = isFunctionDeclarationPattern(line);"
          },
          {
            "lineNum": 631,
            "content": "  const hasArrowFunction = line.includes('=>') && !line.includes('{');"
          },
          {
            "lineNum": 632,
            "content": "  "
          },
          {
            "lineNum": 633,
            "content": "  if (hasFunctionBodyPattern || isFunctionDeclaration) {"
          },
          {
            "lineNum": 634,
            "content": "    // Function body starts here"
          },
          {
            "lineNum": 635,
            "content": "    const braceCount = calculateFunctionBodyBraceCount(line);"
          },
          {
            "lineNum": 636,
            "content": "    return { inFunctionBody: true, braceCount, end: null };"
          },
          {
            "lineNum": 637,
            "content": "  }"
          },
          {
            "lineNum": 638,
            "content": "  "
          },
          {
            "lineNum": 639,
            "content": "  if (hasArrowFunction) {"
          },
          {
            "lineNum": 640,
            "content": "    // Arrow function without braces"
          },
          {
            "lineNum": 641,
            "content": "    const end = handleArrowFunctionWithoutBraces(lines, i);"
          },
          {
            "lineNum": 642,
            "content": "    return { inFunctionBody: true, braceCount: 0, end };"
          },
          {
            "lineNum": 643,
            "content": "  }"
          },
          {
            "lineNum": 644,
            "content": "  "
          },
          {
            "lineNum": 645,
            "content": "  return { inFunctionBody: false, braceCount: 0, end: null };"
          },
          {
            "lineNum": 646,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "findMatchingColonForTernary",
        "file": "scripts/decision-points.js",
        "line": 2297,
        "actualComplexity": 5,
        "calculatedTotal": 1,
        "difference": -4,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2297,
          "end": 2320
        },
        "functionCode": [
          {
            "lineNum": 2297,
            "content": "  const findMatchingColonForTernary = (lineWithoutComments, questionIndex, index, lines, startDepths, jsxTernary, isInsideStringLiteral) => {"
          },
          {
            "lineNum": 2298,
            "content": "    // Try to find matching colon on the same line"
          },
          {
            "lineNum": 2299,
            "content": "    let foundColon = findMatchingColonOnSameLine("
          },
          {
            "lineNum": 2300,
            "content": "      lineWithoutComments,"
          },
          {
            "lineNum": 2301,
            "content": "      questionIndex,"
          },
          {
            "lineNum": 2302,
            "content": "      startDepths,"
          },
          {
            "lineNum": 2303,
            "content": "      isInsideStringLiteral"
          },
          {
            "lineNum": 2304,
            "content": "    );"
          },
          {
            "lineNum": 2305,
            "content": "    "
          },
          {
            "lineNum": 2306,
            "content": "    // If not found and it's a JSX ternary, scan subsequent lines"
          },
          {
            "lineNum": 2307,
            "content": "    if (!foundColon && jsxTernary && index < lines.length - 1) {"
          },
          {
            "lineNum": 2308,
            "content": "      const maxScanLines = jsxTernary ? 20 : 10;"
          },
          {
            "lineNum": 2309,
            "content": "      foundColon = findMatchingColonOnSubsequentLines("
          },
          {
            "lineNum": 2310,
            "content": "        lines,"
          },
          {
            "lineNum": 2311,
            "content": "        index,"
          },
          {
            "lineNum": 2312,
            "content": "        maxScanLines,"
          },
          {
            "lineNum": 2313,
            "content": "        startDepths,"
          },
          {
            "lineNum": 2314,
            "content": "        jsxTernary,"
          },
          {
            "lineNum": 2315,
            "content": "        isInsideStringLiteral"
          },
          {
            "lineNum": 2316,
            "content": "      );"
          },
          {
            "lineNum": 2317,
            "content": "    }"
          },
          {
            "lineNum": 2318,
            "content": "    "
          },
          {
            "lineNum": 2319,
            "content": "    return foundColon;"
          },
          {
            "lineNum": 2320,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "applyParameterListEndFallbacks",
        "file": "scripts/decision-points.js",
        "line": 703,
        "actualComplexity": 4,
        "calculatedTotal": 1,
        "difference": -3,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 703,
          "end": 726
        },
        "functionCode": [
          {
            "lineNum": 703,
            "content": "  const applyParameterListEndFallbacks = (paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, hasFunctionSig) => {"
          },
          {
            "lineNum": 704,
            "content": "    // Match default parameters: identifier = value (including booleans, numbers, strings, etc.)"
          },
          {
            "lineNum": 705,
            "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
          },
          {
            "lineNum": 706,
            "content": "    "
          },
          {
            "lineNum": 707,
            "content": "    // Try fallback 1"
          },
          {
            "lineNum": 708,
            "content": "    const fallback1Result = applyFallback1FunctionDeclaration(paramListEnd, boundaryStart, lineNum, hasFunctionSig, lineWithoutComments, defaultParamPattern);"
          },
          {
            "lineNum": 709,
            "content": "    if (fallback1Result !== null) {"
          },
          {
            "lineNum": 710,
            "content": "      return fallback1Result;"
          },
          {
            "lineNum": 711,
            "content": "    }"
          },
          {
            "lineNum": 712,
            "content": "    "
          },
          {
            "lineNum": 713,
            "content": "    // Try fallback 2"
          },
          {
            "lineNum": 714,
            "content": "    const fallback2Result = applyFallback2ArrowOnLaterLine(paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, defaultParamPattern);"
          },
          {
            "lineNum": 715,
            "content": "    if (fallback2Result !== null) {"
          },
          {
            "lineNum": 716,
            "content": "      return fallback2Result;"
          },
          {
            "lineNum": 717,
            "content": "    }"
          },
          {
            "lineNum": 718,
            "content": "    "
          },
          {
            "lineNum": 719,
            "content": "    // Try fallback 3"
          },
          {
            "lineNum": 720,
            "content": "    const fallback3Result = applyFallback3OpeningParen(paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, defaultParamPattern);"
          },
          {
            "lineNum": 721,
            "content": "    if (fallback3Result !== null) {"
          },
          {
            "lineNum": 722,
            "content": "      return fallback3Result;"
          },
          {
            "lineNum": 723,
            "content": "    }"
          },
          {
            "lineNum": 724,
            "content": "    "
          },
          {
            "lineNum": 725,
            "content": "    return paramListEnd;"
          },
          {
            "lineNum": 726,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "isJSXAttributeLine",
        "file": "scripts/decision-points.js",
        "line": 1063,
        "actualComplexity": 4,
        "calculatedTotal": 1,
        "difference": -3,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1063,
          "end": 1073
        },
        "functionCode": [
          {
            "lineNum": 1063,
            "content": "  const isJSXAttributeLine = (lineWithoutComments, index, lines) => {"
          },
          {
            "lineNum": 1064,
            "content": "    // Check for JSX attribute pattern: identifier = \"value\" or identifier = {expression}"
          },
          {
            "lineNum": 1065,
            "content": "    const hasJSXAttributePattern = /^\\s*\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments) || /\\s+\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments);"
          },
          {
            "lineNum": 1066,
            "content": "    if (!hasJSXAttributePattern) return false;"
          },
          {
            "lineNum": 1067,
            "content": "    "
          },
          {
            "lineNum": 1068,
            "content": "    // Check current line for JSX tag or expression"
          },
          {
            "lineNum": 1069,
            "content": "    if (hasJSXOnCurrentLine(lineWithoutComments)) return true;"
          },
          {
            "lineNum": 1070,
            "content": "    "
          },
          {
            "lineNum": 1071,
            "content": "    // Check previous lines (up to 10 lines back) for JSX tags"
          },
          {
            "lineNum": 1072,
            "content": "    return hasJSXInPreviousLines(index, lines);"
          },
          {
            "lineNum": 1073,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processArrowFunctionDefaultParams",
        "file": "scripts/decision-points.js",
        "line": 1316,
        "actualComplexity": 4,
        "calculatedTotal": 1,
        "difference": -3,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1316,
          "end": 1325
        },
        "functionCode": [
          {
            "lineNum": 1316,
            "content": "  const processArrowFunctionDefaultParams = (lineWithoutComments, paramList, lineNum, actualFunctionLine, index, lines, decisionPoints) => {"
          },
          {
            "lineNum": 1317,
            "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
          },
          {
            "lineNum": 1318,
            "content": "    const defaultParamMatches = paramList.match(defaultParamPattern);"
          },
          {
            "lineNum": 1319,
            "content": "    "
          },
          {
            "lineNum": 1320,
            "content": "    if (defaultParamMatches && defaultParamMatches.length > 0) {"
          },
          {
            "lineNum": 1321,
            "content": "      if (isValidArrowFunctionDefaultParameterContext(lineWithoutComments, index, lines)) {"
          },
          {
            "lineNum": 1322,
            "content": "        processDefaultParameterMatches(defaultParamMatches, lineNum, actualFunctionLine, decisionPoints);"
          },
          {
            "lineNum": 1323,
            "content": "      }"
          },
          {
            "lineNum": 1324,
            "content": "    }"
          },
          {
            "lineNum": 1325,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "ThemePicker",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 517,
        "actualComplexity": 4,
        "calculatedTotal": 1,
        "difference": -3,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 517,
          "end": 864
        },
        "functionCode": [
          {
            "lineNum": 517,
            "content": "export function ThemePicker() {"
          },
          {
            "lineNum": 518,
            "content": "  const { theme, updateTheme, resetTheme, presets, savePreset, loadPreset, deletePreset, currentPresetId } = useTheme();"
          },
          {
            "lineNum": 519,
            "content": "  const [localChanges, setLocalChanges] = useState<Partial<typeof theme>>({});"
          },
          {
            "lineNum": 520,
            "content": "  const [isOpen, setIsOpen] = useState(false);"
          },
          {
            "lineNum": 521,
            "content": "  const [presetName, setPresetName] = useState('');"
          },
          {
            "lineNum": 522,
            "content": "  const [showSavePreset, setShowSavePreset] = useState(false);"
          },
          {
            "lineNum": 523,
            "content": "  const [isPresetsExpanded, setIsPresetsExpanded] = useState(false);"
          },
          {
            "lineNum": 524,
            "content": "  const [isPresetsHeaderCollapsed, setIsPresetsHeaderCollapsed] = useState(false);"
          },
          {
            "lineNum": 525,
            "content": "  const [isTriggerHidden, setIsTriggerHidden] = useState(false);"
          },
          {
            "lineNum": 526,
            "content": "  const drawerRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 527,
            "content": "  const backdropRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 528,
            "content": "  const triggerRef = useRef<HTMLButtonElement>(null);"
          },
          {
            "lineNum": 529,
            "content": ""
          },
          {
            "lineNum": 530,
            "content": "  // PERFORMANCE OPTIMIZATION: Only check contrast when drawer is open"
          },
          {
            "lineNum": 531,
            "content": "  // This prevents expensive contrast calculations when the picker is closed"
          },
          {
            "lineNum": 532,
            "content": "  // checkContrastIssues() creates many Color objects and performs ~20+ contrast checks"
          },
          {
            "lineNum": 533,
            "content": "  const contrastIssues = useMemo(() => {"
          },
          {
            "lineNum": 534,
            "content": "    if (!isOpen) return [];"
          },
          {
            "lineNum": 535,
            "content": "    "
          },
          {
            "lineNum": 536,
            "content": "    const currentTheme = { ...theme, ...localChanges };"
          },
          {
            "lineNum": 537,
            "content": "    return checkContrastIssues({"
          },
          {
            "lineNum": 538,
            "content": "      bg: currentTheme.bg,"
          },
          {
            "lineNum": 539,
            "content": "      text: currentTheme.text,"
          },
          {
            "lineNum": 540,
            "content": "      primary: currentTheme.primary,"
          },
          {
            "lineNum": 541,
            "content": "      primaryContrast: currentTheme.primaryContrast,"
          },
          {
            "lineNum": 542,
            "content": "      surface: currentTheme.surface,"
          },
          {
            "lineNum": 543,
            "content": "      surfaceDark: currentTheme.surfaceDark,"
          },
          {
            "lineNum": 544,
            "content": "      textDark: currentTheme.textDark,"
          },
          {
            "lineNum": 545,
            "content": "      link: currentTheme.link,"
          },
          {
            "lineNum": 546,
            "content": "      footerBg: currentTheme.footerBg,"
          },
          {
            "lineNum": 547,
            "content": "      footerTextMuted: currentTheme.footerTextMuted,"
          },
          {
            "lineNum": 548,
            "content": "      footerTextSubtle: currentTheme.footerTextSubtle,"
          },
          {
            "lineNum": 549,
            "content": "      footerSocialBg: currentTheme.footerSocialBg,"
          },
          {
            "lineNum": 550,
            "content": "      accentAlt: currentTheme.accentAlt,"
          },
          {
            "lineNum": 551,
            "content": "      codeBg: currentTheme.codeBg,"
          },
          {
            "lineNum": 552,
            "content": "      codeText: currentTheme.codeText,"
          },
          {
            "lineNum": 553,
            "content": "      blogLink: currentTheme.blogLink,"
          },
          {
            "lineNum": 554,
            "content": "      authorBoxStart: currentTheme.authorBoxStart,"
          },
          {
            "lineNum": 555,
            "content": "      authorBoxEnd: currentTheme.authorBoxEnd,"
          },
          {
            "lineNum": 556,
            "content": "      relatedSectionStart: currentTheme.relatedSectionStart,"
          },
          {
            "lineNum": 557,
            "content": "      relatedSectionEnd: currentTheme.relatedSectionEnd,"
          },
          {
            "lineNum": 558,
            "content": "    });"
          },
          {
            "lineNum": 559,
            "content": "  }, [theme, localChanges, isOpen]);"
          },
          {
            "lineNum": 560,
            "content": ""
          },
          {
            "lineNum": 561,
            "content": "  // Memoize event handlers to prevent unnecessary re-renders"
          },
          {
            "lineNum": 562,
            "content": "  const handleColorChange = useCallback((key: keyof typeof theme, value: string) => {"
          },
          {
            "lineNum": 563,
            "content": "    setLocalChanges((prev) => ({ ...prev, [key]: value }));"
          },
          {
            "lineNum": 564,
            "content": "    // Apply temporarily for preview"
          },
          {
            "lineNum": 565,
            "content": "    const root = document.getElementById('root');"
          },
          {
            "lineNum": 566,
            "content": "    if (root) {"
          }
        ]
      },
      {
        "functionName": "handleContactClick",
        "file": "src/sections/Hero/index.tsx",
        "line": 9,
        "actualComplexity": 4,
        "calculatedTotal": 1,
        "difference": -3,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 9,
          "end": 24
        },
        "functionCode": [
          {
            "lineNum": 9,
            "content": "  const handleContactClick = (e: React.MouseEvent<HTMLAnchorElement>) => {"
          },
          {
            "lineNum": 10,
            "content": "    // If we're already on the home page with #contact, manually scroll"
          },
          {
            "lineNum": 11,
            "content": "    if (location.pathname === \"/\" && location.hash === \"#contact\") {"
          },
          {
            "lineNum": 12,
            "content": "      e.preventDefault();"
          },
          {
            "lineNum": 13,
            "content": "      const element = document.querySelector(\"#contact\");"
          },
          {
            "lineNum": 14,
            "content": "      if (element) {"
          },
          {
            "lineNum": 15,
            "content": "        const headerOffset = 110;"
          },
          {
            "lineNum": 16,
            "content": "        const elementPosition = element.getBoundingClientRect().top;"
          },
          {
            "lineNum": 17,
            "content": "        const offsetPosition = elementPosition + window.scrollY - headerOffset;"
          },
          {
            "lineNum": 18,
            "content": "        window.scrollTo({"
          },
          {
            "lineNum": 19,
            "content": "          top: offsetPosition,"
          },
          {
            "lineNum": 20,
            "content": "          behavior: \"smooth\","
          },
          {
            "lineNum": 21,
            "content": "        });"
          },
          {
            "lineNum": 22,
            "content": "      }"
          },
          {
            "lineNum": 23,
            "content": "    }"
          },
          {
            "lineNum": 24,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "matchDefaultParameters",
        "file": "scripts/decision-points.js",
        "line": 802,
        "actualComplexity": 3,
        "calculatedTotal": 1,
        "difference": -2,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 802,
          "end": 814
        },
        "functionCode": [
          {
            "lineNum": 802,
            "content": "  const matchDefaultParameters = (lineWithoutComments, isArrowFunctionParam, arrowIndex) => {"
          },
          {
            "lineNum": 803,
            "content": "    // Match default parameters: identifier = value"
          },
          {
            "lineNum": 804,
            "content": "    // Values can be: strings (\"...\", '...', `...`), booleans (true, false), numbers, or other expressions"
          },
          {
            "lineNum": 805,
            "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
          },
          {
            "lineNum": 806,
            "content": "    "
          },
          {
            "lineNum": 807,
            "content": "    if (isArrowFunctionParam) {"
          },
          {
            "lineNum": 808,
            "content": "      const beforeArrow = lineWithoutComments.substring(0, arrowIndex);"
          },
          {
            "lineNum": 809,
            "content": "      return matchArrowFunctionDefaultParams(lineWithoutComments, beforeArrow, defaultParamPattern);"
          },
          {
            "lineNum": 810,
            "content": "    }"
          },
          {
            "lineNum": 811,
            "content": "    "
          },
          {
            "lineNum": 812,
            "content": "    const matches = lineWithoutComments.match(defaultParamPattern);"
          },
          {
            "lineNum": 813,
            "content": "    return matches || [];"
          },
          {
            "lineNum": 814,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processMultiLineTernaryConditionOperators",
        "file": "scripts/decision-points.js",
        "line": 2445,
        "actualComplexity": 3,
        "calculatedTotal": 1,
        "difference": -2,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2445,
          "end": 2453
        },
        "functionCode": [
          {
            "lineNum": 2445,
            "content": "  const processMultiLineTernaryConditionOperators = (lineWithoutComments, lineNum, index, lines, functionLine, hasQuestionMarkOutsideString, decisionPoints) => {"
          },
          {
            "lineNum": 2446,
            "content": "    const nextLine = index + 1 < lines.length ? lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
          },
          {
            "lineNum": 2447,
            "content": "    const nextLineHasQuestionMark = hasQuestionMarkOutsideString(nextLine);"
          },
          {
            "lineNum": 2448,
            "content": "    "
          },
          {
            "lineNum": 2449,
            "content": "    // Only process operators if next line doesn't have ? (meaning ? is on previous line, not next line)"
          },
          {
            "lineNum": 2450,
            "content": "    if (!nextLineHasQuestionMark) {"
          },
          {
            "lineNum": 2451,
            "content": "      processTernaryLogicalOperators(lineWithoutComments, lineNum, functionLine, decisionPoints);"
          },
          {
            "lineNum": 2452,
            "content": "    }"
          },
          {
            "lineNum": 2453,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "FeatureAccordion",
        "file": "src/sections/FeatureAccordion/index.tsx",
        "line": 93,
        "actualComplexity": 3,
        "calculatedTotal": 1,
        "difference": -2,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 93,
          "end": 260
        },
        "functionCode": [
          {
            "lineNum": 93,
            "content": "export function FeatureAccordion() {"
          },
          {
            "lineNum": 94,
            "content": "  const { currentPresetId } = useTheme();"
          },
          {
            "lineNum": 95,
            "content": "  const isNoirTheme = currentPresetId === 'noir';"
          },
          {
            "lineNum": 96,
            "content": ""
          },
          {
            "lineNum": 97,
            "content": "  // Accordion behavior: one item open at all times"
          },
          {
            "lineNum": 98,
            "content": "  // Initialize with first item's ID, defaulting to 1 if items array is empty"
          },
          {
            "lineNum": 99,
            "content": "  const firstItemId = items[0]?.id ?? 1;"
          },
          {
            "lineNum": 100,
            "content": "  const [activeId, setActiveId] = useState<number>(firstItemId);"
          },
          {
            "lineNum": 101,
            "content": ""
          },
          {
            "lineNum": 102,
            "content": "  // Refs for height matching"
          },
          {
            "lineNum": 103,
            "content": "  const controlsWrapperRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 104,
            "content": "  const contentsWrapperRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 105,
            "content": ""
          },
          {
            "lineNum": 106,
            "content": "  // Match heights between left and right columns (desktop only)"
          },
          {
            "lineNum": 107,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 108,
            "content": "    const matchHeights = () => {"
          },
          {
            "lineNum": 109,
            "content": "      // Only run on desktop (window width > 990px)"
          },
          {
            "lineNum": 110,
            "content": "      if (window.innerWidth <= 990) {"
          },
          {
            "lineNum": 111,
            "content": "        // Reset height on mobile"
          },
          {
            "lineNum": 112,
            "content": "        if (contentsWrapperRef.current) {"
          },
          {
            "lineNum": 113,
            "content": "          contentsWrapperRef.current.style.height = \"\";"
          },
          {
            "lineNum": 114,
            "content": "        }"
          },
          {
            "lineNum": 115,
            "content": "        return;"
          },
          {
            "lineNum": 116,
            "content": "      }"
          },
          {
            "lineNum": 117,
            "content": ""
          },
          {
            "lineNum": 118,
            "content": "      if (controlsWrapperRef.current && contentsWrapperRef.current) {"
          },
          {
            "lineNum": 119,
            "content": "        const leftHeight = controlsWrapperRef.current.offsetHeight;"
          },
          {
            "lineNum": 120,
            "content": "        contentsWrapperRef.current.style.height = `${leftHeight}px`;"
          },
          {
            "lineNum": 121,
            "content": "      }"
          },
          {
            "lineNum": 122,
            "content": "    };"
          },
          {
            "lineNum": 123,
            "content": ""
          },
          {
            "lineNum": 124,
            "content": "    // Match heights on mount, activeId change, and window resize"
          },
          {
            "lineNum": 125,
            "content": "    matchHeights();"
          },
          {
            "lineNum": 126,
            "content": "    window.addEventListener(\"resize\", matchHeights);"
          },
          {
            "lineNum": 127,
            "content": ""
          },
          {
            "lineNum": 128,
            "content": "    // Use a small delay to ensure DOM has updated after activeId change"
          },
          {
            "lineNum": 129,
            "content": "    const timeoutId = setTimeout(matchHeights, 0);"
          },
          {
            "lineNum": 130,
            "content": ""
          },
          {
            "lineNum": 131,
            "content": "    return () => {"
          },
          {
            "lineNum": 132,
            "content": "      window.removeEventListener(\"resize\", matchHeights);"
          },
          {
            "lineNum": 133,
            "content": "      clearTimeout(timeoutId);"
          },
          {
            "lineNum": 134,
            "content": "    };"
          },
          {
            "lineNum": 135,
            "content": "  }, [activeId]);"
          },
          {
            "lineNum": 136,
            "content": ""
          },
          {
            "lineNum": 137,
            "content": "  return ("
          },
          {
            "lineNum": 138,
            "content": "    <Section id=\"projects\">"
          },
          {
            "lineNum": 139,
            "content": "      <Container className={styles.projectsContainer}>"
          },
          {
            "lineNum": 140,
            "content": "      <h2 className={styles.heading}>Recent Projects</h2>"
          },
          {
            "lineNum": 141,
            "content": ""
          },
          {
            "lineNum": 142,
            "content": "        <div className={styles.wrapper}>"
          }
        ]
      },
      {
        "functionName": "TopBanner",
        "file": "src/sections/TopBanner/index.tsx",
        "line": 5,
        "actualComplexity": 3,
        "calculatedTotal": 1,
        "difference": -2,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 5,
          "end": 71
        },
        "functionCode": [
          {
            "lineNum": 5,
            "content": "export function TopBanner() {"
          },
          {
            "lineNum": 6,
            "content": "  const [isVisible, setIsVisible] = useState(true);   // user can close permanently"
          },
          {
            "lineNum": 7,
            "content": "  const [isHidden, setIsHidden] = useState(false);    // scroll-controlled (slides away)"
          },
          {
            "lineNum": 8,
            "content": "  const bannerRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 9,
            "content": ""
          },
          {
            "lineNum": 10,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 11,
            "content": "    const root = document.documentElement;"
          },
          {
            "lineNum": 12,
            "content": ""
          },
          {
            "lineNum": 13,
            "content": "    const updateVars = () => {"
          },
          {
            "lineNum": 14,
            "content": "      // If user closed it OR it's scrolled-hidden, treat banner height as 0"
          },
          {
            "lineNum": 15,
            "content": "      const h ="
          },
          {
            "lineNum": 16,
            "content": "        isVisible && !isHidden && bannerRef.current"
          },
          {
            "lineNum": 17,
            "content": "          ? bannerRef.current.offsetHeight"
          },
          {
            "lineNum": 18,
            "content": "          : 0;"
          },
          {
            "lineNum": 19,
            "content": ""
          },
          {
            "lineNum": 20,
            "content": "      root.style.setProperty(\"--banner-height\", `${h}px`);"
          },
          {
            "lineNum": 21,
            "content": "    };"
          },
          {
            "lineNum": 22,
            "content": ""
          },
          {
            "lineNum": 23,
            "content": "    updateVars();"
          },
          {
            "lineNum": 24,
            "content": "    window.addEventListener(\"resize\", updateVars);"
          },
          {
            "lineNum": 25,
            "content": "    return () => window.removeEventListener(\"resize\", updateVars);"
          },
          {
            "lineNum": 26,
            "content": "  }, [isVisible, isHidden]);"
          },
          {
            "lineNum": 27,
            "content": ""
          },
          {
            "lineNum": 28,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 29,
            "content": "    let ticking = false;"
          },
          {
            "lineNum": 30,
            "content": ""
          },
          {
            "lineNum": 31,
            "content": "    const onScroll = () => {"
          },
          {
            "lineNum": 32,
            "content": "      if (ticking) return;"
          },
          {
            "lineNum": 33,
            "content": "      ticking = true;"
          },
          {
            "lineNum": 34,
            "content": ""
          },
          {
            "lineNum": 35,
            "content": "      window.requestAnimationFrame(() => {"
          },
          {
            "lineNum": 36,
            "content": "        const y = window.scrollY || document.documentElement.scrollTop;"
          },
          {
            "lineNum": 37,
            "content": "        // Tune this threshold to match main site (try 10, 20, 40)"
          },
          {
            "lineNum": 38,
            "content": "        setIsHidden(y > 20);"
          },
          {
            "lineNum": 39,
            "content": "        ticking = false;"
          },
          {
            "lineNum": 40,
            "content": "      });"
          },
          {
            "lineNum": 41,
            "content": "    };"
          },
          {
            "lineNum": 42,
            "content": ""
          },
          {
            "lineNum": 43,
            "content": "    onScroll(); // initialize"
          },
          {
            "lineNum": 44,
            "content": "    window.addEventListener(\"scroll\", onScroll, { passive: true });"
          },
          {
            "lineNum": 45,
            "content": "    return () => window.removeEventListener(\"scroll\", onScroll);"
          },
          {
            "lineNum": 46,
            "content": "  }, []);"
          },
          {
            "lineNum": 47,
            "content": ""
          },
          {
            "lineNum": 48,
            "content": "  // If user closed it, remove entirely (like now)"
          },
          {
            "lineNum": 49,
            "content": "  if (!isVisible) return null;"
          },
          {
            "lineNum": 50,
            "content": ""
          },
          {
            "lineNum": 51,
            "content": "  return ("
          },
          {
            "lineNum": 52,
            "content": "    <div"
          },
          {
            "lineNum": 53,
            "content": "      ref={bannerRef}"
          },
          {
            "lineNum": 54,
            "content": "      className={`${styles.banner} ${isHidden ? styles.hidden : \"\"}`}"
          }
        ]
      },
      {
        "functionName": "findImmediateParent",
        "file": "scripts/decision-points.js",
        "line": 44,
        "actualComplexity": 2,
        "calculatedTotal": 1,
        "difference": -1,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 44,
          "end": 55
        },
        "functionCode": [
          {
            "lineNum": 44,
            "content": "  const findImmediateParent = (sortedFunctions, lineNum) => {"
          },
          {
            "lineNum": 45,
            "content": "    return sortedFunctions"
          },
          {
            "lineNum": 46,
            "content": "      .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
          },
          {
            "lineNum": 47,
            "content": "      .sort((a, b) => {"
          },
          {
            "lineNum": 48,
            "content": "        const aSize = a.boundary.end - a.boundary.start;"
          },
          {
            "lineNum": 49,
            "content": "        const bSize = b.boundary.end - b.boundary.start;"
          },
          {
            "lineNum": 50,
            "content": "        if (aSize !== bSize) {"
          },
          {
            "lineNum": 51,
            "content": "          return aSize - bSize;"
          },
          {
            "lineNum": 52,
            "content": "        }"
          },
          {
            "lineNum": 53,
            "content": "        return b.boundary.start - a.boundary.start;"
          },
          {
            "lineNum": 54,
            "content": "      })[0] || null;"
          },
          {
            "lineNum": 55,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "useCallback callback",
        "file": "src/context/ThemeContext.tsx",
        "line": 163,
        "actualComplexity": 2,
        "calculatedTotal": 1,
        "difference": -1,
        "category": "(none)",
        "decisionPoints": [],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 163,
          "end": 172
        },
        "functionCode": [
          {
            "lineNum": 163,
            "content": "  const deletePreset = useCallback((presetId: string) => {"
          },
          {
            "lineNum": 164,
            "content": "    // Don't allow deleting built-in presets"
          },
          {
            "lineNum": 165,
            "content": "    if (builtInPresets.find((p) => p.id === presetId)) {"
          },
          {
            "lineNum": 166,
            "content": "      return;"
          },
          {
            "lineNum": 167,
            "content": "    }"
          },
          {
            "lineNum": 168,
            "content": "    const customPresets = presets.filter((p) => p.id !== presetId && !builtInPresets.find((bp) => bp.id === p.id));"
          },
          {
            "lineNum": 169,
            "content": "    const updated = [...builtInPresets, ...customPresets];"
          },
          {
            "lineNum": 170,
            "content": "    setPresets(updated);"
          },
          {
            "lineNum": 171,
            "content": "    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(customPresets));"
          },
          {
            "lineNum": 172,
            "content": "  }, [presets]);"
          }
        ]
      }
    ],
    "under-counting": [
      {
        "functionName": "processLineInFunctionBody",
        "file": "scripts/function-boundaries.js",
        "line": 736,
        "actualComplexity": 53,
        "calculatedTotal": 35,
        "difference": -18,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 752,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 788,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 788,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 793,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 793,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 793,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 794,
            "name": "if statement"
          },
          {
            "type": "else if",
            "line": 797,
            "name": "else if statement"
          },
          {
            "type": "if",
            "line": 806,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 806,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 806,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 806,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 806,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 810,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 810,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 810,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 810,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 811,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 811,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 818,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 818,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 818,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 818,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 824,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 824,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 825,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 826,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 833,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 833,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 837,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 837,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 839,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 844,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 851,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 14,
          "else if": 1,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 10,
          "||": 8,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 736,
          "end": 857
        },
        "functionCode": [
          {
            "lineNum": 736,
            "content": "function processLineInFunctionBody(line, i, functionLine, braceCount, lines) {"
          },
          {
            "lineNum": 737,
            "content": "  // Count braces, but exclude those inside regex patterns, string literals, and comments"
          },
          {
            "lineNum": 738,
            "content": "  // Regex patterns can contain braces in character classes (e.g., /[({]/ or /[&|]{2}/)"
          },
          {
            "lineNum": 739,
            "content": "  // String literals can contain braces (e.g., includes('{') or \"text { more }\")"
          },
          {
            "lineNum": 740,
            "content": "  // Comments can contain braces (e.g., // Check if the { is part of...)"
          },
          {
            "lineNum": 741,
            "content": "  let openBraces = 0;"
          },
          {
            "lineNum": 742,
            "content": "  let closeBraces = 0;"
          },
          {
            "lineNum": 743,
            "content": "  let inRegex = false;"
          },
          {
            "lineNum": 744,
            "content": "  let inString = false;"
          },
          {
            "lineNum": 745,
            "content": "  let inSingleLineComment = false;"
          },
          {
            "lineNum": 746,
            "content": "  let inMultiLineComment = false;"
          },
          {
            "lineNum": 747,
            "content": "  let stringChar = null; // Track which quote started the string (' or \")"
          },
          {
            "lineNum": 748,
            "content": "  let escapeNext = false;"
          },
          {
            "lineNum": 749,
            "content": "  "
          },
          {
            "lineNum": 750,
            "content": "  for (let j = 0; j < line.length; j++) {"
          },
          {
            "lineNum": 751,
            "content": "    const char = line[j];"
          },
          {
            "lineNum": 752,
            "content": "    const prevChar = j > 0 ? line[j - 1] : '';"
          },
          {
            "lineNum": 753,
            "content": "    const nextChar = j + 1 < line.length ? line[j + 1] : '';"
          },
          {
            "lineNum": 754,
            "content": "    "
          },
          {
            "lineNum": 755,
            "content": "    // Handle escape sequences in strings"
          },
          {
            "lineNum": 756,
            "content": "    if (escapeNext) {"
          },
          {
            "lineNum": 757,
            "content": "      escapeNext = false;"
          },
          {
            "lineNum": 758,
            "content": "      continue;"
          },
          {
            "lineNum": 759,
            "content": "    }"
          },
          {
            "lineNum": 760,
            "content": "    "
          },
          {
            "lineNum": 761,
            "content": "    if (char === '\\\\' && inString) {"
          },
          {
            "lineNum": 762,
            "content": "      escapeNext = true;"
          },
          {
            "lineNum": 763,
            "content": "      continue;"
          },
          {
            "lineNum": 764,
            "content": "    }"
          },
          {
            "lineNum": 765,
            "content": "    "
          },
          {
            "lineNum": 766,
            "content": "    // Handle single-line comments (//)"
          },
          {
            "lineNum": 767,
            "content": "    if (char === '/' && nextChar === '/' && !inString && !inRegex && !inMultiLineComment) {"
          },
          {
            "lineNum": 768,
            "content": "      inSingleLineComment = true;"
          },
          {
            "lineNum": 769,
            "content": "      // Rest of line is comment, break"
          },
          {
            "lineNum": 770,
            "content": "      break;"
          },
          {
            "lineNum": 771,
            "content": "    }"
          },
          {
            "lineNum": 772,
            "content": "    "
          },
          {
            "lineNum": 773,
            "content": "    // Handle multi-line comment start (/*)"
          },
          {
            "lineNum": 774,
            "content": "    if (char === '/' && nextChar === '*' && !inString && !inRegex && !inSingleLineComment) {"
          },
          {
            "lineNum": 775,
            "content": "      inMultiLineComment = true;"
          },
          {
            "lineNum": 776,
            "content": "      j++; // Skip the * character"
          },
          {
            "lineNum": 777,
            "content": "      continue;"
          },
          {
            "lineNum": 778,
            "content": "    }"
          },
          {
            "lineNum": 779,
            "content": "    "
          },
          {
            "lineNum": 780,
            "content": "    // Handle multi-line comment end (*/)"
          },
          {
            "lineNum": 781,
            "content": "    if (char === '*' && nextChar === '/' && inMultiLineComment) {"
          },
          {
            "lineNum": 782,
            "content": "      inMultiLineComment = false;"
          },
          {
            "lineNum": 783,
            "content": "      j++; // Skip the / character"
          },
          {
            "lineNum": 784,
            "content": "      continue;"
          },
          {
            "lineNum": 785,
            "content": "    }"
          }
        ]
      },
      {
        "functionName": "logComplexityMismatch",
        "file": "scripts/html-generators.js",
        "line": 1035,
        "actualComplexity": 10,
        "calculatedTotal": 4,
        "difference": -6,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 1039,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1041,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 1041,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1035,
          "end": 1061
        },
        "functionCode": [
          {
            "lineNum": 1035,
            "content": "function logComplexityMismatch(func, breakdown, functionBoundaries) {"
          },
          {
            "lineNum": 1036,
            "content": "  const actualComplexity = parseInt(func.complexity);"
          },
          {
            "lineNum": 1037,
            "content": "  const calculatedTotal = breakdown.calculatedTotal;"
          },
          {
            "lineNum": 1038,
            "content": "  "
          },
          {
            "lineNum": 1039,
            "content": "  if (Math.abs(calculatedTotal - actualComplexity) > 1) {"
          },
          {
            "lineNum": 1040,
            "content": "    console.warn(`Complexity mismatch for ${func.functionName} at line ${func.line}: ESLint reports ${actualComplexity}, calculated ${calculatedTotal}`);"
          },
          {
            "lineNum": 1041,
            "content": "    if (breakdown.decisionPoints && breakdown.decisionPoints.length > 0) {"
          },
          {
            "lineNum": 1042,
            "content": "      console.warn(`  Decision points found:`, breakdown.decisionPoints.map(dp => `${dp.type} at line ${dp.line}`).join(', '));"
          },
          {
            "lineNum": 1043,
            "content": "    } else {"
          },
          {
            "lineNum": 1044,
            "content": "      console.warn(`  Decision points found: (none)`);"
          },
          {
            "lineNum": 1045,
            "content": "      // For TopBanner specifically, check what's happening"
          },
          {
            "lineNum": 1046,
            "content": "      if (func.functionName === 'TopBanner' && func.line === 5) {"
          },
          {
            "lineNum": 1047,
            "content": "        const boundary = functionBoundaries.get(func.line);"
          },
          {
            "lineNum": 1048,
            "content": "        console.warn(`  TopBanner boundary: start=${boundary?.start}, end=${boundary?.end}`);"
          },
          {
            "lineNum": 1049,
            "content": "        // Check if lines 49 and 54 are in any function boundary"
          },
          {
            "lineNum": 1050,
            "content": "        const line49Funcs = Array.from(functionBoundaries.entries()).filter(([fl, b]) => fl !== func.line && 49 >= b.start && 49 <= b.end);"
          },
          {
            "lineNum": 1051,
            "content": "        const line54Funcs = Array.from(functionBoundaries.entries()).filter(([fl, b]) => fl !== func.line && 54 >= b.start && 54 <= b.end);"
          },
          {
            "lineNum": 1052,
            "content": "        if (line49Funcs.length > 0) {"
          },
          {
            "lineNum": 1053,
            "content": "          console.warn(`  Line 49 is in other function boundaries:`, line49Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
          },
          {
            "lineNum": 1054,
            "content": "        }"
          },
          {
            "lineNum": 1055,
            "content": "        if (line54Funcs.length > 0) {"
          },
          {
            "lineNum": 1056,
            "content": "          console.warn(`  Line 54 is in other function boundaries:`, line54Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
          },
          {
            "lineNum": 1057,
            "content": "        }"
          },
          {
            "lineNum": 1058,
            "content": "      }"
          },
          {
            "lineNum": 1059,
            "content": "    }"
          },
          {
            "lineNum": 1060,
            "content": "  }"
          },
          {
            "lineNum": 1061,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "findNamedFunctionEnd",
        "file": "scripts/function-boundaries.js",
        "line": 869,
        "actualComplexity": 9,
        "calculatedTotal": 4,
        "difference": -5,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 906,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 906,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 913,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 869,
          "end": 923
        },
        "functionCode": [
          {
            "lineNum": 869,
            "content": "function findNamedFunctionEnd(lines, start, functionLine, arrowFunctionHandled, inFunctionBody, braceCount) {"
          },
          {
            "lineNum": 870,
            "content": "  let end = functionLine;"
          },
          {
            "lineNum": 871,
            "content": "  let typeBraceCount = 0;"
          },
          {
            "lineNum": 872,
            "content": "  "
          },
          {
            "lineNum": 873,
            "content": "  // For arrow functions that we've already handled, start from the body start line"
          },
          {
            "lineNum": 874,
            "content": "  // but skip counting braces on that line since we already counted them in handleBraceOnSameLine"
          },
          {
            "lineNum": 875,
            "content": "  // For other functions, start from start - 1 to find the body"
          },
          {
            "lineNum": 876,
            "content": "  // loopStart must be 0-based (array index)"
          },
          {
            "lineNum": 877,
            "content": "  const loopStart = start - 1; // Always 0-based array index (start is 1-based line number)"
          },
          {
            "lineNum": 878,
            "content": "  // Skip the first line if we already counted its braces in handleBraceOnSameLine"
          },
          {
            "lineNum": 879,
            "content": "  const skipFirstLine = (arrowFunctionHandled && inFunctionBody);"
          },
          {
            "lineNum": 880,
            "content": "  "
          },
          {
            "lineNum": 881,
            "content": "  for (let i = loopStart; i < lines.length; i++) {"
          },
          {
            "lineNum": 882,
            "content": "    const line = lines[i];"
          },
          {
            "lineNum": 883,
            "content": "    "
          },
          {
            "lineNum": 884,
            "content": "    if (!inFunctionBody) {"
          },
          {
            "lineNum": 885,
            "content": "      const result = processLineBeforeFunctionBody(line, i, lines, typeBraceCount);"
          },
          {
            "lineNum": 886,
            "content": "      "
          },
          {
            "lineNum": 887,
            "content": "      if (result.end !== null) {"
          },
          {
            "lineNum": 888,
            "content": "        // Arrow function without braces - end found"
          },
          {
            "lineNum": 889,
            "content": "        return result.end;"
          },
          {
            "lineNum": 890,
            "content": "      }"
          },
          {
            "lineNum": 891,
            "content": "      "
          },
          {
            "lineNum": 892,
            "content": "      if (result.inFunctionBody) {"
          },
          {
            "lineNum": 893,
            "content": "        // Function body found"
          },
          {
            "lineNum": 894,
            "content": "        inFunctionBody = true;"
          },
          {
            "lineNum": 895,
            "content": "        braceCount = result.braceCount;"
          },
          {
            "lineNum": 896,
            "content": "        typeBraceCount = result.typeBraceCount;"
          },
          {
            "lineNum": 897,
            "content": "        // Don't process this line's braces again in the function body tracking section"
          },
          {
            "lineNum": 898,
            "content": "        continue;"
          },
          {
            "lineNum": 899,
            "content": "      }"
          },
          {
            "lineNum": 900,
            "content": "      "
          },
          {
            "lineNum": 901,
            "content": "      typeBraceCount = result.typeBraceCount;"
          },
          {
            "lineNum": 902,
            "content": "    } else {"
          },
          {
            "lineNum": 903,
            "content": "      // We're in the function body, track its braces"
          },
          {
            "lineNum": 904,
            "content": "      // Skip the first line if we already counted its braces in handleBraceOnSameLine"
          },
          {
            "lineNum": 905,
            "content": "      // i is 0-based index, start is 1-based line number, so compare i + 1 === start"
          },
          {
            "lineNum": 906,
            "content": "      if (skipFirstLine && i + 1 === start) {"
          },
          {
            "lineNum": 907,
            "content": "        // Skip this line - braces already counted in handleBraceOnSameLine"
          },
          {
            "lineNum": 908,
            "content": "        continue;"
          },
          {
            "lineNum": 909,
            "content": "      }"
          },
          {
            "lineNum": 910,
            "content": "      "
          },
          {
            "lineNum": 911,
            "content": "      const result = processLineInFunctionBody(line, i, functionLine, braceCount, lines);"
          },
          {
            "lineNum": 912,
            "content": "      "
          },
          {
            "lineNum": 913,
            "content": "      if (result.end !== null) {"
          },
          {
            "lineNum": 914,
            "content": "        // Function end found"
          },
          {
            "lineNum": 915,
            "content": "        return result.end;"
          },
          {
            "lineNum": 916,
            "content": "      }"
          },
          {
            "lineNum": 917,
            "content": "      "
          },
          {
            "lineNum": 918,
            "content": "      braceCount = result.braceCount;"
          }
        ]
      },
      {
        "functionName": "processSubsequentLine",
        "file": "scripts/decision-points.js",
        "line": 2068,
        "actualComplexity": 9,
        "calculatedTotal": 4,
        "difference": -5,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for",
            "line": 2071,
            "name": "for loop"
          },
          {
            "type": "ternary",
            "line": 2073,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 2080,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2068,
          "end": 2103
        },
        "functionCode": [
          {
            "lineNum": 2068,
            "content": "  const processSubsequentLine = (currentScanLine, depths, startDepths, isJSXTernary, isInsideStringLiteral, scanLineIndex, startIndex) => {"
          },
          {
            "lineNum": 2069,
            "content": "    let currentDepths = { ...depths };"
          },
          {
            "lineNum": 2070,
            "content": "    "
          },
          {
            "lineNum": 2071,
            "content": "    for (let i = 0; i < currentScanLine.length; i++) {"
          },
          {
            "lineNum": 2072,
            "content": "      const char = currentScanLine[i];"
          },
          {
            "lineNum": 2073,
            "content": "      const nextChar = i + 1 < currentScanLine.length ? currentScanLine[i + 1] : '';"
          },
          {
            "lineNum": 2074,
            "content": "      "
          },
          {
            "lineNum": 2075,
            "content": "      // Update nesting depths"
          },
          {
            "lineNum": 2076,
            "content": "      const updated = updateNestingDepths(char, nextChar, currentDepths, startDepths, isInsideStringLiteral, currentScanLine, i);"
          },
          {
            "lineNum": 2077,
            "content": "      currentDepths = updated;"
          },
          {
            "lineNum": 2078,
            "content": "      "
          },
          {
            "lineNum": 2079,
            "content": "      // Check if we should break"
          },
          {
            "lineNum": 2080,
            "content": "      if (shouldBreakSubsequentLineSearch(char, updated.shouldBreak, scanLineIndex, startIndex)) {"
          },
          {
            "lineNum": 2081,
            "content": "        return { depths: currentDepths, matchFound: false, shouldBreak: true };"
          },
          {
            "lineNum": 2082,
            "content": "      }"
          },
          {
            "lineNum": 2083,
            "content": "      "
          },
          {
            "lineNum": 2084,
            "content": "      // If we hit a :, check if it's our matching colon"
          },
          {
            "lineNum": 2085,
            "content": "      if (char === ':') {"
          },
          {
            "lineNum": 2086,
            "content": "        const colonResult = handleColonInSubsequentLines(currentDepths, startDepths, isJSXTernary);"
          },
          {
            "lineNum": 2087,
            "content": "        if (colonResult === true) {"
          },
          {
            "lineNum": 2088,
            "content": "          return { depths: currentDepths, matchFound: true, shouldBreak: false };"
          },
          {
            "lineNum": 2089,
            "content": "        }"
          },
          {
            "lineNum": 2090,
            "content": "        if (colonResult === null) {"
          },
          {
            "lineNum": 2091,
            "content": "          currentDepths.ternaryDepth--;"
          },
          {
            "lineNum": 2092,
            "content": "          continue;"
          },
          {
            "lineNum": 2093,
            "content": "        }"
          },
          {
            "lineNum": 2094,
            "content": "      }"
          },
          {
            "lineNum": 2095,
            "content": "      "
          },
          {
            "lineNum": 2096,
            "content": "      // Stop at semicolon if depths match"
          },
          {
            "lineNum": 2097,
            "content": "      if (char === ';' && shouldStopAtSemicolon(currentDepths, startDepths)) {"
          },
          {
            "lineNum": 2098,
            "content": "        return { depths: currentDepths, matchFound: false, shouldBreak: true };"
          },
          {
            "lineNum": 2099,
            "content": "      }"
          },
          {
            "lineNum": 2100,
            "content": "    }"
          },
          {
            "lineNum": 2101,
            "content": "    "
          },
          {
            "lineNum": 2102,
            "content": "    return { depths: currentDepths, matchFound: false, shouldBreak: false };"
          },
          {
            "lineNum": 2103,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "parseDestructuredAssignments",
        "file": "scripts/decision-points.js",
        "line": 3155,
        "actualComplexity": 9,
        "calculatedTotal": 4,
        "difference": -5,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 3157,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 3157,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 3157,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3155,
          "end": 3186
        },
        "functionCode": [
          {
            "lineNum": 3155,
            "content": "  const parseDestructuredAssignments = (lineWithoutComments, lineNum, index, lines, functionLine, boundary, decisionPoints) => {"
          },
          {
            "lineNum": 3156,
            "content": "    // Only check if this is near the start of the function (first 15 lines)"
          },
          {
            "lineNum": 3157,
            "content": "    if (!boundary || lineNum < boundary.start || lineNum > boundary.start + 15) {"
          },
          {
            "lineNum": 3158,
            "content": "      return;"
          },
          {
            "lineNum": 3159,
            "content": "    }"
          },
          {
            "lineNum": 3160,
            "content": "    "
          },
          {
            "lineNum": 3161,
            "content": "    // Check if this line has a default parameter pattern (prop = value)"
          },
          {
            "lineNum": 3162,
            "content": "    // Include booleans, numbers, strings, etc."
          },
          {
            "lineNum": 3163,
            "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?![=<>])(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,}\\s]+)/g;"
          },
          {
            "lineNum": 3164,
            "content": "    const hasDefaultParam = defaultParamPattern.test(lineWithoutComments);"
          },
          {
            "lineNum": 3165,
            "content": "    "
          },
          {
            "lineNum": 3166,
            "content": "    if (!hasDefaultParam) {"
          },
          {
            "lineNum": 3167,
            "content": "      return;"
          },
          {
            "lineNum": 3168,
            "content": "    }"
          },
          {
            "lineNum": 3169,
            "content": "    "
          },
          {
            "lineNum": 3170,
            "content": "    // Check if we're in a destructured assignment"
          },
          {
            "lineNum": 3171,
            "content": "    const inDestructuredAssignment = isInDestructuredAssignment(lineWithoutComments, index, lineNum, lines, boundary);"
          },
          {
            "lineNum": 3172,
            "content": "    "
          },
          {
            "lineNum": 3173,
            "content": "    // EXCLUDE regular const/let/var assignments that are NOT destructuring"
          },
          {
            "lineNum": 3174,
            "content": "    const isRegularAssignment = /^\\s*(const|let|var)\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*=\\s*(?!\\{)/.test(lineWithoutComments);"
          },
          {
            "lineNum": 3175,
            "content": "    "
          },
          {
            "lineNum": 3176,
            "content": "    if (inDestructuredAssignment && !isRegularAssignment) {"
          },
          {
            "lineNum": 3177,
            "content": "      // Match all default parameters on this line"
          },
          {
            "lineNum": 3178,
            "content": "      const defaultParamMatches = lineWithoutComments.match(defaultParamPattern);"
          },
          {
            "lineNum": 3179,
            "content": "      if (defaultParamMatches && defaultParamMatches.length > 0) {"
          },
          {
            "lineNum": 3180,
            "content": "        // Count each default parameter in the destructured assignment"
          },
          {
            "lineNum": 3181,
            "content": "        defaultParamMatches.forEach(() => {"
          },
          {
            "lineNum": 3182,
            "content": "          decisionPoints.push({ line: lineNum, type: 'default parameter', name: 'default parameter', functionLine });"
          },
          {
            "lineNum": 3183,
            "content": "        });"
          },
          {
            "lineNum": 3184,
            "content": "      }"
          },
          {
            "lineNum": 3185,
            "content": "    }"
          },
          {
            "lineNum": 3186,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "findBoundaryForFunction",
        "file": "scripts/html-generators.js",
        "line": 996,
        "actualComplexity": 7,
        "calculatedTotal": 2,
        "difference": -5,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 999,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 996,
          "end": 1012
        },
        "functionCode": [
          {
            "lineNum": 996,
            "content": "function findBoundaryForFunction(functionLine, functionBoundaries) {"
          },
          {
            "lineNum": 997,
            "content": "  let boundary = functionBoundaries.get(functionLine);"
          },
          {
            "lineNum": 998,
            "content": "  "
          },
          {
            "lineNum": 999,
            "content": "  if (!boundary) {"
          },
          {
            "lineNum": 1000,
            "content": "    // Find boundary that contains this function's line OR starts right after it"
          },
          {
            "lineNum": 1001,
            "content": "    // (e.g., function at line 39, boundary starts at 40)"
          },
          {
            "lineNum": 1002,
            "content": "    for (const [boundaryLine, b] of functionBoundaries.entries()) {"
          },
          {
            "lineNum": 1003,
            "content": "      if ((functionLine >= b.start && functionLine <= b.end) || "
          },
          {
            "lineNum": 1004,
            "content": "          (functionLine < b.start && b.start === functionLine + 1)) {"
          },
          {
            "lineNum": 1005,
            "content": "        boundary = b;"
          },
          {
            "lineNum": 1006,
            "content": "        break;"
          },
          {
            "lineNum": 1007,
            "content": "      }"
          },
          {
            "lineNum": 1008,
            "content": "    }"
          },
          {
            "lineNum": 1009,
            "content": "  }"
          },
          {
            "lineNum": 1010,
            "content": "  "
          },
          {
            "lineNum": 1011,
            "content": "  return boundary;"
          },
          {
            "lineNum": 1012,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "AudioControl (useEffect callback)",
        "file": "src/components/AudioControl/AudioControl.tsx",
        "line": 22,
        "actualComplexity": 8,
        "calculatedTotal": 3,
        "difference": -5,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 38,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 38,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 22,
          "end": 58
        },
        "functionCode": [
          {
            "lineNum": 22,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 23,
            "content": "    // Determine audio file based on theme (but don't create Audio yet - lazy load on interaction)"
          },
          {
            "lineNum": 24,
            "content": "    let audioFile: string | null = null;"
          },
          {
            "lineNum": 25,
            "content": "    if (currentPresetId === 'samson') {"
          },
          {
            "lineNum": 26,
            "content": "      audioFile = '/samson.mp3';"
          },
          {
            "lineNum": 27,
            "content": "    } else if (currentPresetId === 'noname') {"
          },
          {
            "lineNum": 28,
            "content": "      audioFile = '/noname.mp3';"
          },
          {
            "lineNum": 29,
            "content": "    } else if (currentPresetId === 'vapor-wave') {"
          },
          {
            "lineNum": 30,
            "content": "      audioFile = 'http://radio.plaza.one/mp3';"
          },
          {
            "lineNum": 31,
            "content": "    } else if (currentPresetId === 'king') {"
          },
          {
            "lineNum": 32,
            "content": "      audioFile = '/i_have_a_dream_speech.mp3';"
          },
          {
            "lineNum": 33,
            "content": "    } else if (currentPresetId === 'planet') {"
          },
          {
            "lineNum": 34,
            "content": "      audioFile = '/earth_song.mp3';"
          },
          {
            "lineNum": 35,
            "content": "    }"
          },
          {
            "lineNum": 36,
            "content": ""
          },
          {
            "lineNum": 37,
            "content": "    // Store audio file path, but don't create Audio instance yet (prevents eager download)"
          },
          {
            "lineNum": 38,
            "content": "    if (isThemeWithAudio && audioFile) {"
          },
          {
            "lineNum": 39,
            "content": "      audioFileRef.current = audioFile;"
          },
          {
            "lineNum": 40,
            "content": "    } else {"
          },
          {
            "lineNum": 41,
            "content": "      audioFileRef.current = null;"
          },
          {
            "lineNum": 42,
            "content": "    }"
          },
          {
            "lineNum": 43,
            "content": ""
          },
          {
            "lineNum": 44,
            "content": "    // Cleanup: if audio was created, clean it up when theme changes"
          },
          {
            "lineNum": 45,
            "content": "    return () => {"
          },
          {
            "lineNum": 46,
            "content": "      if (audioRef.current) {"
          },
          {
            "lineNum": 47,
            "content": "        audioRef.current.pause();"
          },
          {
            "lineNum": 48,
            "content": "        if (handlersRef.current) {"
          },
          {
            "lineNum": 49,
            "content": "          audioRef.current.removeEventListener('play', handlersRef.current.handlePlay);"
          },
          {
            "lineNum": 50,
            "content": "          audioRef.current.removeEventListener('pause', handlersRef.current.handlePause);"
          },
          {
            "lineNum": 51,
            "content": "          audioRef.current.removeEventListener('ended', handlersRef.current.handleEnded);"
          },
          {
            "lineNum": 52,
            "content": "        }"
          },
          {
            "lineNum": 53,
            "content": "        audioRef.current = null;"
          },
          {
            "lineNum": 54,
            "content": "      }"
          },
          {
            "lineNum": 55,
            "content": "      handlersRef.current = null;"
          },
          {
            "lineNum": 56,
            "content": "      setIsPlaying(false);"
          },
          {
            "lineNum": 57,
            "content": "    };"
          },
          {
            "lineNum": 58,
            "content": "  }, [isThemeWithAudio, currentPresetId]);"
          }
        ]
      },
      {
        "functionName": "findObjectLiteralClosingParen",
        "file": "scripts/function-boundaries.js",
        "line": 153,
        "actualComplexity": 7,
        "calculatedTotal": 3,
        "difference": -4,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 166,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 166,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 153,
          "end": 172
        },
        "functionCode": [
          {
            "lineNum": 153,
            "content": "function findObjectLiteralClosingParen(line, braceIndex) {"
          },
          {
            "lineNum": 154,
            "content": "  let parenCount = 1; // We know there's an opening ( before the {"
          },
          {
            "lineNum": 155,
            "content": "  "
          },
          {
            "lineNum": 156,
            "content": "  for (let k = braceIndex + 1; k < line.length; k++) {"
          },
          {
            "lineNum": 157,
            "content": "    if (line[k] === '(') {"
          },
          {
            "lineNum": 158,
            "content": "      parenCount++;"
          },
          {
            "lineNum": 159,
            "content": "    } else if (line[k] === ')') {"
          },
          {
            "lineNum": 160,
            "content": "      parenCount--;"
          },
          {
            "lineNum": 161,
            "content": "      if (parenCount === 0) {"
          },
          {
            "lineNum": 162,
            "content": "        // Found the closing paren of the object literal"
          },
          {
            "lineNum": 163,
            "content": "        // Check if there's a semicolon or closing paren after (end of expression)"
          },
          {
            "lineNum": 164,
            "content": "        const restOfLine = line.substring(k + 1).trim();"
          },
          {
            "lineNum": 165,
            "content": "        // Allow: ); or ; or ) or empty (end of expression)"
          },
          {
            "lineNum": 166,
            "content": "        return restOfLine.startsWith(';') || restOfLine.startsWith(')') || restOfLine === '';"
          },
          {
            "lineNum": 167,
            "content": "      }"
          },
          {
            "lineNum": 168,
            "content": "    }"
          },
          {
            "lineNum": 169,
            "content": "  }"
          },
          {
            "lineNum": 170,
            "content": "  "
          },
          {
            "lineNum": 171,
            "content": "  return false;"
          },
          {
            "lineNum": 172,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "findMatchingColonOnSameLine",
        "file": "scripts/decision-points.js",
        "line": 1842,
        "actualComplexity": 8,
        "calculatedTotal": 4,
        "difference": -4,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for",
            "line": 1851,
            "name": "for loop"
          },
          {
            "type": "ternary",
            "line": 1853,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 1859,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1842,
          "end": 1882
        },
        "functionCode": [
          {
            "lineNum": 1842,
            "content": "  const findMatchingColonOnSameLine = (line, questionIndex, startDepths, isInsideStringLiteral) => {"
          },
          {
            "lineNum": 1843,
            "content": "    let depths = {"
          },
          {
            "lineNum": 1844,
            "content": "      parenDepth: startDepths.parenDepth,"
          },
          {
            "lineNum": 1845,
            "content": "      braceDepth: startDepths.braceDepth,"
          },
          {
            "lineNum": 1846,
            "content": "      bracketDepth: startDepths.bracketDepth,"
          },
          {
            "lineNum": 1847,
            "content": "      ternaryDepth: 0"
          },
          {
            "lineNum": 1848,
            "content": "    };"
          },
          {
            "lineNum": 1849,
            "content": "    const isJSX = isJSXTernary(line, questionIndex);"
          },
          {
            "lineNum": 1850,
            "content": "    "
          },
          {
            "lineNum": 1851,
            "content": "    for (let i = questionIndex + 1; i < line.length; i++) {"
          },
          {
            "lineNum": 1852,
            "content": "      const char = line[i];"
          },
          {
            "lineNum": 1853,
            "content": "      const nextChar = i + 1 < line.length ? line[i + 1] : '';"
          },
          {
            "lineNum": 1854,
            "content": "      "
          },
          {
            "lineNum": 1855,
            "content": "      // Update nesting depths"
          },
          {
            "lineNum": 1856,
            "content": "      const updated = updateSameLineDepths(char, nextChar, depths, isInsideStringLiteral, line, i);"
          },
          {
            "lineNum": 1857,
            "content": "      depths = updated;"
          },
          {
            "lineNum": 1858,
            "content": "      "
          },
          {
            "lineNum": 1859,
            "content": "      if (updated.shouldBreak) {"
          },
          {
            "lineNum": 1860,
            "content": "        break;"
          },
          {
            "lineNum": 1861,
            "content": "      }"
          },
          {
            "lineNum": 1862,
            "content": "      "
          },
          {
            "lineNum": 1863,
            "content": "      // If we hit a :, check if it's our matching colon"
          },
          {
            "lineNum": 1864,
            "content": "      if (char === ':') {"
          },
          {
            "lineNum": 1865,
            "content": "        const colonResult = handleColonInSameLine(depths, startDepths);"
          },
          {
            "lineNum": 1866,
            "content": "        if (colonResult === true) {"
          },
          {
            "lineNum": 1867,
            "content": "          return true;"
          },
          {
            "lineNum": 1868,
            "content": "        }"
          },
          {
            "lineNum": 1869,
            "content": "        if (colonResult === null) {"
          },
          {
            "lineNum": 1870,
            "content": "          depths.ternaryDepth--;"
          },
          {
            "lineNum": 1871,
            "content": "          continue;"
          },
          {
            "lineNum": 1872,
            "content": "        }"
          },
          {
            "lineNum": 1873,
            "content": "      }"
          },
          {
            "lineNum": 1874,
            "content": "      "
          },
          {
            "lineNum": 1875,
            "content": "      // Stop if we hit certain characters"
          },
          {
            "lineNum": 1876,
            "content": "      if (shouldStopSameLineAtChar(char, depths, startDepths, isJSX)) {"
          },
          {
            "lineNum": 1877,
            "content": "        break;"
          },
          {
            "lineNum": 1878,
            "content": "      }"
          },
          {
            "lineNum": 1879,
            "content": "    }"
          },
          {
            "lineNum": 1880,
            "content": "    "
          },
          {
            "lineNum": 1881,
            "content": "    return false;"
          },
          {
            "lineNum": 1882,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "handleBackdropClick (useCallback callback)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 704,
        "actualComplexity": 6,
        "calculatedTotal": 2,
        "difference": -4,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 721,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 704,
          "end": 727
        },
        "functionCode": [
          {
            "lineNum": 704,
            "content": "  const colorToHex = useCallback((color: string): string => {"
          },
          {
            "lineNum": 705,
            "content": "    try {"
          },
          {
            "lineNum": 706,
            "content": "      // Handle rgba - extract rgb values (color input doesn't support alpha)"
          },
          {
            "lineNum": 707,
            "content": "      if (color.startsWith('rgba')) {"
          },
          {
            "lineNum": 708,
            "content": "        const matches = color.match(/\\d+/g);"
          },
          {
            "lineNum": 709,
            "content": "        if (matches && matches.length >= 3) {"
          },
          {
            "lineNum": 710,
            "content": "          const r = parseInt(matches[0]);"
          },
          {
            "lineNum": 711,
            "content": "          const g = parseInt(matches[1]);"
          },
          {
            "lineNum": 712,
            "content": "          const b = parseInt(matches[2]);"
          },
          {
            "lineNum": 713,
            "content": "          return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;"
          },
          {
            "lineNum": 714,
            "content": "        }"
          },
          {
            "lineNum": 715,
            "content": "      }"
          },
          {
            "lineNum": 716,
            "content": "      // Use color library to handle other formats (rgb, hex, etc.)"
          },
          {
            "lineNum": 717,
            "content": "      const parsed = Color(color);"
          },
          {
            "lineNum": 718,
            "content": "      return parsed.hex();"
          },
          {
            "lineNum": 719,
            "content": "    } catch {"
          },
          {
            "lineNum": 720,
            "content": "      // Fallback: if it's already hex, return as-is"
          },
          {
            "lineNum": 721,
            "content": "      if (color.startsWith('#')) {"
          },
          {
            "lineNum": 722,
            "content": "        return color;"
          },
          {
            "lineNum": 723,
            "content": "      }"
          },
          {
            "lineNum": 724,
            "content": "      // Default fallback"
          },
          {
            "lineNum": 725,
            "content": "      return '#000000';"
          },
          {
            "lineNum": 726,
            "content": "    }"
          },
          {
            "lineNum": 727,
            "content": "  }, []);"
          }
        ]
      },
      {
        "functionName": "processLineForDecisionPoints",
        "file": "scripts/decision-points.js",
        "line": 3614,
        "actualComplexity": 19,
        "calculatedTotal": 16,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 3616,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 3617,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3620,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 3620,
            "name": "logical OR"
          },
          {
            "type": "while",
            "line": 3720,
            "name": "while loop"
          },
          {
            "type": "ternary",
            "line": 3721,
            "name": "ternary operator"
          },
          {
            "type": "||",
            "line": 3722,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 3722,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 3723,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3726,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3728,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 3728,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3729,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3739,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3739,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 5,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 1,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 4,
          "||": 4,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3614,
          "end": 3824
        },
        "functionCode": [
          {
            "lineNum": 3614,
            "content": "  const processLineForDecisionPoints = (line, index, lines, lineToFunctions, functionBoundaries, getInnermostFunction, isInsideStringLiteral, hasQuestionMarkOutsideString, decisionPoints) => {"
          },
          {
            "lineNum": 3615,
            "content": "    const lineNum = index + 1;"
          },
          {
            "lineNum": 3616,
            "content": "    const containingFunctions = lineToFunctions.get(lineNum) || [];"
          },
          {
            "lineNum": 3617,
            "content": "    if (containingFunctions.length === 0) return; // Skip lines outside functions"
          },
          {
            "lineNum": 3618,
            "content": "    "
          },
          {
            "lineNum": 3619,
            "content": "    const trimmed = line.trim();"
          },
          {
            "lineNum": 3620,
            "content": "    if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('*')) {"
          },
          {
            "lineNum": 3621,
            "content": "      return; // Skip empty lines and comments"
          },
          {
            "lineNum": 3622,
            "content": "    }"
          },
          {
            "lineNum": 3623,
            "content": "    "
          },
          {
            "lineNum": 3624,
            "content": "    // Remove comments from line for parsing"
          },
          {
            "lineNum": 3625,
            "content": "    const lineWithoutComments = line.replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
          },
          {
            "lineNum": 3626,
            "content": "    "
          },
          {
            "lineNum": 3627,
            "content": "    // Special handling for control structures (if, for, while, etc.) that contain callbacks"
          },
          {
            "lineNum": 3628,
            "content": "    // These should always belong to the immediate parent function, not nested callbacks"
          },
          {
            "lineNum": 3629,
            "content": "    // Check if this line contains a control structure"
          },
          {
            "lineNum": 3630,
            "content": "    const isControlStructure = /^\\s*(if|for|while|switch)\\s*\\(/.test(lineWithoutComments);"
          },
          {
            "lineNum": 3631,
            "content": "    "
          },
          {
            "lineNum": 3632,
            "content": "    // Find the function to assign this decision point to"
          },
          {
            "lineNum": 3633,
            "content": "    // For control structures, prefer immediate parent function even if there's a nested callback on the same line"
          },
          {
            "lineNum": 3634,
            "content": "    const functionLine = getFunctionLineForControlStructure("
          },
          {
            "lineNum": 3635,
            "content": "      isControlStructure,"
          },
          {
            "lineNum": 3636,
            "content": "      lineNum,"
          },
          {
            "lineNum": 3637,
            "content": "      containingFunctions,"
          },
          {
            "lineNum": 3638,
            "content": "      functionBoundaries,"
          },
          {
            "lineNum": 3639,
            "content": "      getInnermostFunction"
          },
          {
            "lineNum": 3640,
            "content": "    );"
          },
          {
            "lineNum": 3641,
            "content": "    "
          },
          {
            "lineNum": 3642,
            "content": "    if (!functionLine) return; // Skip if no function found"
          },
          {
            "lineNum": 3643,
            "content": "    "
          },
          {
            "lineNum": 3644,
            "content": "    // Get function boundary to limit template literal lookback"
          },
          {
            "lineNum": 3645,
            "content": "    const boundary = functionBoundaries.get(functionLine);"
          },
          {
            "lineNum": 3646,
            "content": "    const functionStartIndex = boundary ? Math.max(0, boundary.start - 1) : 0;"
          },
          {
            "lineNum": 3647,
            "content": "    "
          },
          {
            "lineNum": 3648,
            "content": "    // Create a bound version of isInsideStringLiteral with line context for multi-line template literal support"
          },
          {
            "lineNum": 3649,
            "content": "    // Only look back within the function's boundary to avoid incorrectly excluding decision points from other functions"
          },
          {
            "lineNum": 3650,
            "content": "    // IMPORTANT: Always use the original line (with comments) for template literal detection"
          },
          {
            "lineNum": 3651,
            "content": "    // The lookback processes original lines, so we need consistency"
          },
          {
            "lineNum": 3652,
            "content": "    const isInsideStringLiteralWithContext = (lineToCheck, charIndex) => {"
          },
          {
            "lineNum": 3653,
            "content": "      // Always use the original line for template literal detection to match what lookback processes"
          },
          {
            "lineNum": 3654,
            "content": "      // Always pass lineIndex, allLines, and functionStartIndex for accurate multi-line template literal detection"
          },
          {
            "lineNum": 3655,
            "content": "      if (lineToCheck === line) {"
          },
          {
            "lineNum": 3656,
            "content": "        // Same line - use charIndex directly with full context"
          },
          {
            "lineNum": 3657,
            "content": "        return isInsideStringLiteral(line, charIndex, index, lines, functionStartIndex);"
          },
          {
            "lineNum": 3658,
            "content": "      }"
          },
          {
            "lineNum": 3659,
            "content": "      "
          },
          {
            "lineNum": 3660,
            "content": "      // Different line (lineWithoutComments) - find the character at charIndex in the original line"
          },
          {
            "lineNum": 3661,
            "content": "      // Since comments are removed with .replace().trim(), indices should mostly match"
          },
          {
            "lineNum": 3662,
            "content": "      // But to be safe, find the character sequence around charIndex"
          },
          {
            "lineNum": 3663,
            "content": "      const charAtPos = lineToCheck[charIndex];"
          }
        ]
      },
      {
        "functionName": "isInsideStringLiteral",
        "file": "scripts/decision-points.js",
        "line": 509,
        "actualComplexity": 16,
        "calculatedTotal": 13,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "for",
            "line": 524,
            "name": "for loop"
          },
          {
            "type": "if",
            "line": 526,
            "name": "if statement"
          },
          {
            "type": "for",
            "line": 529,
            "name": "for loop"
          },
          {
            "type": "ternary",
            "line": 531,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 534,
            "name": "if statement"
          },
          {
            "type": "for",
            "line": 542,
            "name": "for loop"
          },
          {
            "type": "&&",
            "line": 542,
            "name": "logical AND"
          },
          {
            "type": "ternary",
            "line": 544,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 549,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 3,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 2,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 3
        },
        "boundary": {
          "start": 509,
          "end": 558
        },
        "functionCode": [
          {
            "lineNum": 509,
            "content": "  const isInsideStringLiteral = (line, charIndex, lineIndex = -1, allLines = [], functionStartIndex = 0) => {"
          },
          {
            "lineNum": 510,
            "content": "    let state = {"
          },
          {
            "lineNum": 511,
            "content": "      inSingleQuote: false,"
          },
          {
            "lineNum": 512,
            "content": "      inDoubleQuote: false,"
          },
          {
            "lineNum": 513,
            "content": "      inTemplateLiteral: false,"
          },
          {
            "lineNum": 514,
            "content": "      inTemplateExpression: false,"
          },
          {
            "lineNum": 515,
            "content": "      braceDepth: 0,"
          },
          {
            "lineNum": 516,
            "content": "      escapeNext: false"
          },
          {
            "lineNum": 517,
            "content": "    };"
          },
          {
            "lineNum": 518,
            "content": "    "
          },
          {
            "lineNum": 519,
            "content": "    // If we have line context, look backwards to find template literal starts"
          },
          {
            "lineNum": 520,
            "content": "    // Only look back within the function's boundary to avoid incorrectly excluding decision points"
          },
          {
            "lineNum": 521,
            "content": "    // Process ALL lines from function start to current line to correctly track template literal state"
          },
          {
            "lineNum": 522,
            "content": "    if (lineIndex >= 0 && allLines.length > 0 && functionStartIndex >= 0) {"
          },
          {
            "lineNum": 523,
            "content": "      // Process all lines from function start to current line (excluding current line - we'll process it separately)"
          },
          {
            "lineNum": 524,
            "content": "      for (let i = functionStartIndex; i < lineIndex; i++) {"
          },
          {
            "lineNum": 525,
            "content": "        const prevLine = allLines[i];"
          },
          {
            "lineNum": 526,
            "content": "        if (!prevLine) continue;"
          },
          {
            "lineNum": 527,
            "content": "        "
          },
          {
            "lineNum": 528,
            "content": "        // Process the previous line to update template literal state"
          },
          {
            "lineNum": 529,
            "content": "        for (let j = 0; j < prevLine.length; j++) {"
          },
          {
            "lineNum": 530,
            "content": "          const char = prevLine[j];"
          },
          {
            "lineNum": 531,
            "content": "          const nextChar = j + 1 < prevLine.length ? prevLine[j + 1] : '';"
          },
          {
            "lineNum": 532,
            "content": "          const result = processCharacterForStringLiteral(char, nextChar, state);"
          },
          {
            "lineNum": 533,
            "content": "          state = result;"
          },
          {
            "lineNum": 534,
            "content": "          if (result.skipNext) {"
          },
          {
            "lineNum": 535,
            "content": "            j++; // Skip the next character"
          },
          {
            "lineNum": 536,
            "content": "          }"
          },
          {
            "lineNum": 537,
            "content": "        }"
          },
          {
            "lineNum": 538,
            "content": "      }"
          },
          {
            "lineNum": 539,
            "content": "    }"
          },
          {
            "lineNum": 540,
            "content": "    "
          },
          {
            "lineNum": 541,
            "content": "    // Process current line up to charIndex"
          },
          {
            "lineNum": 542,
            "content": "    for (let i = 0; i < charIndex && i < line.length; i++) {"
          },
          {
            "lineNum": 543,
            "content": "      const char = line[i];"
          },
          {
            "lineNum": 544,
            "content": "      const nextChar = i + 1 < line.length ? line[i + 1] : '';"
          },
          {
            "lineNum": 545,
            "content": "      "
          },
          {
            "lineNum": 546,
            "content": "      const result = processCharacterForStringLiteral(char, nextChar, state);"
          },
          {
            "lineNum": 547,
            "content": "      state = result;"
          },
          {
            "lineNum": 548,
            "content": "      "
          },
          {
            "lineNum": 549,
            "content": "      if (result.skipNext) {"
          },
          {
            "lineNum": 550,
            "content": "        i++; // Skip the next character (e.g., '{' in ${)"
          },
          {
            "lineNum": 551,
            "content": "      }"
          },
          {
            "lineNum": 552,
            "content": "    }"
          },
          {
            "lineNum": 553,
            "content": "    "
          },
          {
            "lineNum": 554,
            "content": "    // Use isInStringLiteralFromState which correctly handles template literals:"
          },
          {
            "lineNum": 555,
            "content": "    // - Inside template literal string (not in expression): returns true (skip decision point)"
          },
          {
            "lineNum": 556,
            "content": "    // - Inside template literal expression (${...}): returns false (count decision point)"
          },
          {
            "lineNum": 557,
            "content": "    return isInStringLiteralFromState(state);"
          },
          {
            "lineNum": 558,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "trackParameterListBoundaries",
        "file": "scripts/decision-points.js",
        "line": 902,
        "actualComplexity": 10,
        "calculatedTotal": 7,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for",
            "line": 905,
            "name": "for loop"
          },
          {
            "type": "if",
            "line": 908,
            "name": "if statement"
          },
          {
            "type": "else if",
            "line": 910,
            "name": "else if statement"
          },
          {
            "type": "else if",
            "line": 912,
            "name": "else if statement"
          },
          {
            "type": "if",
            "line": 914,
            "name": "if statement"
          },
          {
            "type": "else if",
            "line": 918,
            "name": "else if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 3,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 902,
          "end": 934
        },
        "functionCode": [
          {
            "lineNum": 902,
            "content": "  const trackParameterListBoundaries = (checkLine, checkLineNum, boundaryStart, state) => {"
          },
          {
            "lineNum": 903,
            "content": "    let currentState = { ...state };"
          },
          {
            "lineNum": 904,
            "content": "    "
          },
          {
            "lineNum": 905,
            "content": "    for (let j = 0; j < checkLine.length; j++) {"
          },
          {
            "lineNum": 906,
            "content": "      const char = checkLine[j];"
          },
          {
            "lineNum": 907,
            "content": "      "
          },
          {
            "lineNum": 908,
            "content": "      if (char === '(') {"
          },
          {
            "lineNum": 909,
            "content": "        currentState = handleOpeningParen(currentState);"
          },
          {
            "lineNum": 910,
            "content": "      } else if (char === ')') {"
          },
          {
            "lineNum": 911,
            "content": "        currentState = handleClosingParen(currentState);"
          },
          {
            "lineNum": 912,
            "content": "      } else if (char === '{') {"
          },
          {
            "lineNum": 913,
            "content": "        const braceResult = handleOpeningBrace(checkLine, checkLineNum, boundaryStart, currentState);"
          },
          {
            "lineNum": 914,
            "content": "        if (typeof braceResult === 'number') {"
          },
          {
            "lineNum": 915,
            "content": "          return braceResult;"
          },
          {
            "lineNum": 916,
            "content": "        }"
          },
          {
            "lineNum": 917,
            "content": "        currentState = braceResult;"
          },
          {
            "lineNum": 918,
            "content": "      } else if (char === '}') {"
          },
          {
            "lineNum": 919,
            "content": "        currentState = {"
          },
          {
            "lineNum": 920,
            "content": "          ...currentState,"
          },
          {
            "lineNum": 921,
            "content": "          braceDepth: currentState.braceDepth - 1"
          },
          {
            "lineNum": 922,
            "content": "        };"
          },
          {
            "lineNum": 923,
            "content": "      }"
          },
          {
            "lineNum": 924,
            "content": "      "
          },
          {
            "lineNum": 925,
            "content": "      // Check if we've found the closing paren after processing this character"
          },
          {
            "lineNum": 926,
            "content": "      // For destructured parameters like }: Type), we need parenDepth = 0 and braceDepth = 0"
          },
          {
            "lineNum": 927,
            "content": "      if (currentState.foundClosingParen && currentState.parenDepth === 0 && currentState.braceDepth === 0) {"
          },
          {
            "lineNum": 928,
            "content": "        return checkLineNum;"
          },
          {
            "lineNum": 929,
            "content": "      }"
          },
          {
            "lineNum": 930,
            "content": "    }"
          },
          {
            "lineNum": 931,
            "content": "    "
          },
          {
            "lineNum": 932,
            "content": "    // Return updated state so it can be used in next iteration"
          },
          {
            "lineNum": 933,
            "content": "    return currentState;"
          },
          {
            "lineNum": 934,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "checkJSXAttribute",
        "file": "scripts/decision-points.js",
        "line": 1125,
        "actualComplexity": 8,
        "calculatedTotal": 5,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 1126,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 1126,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 1131,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1131,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1125,
          "end": 1134
        },
        "functionCode": [
          {
            "lineNum": 1125,
            "content": "  const checkJSXAttribute = (lineWithoutComments, index, lines) => {"
          },
          {
            "lineNum": 1126,
            "content": "    if (index >= 0 && lines.length > 0) {"
          },
          {
            "lineNum": 1127,
            "content": "      return isJSXAttributeLine(lineWithoutComments, index, lines);"
          },
          {
            "lineNum": 1128,
            "content": "    }"
          },
          {
            "lineNum": 1129,
            "content": "    // Fallback for single-line check (backward compatibility)"
          },
          {
            "lineNum": 1130,
            "content": "    const hasJSXExpression = /\\{[^}]*\\}/.test(lineWithoutComments);"
          },
          {
            "lineNum": 1131,
            "content": "    const hasJSXTag = /<[A-Za-z]/.test(lineWithoutComments) || /<\\/[A-Za-z]/.test(lineWithoutComments) || /\\/>/.test(lineWithoutComments);"
          },
          {
            "lineNum": 1132,
            "content": "    const hasJSXAttributePattern = /^\\s*\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments) || /\\s+\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments);"
          },
          {
            "lineNum": 1133,
            "content": "    return (hasJSXExpression || hasJSXTag) && hasJSXAttributePattern;"
          },
          {
            "lineNum": 1134,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "handleArrowFunctionDetection",
        "file": "scripts/decision-points.js",
        "line": 824,
        "actualComplexity": 6,
        "calculatedTotal": 3,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 825,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 830,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 824,
          "end": 843
        },
        "functionCode": [
          {
            "lineNum": 824,
            "content": "  const handleArrowFunctionDetection = (checkLine, lineNum, checkLineNum, lineWithoutComments) => {"
          },
          {
            "lineNum": 825,
            "content": "    if (!checkLine.includes('=>')) {"
          },
          {
            "lineNum": 826,
            "content": "      return null;"
          },
          {
            "lineNum": 827,
            "content": "    }"
          },
          {
            "lineNum": 828,
            "content": "    "
          },
          {
            "lineNum": 829,
            "content": "    const arrowIndex = checkLine.indexOf('=>');"
          },
          {
            "lineNum": 830,
            "content": "    if (lineNum === checkLineNum) {"
          },
          {
            "lineNum": 831,
            "content": "      // Current line is the line with =>, check if we're before it"
          },
          {
            "lineNum": 832,
            "content": "      if (lineWithoutComments.indexOf('=>') === -1 || lineWithoutComments.indexOf('=') < lineWithoutComments.indexOf('=>')) {"
          },
          {
            "lineNum": 833,
            "content": "        return checkLineNum + 1; // Parameter list includes this line"
          },
          {
            "lineNum": 834,
            "content": "      } else {"
          },
          {
            "lineNum": 835,
            "content": "        return checkLineNum; // Parameter list ends before =>"
          },
          {
            "lineNum": 836,
            "content": "      }"
          },
          {
            "lineNum": 837,
            "content": "    } else if (lineNum < checkLineNum) {"
          },
          {
            "lineNum": 838,
            "content": "      // Current line is before the line with =>, so it's in parameter list"
          },
          {
            "lineNum": 839,
            "content": "      return checkLineNum + 1; // Include the line with =>"
          },
          {
            "lineNum": 840,
            "content": "    }"
          },
          {
            "lineNum": 841,
            "content": "    "
          },
          {
            "lineNum": 842,
            "content": "    return null;"
          },
          {
            "lineNum": 843,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "hasJSXInPreviousLines",
        "file": "scripts/decision-points.js",
        "line": 1034,
        "actualComplexity": 6,
        "calculatedTotal": 3,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for",
            "line": 1035,
            "name": "for loop"
          },
          {
            "type": "if",
            "line": 1044,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1034,
          "end": 1054
        },
        "functionCode": [
          {
            "lineNum": 1034,
            "content": "  const hasJSXInPreviousLines = (index, lines) => {"
          },
          {
            "lineNum": 1035,
            "content": "    for (let i = index - 1; i >= Math.max(0, index - 10); i--) {"
          },
          {
            "lineNum": 1036,
            "content": "      const prevLine = lines[i].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '');"
          },
          {
            "lineNum": 1037,
            "content": "      "
          },
          {
            "lineNum": 1038,
            "content": "      // If we find a closing tag, we're not in JSX context"
          },
          {
            "lineNum": 1039,
            "content": "      if (/\\/>/.test(prevLine) || /<\\/[A-Za-z]/.test(prevLine)) {"
          },
          {
            "lineNum": 1040,
            "content": "        return false;"
          },
          {
            "lineNum": 1041,
            "content": "      }"
          },
          {
            "lineNum": 1042,
            "content": "      "
          },
          {
            "lineNum": 1043,
            "content": "      // If we find an opening tag, we're in JSX context"
          },
          {
            "lineNum": 1044,
            "content": "      if (/<[A-Za-z]/.test(prevLine)) {"
          },
          {
            "lineNum": 1045,
            "content": "        return true;"
          },
          {
            "lineNum": 1046,
            "content": "      }"
          },
          {
            "lineNum": 1047,
            "content": "      "
          },
          {
            "lineNum": 1048,
            "content": "      // If we hit a line that's clearly not JSX (like a function declaration or return statement), stop"
          },
          {
            "lineNum": 1049,
            "content": "      if (/^\\s*(function|const|let|var|return|if|for|while)\\s/.test(prevLine)) {"
          },
          {
            "lineNum": 1050,
            "content": "        return false;"
          },
          {
            "lineNum": 1051,
            "content": "      }"
          },
          {
            "lineNum": 1052,
            "content": "    }"
          },
          {
            "lineNum": 1053,
            "content": "    return false;"
          },
          {
            "lineNum": 1054,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "parseDefaultParameters",
        "file": "scripts/decision-points.js",
        "line": 1472,
        "actualComplexity": 6,
        "calculatedTotal": 3,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1474,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 1475,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1472,
          "end": 1519
        },
        "functionCode": [
          {
            "lineNum": 1472,
            "content": "  const parseDefaultParameters = (lineWithoutComments, lineNum, index, lines, functionLine, functionBoundaries, getInnermostFunction, decisionPoints) => {"
          },
          {
            "lineNum": 1473,
            "content": "    const hasArrowFunction = lineWithoutComments.includes('=>');"
          },
          {
            "lineNum": 1474,
            "content": "    const arrowIndex = hasArrowFunction ? lineWithoutComments.indexOf('=>') : -1;"
          },
          {
            "lineNum": 1475,
            "content": "    const isArrowFunctionParam = hasArrowFunction && arrowIndex > 0;"
          },
          {
            "lineNum": 1476,
            "content": "    "
          },
          {
            "lineNum": 1477,
            "content": "    // Determine which function's boundary to use"
          },
          {
            "lineNum": 1478,
            "content": "    let actualFunctionLine = functionLine;"
          },
          {
            "lineNum": 1479,
            "content": "    let boundary = functionBoundaries.get(functionLine);"
          },
          {
            "lineNum": 1480,
            "content": "    "
          },
          {
            "lineNum": 1481,
            "content": "    if (isArrowFunctionParam) {"
          },
          {
            "lineNum": 1482,
            "content": "      const callbackInfo = findCallbackFunctionLine(lineNum, functionLine, functionBoundaries, getInnermostFunction);"
          },
          {
            "lineNum": 1483,
            "content": "      actualFunctionLine = callbackInfo.actualFunctionLine;"
          },
          {
            "lineNum": 1484,
            "content": "      boundary = callbackInfo.boundary;"
          },
          {
            "lineNum": 1485,
            "content": "      "
          },
          {
            "lineNum": 1486,
            "content": "      // Handle arrow function default parameters directly"
          },
          {
            "lineNum": 1487,
            "content": "      handleArrowFunctionDefaultParams(lineWithoutComments, arrowIndex, lineNum, actualFunctionLine, decisionPoints, index, lines);"
          },
          {
            "lineNum": 1488,
            "content": "    }"
          },
          {
            "lineNum": 1489,
            "content": "    "
          },
          {
            "lineNum": 1490,
            "content": "    if (!boundary) return;"
          },
          {
            "lineNum": 1491,
            "content": "    "
          },
          {
            "lineNum": 1492,
            "content": "    const hasFunctionSig = hasFunctionSignature(lineWithoutComments, isArrowFunctionParam);"
          },
          {
            "lineNum": 1493,
            "content": "    let paramListEnd = findParameterListEnd(lineNum, boundary.start, lines, lineWithoutComments);"
          },
          {
            "lineNum": 1494,
            "content": "    paramListEnd = applyParameterListEndFallbacks("
          },
          {
            "lineNum": 1495,
            "content": "      paramListEnd,"
          },
          {
            "lineNum": 1496,
            "content": "      boundary.start,"
          },
          {
            "lineNum": 1497,
            "content": "      lineNum,"
          },
          {
            "lineNum": 1498,
            "content": "      index,"
          },
          {
            "lineNum": 1499,
            "content": "      lines,"
          },
          {
            "lineNum": 1500,
            "content": "      lineWithoutComments,"
          },
          {
            "lineNum": 1501,
            "content": "      hasFunctionSig"
          },
          {
            "lineNum": 1502,
            "content": "    );"
          },
          {
            "lineNum": 1503,
            "content": "    "
          },
          {
            "lineNum": 1504,
            "content": "    if (shouldProcessDefaultParameters(lineWithoutComments, lineNum, index, lines, boundary, isArrowFunctionParam, hasFunctionSig, paramListEnd)) {"
          },
          {
            "lineNum": 1505,
            "content": "      processNonArrowDefaultParameters("
          },
          {
            "lineNum": 1506,
            "content": "        lineWithoutComments,"
          },
          {
            "lineNum": 1507,
            "content": "        lineNum,"
          },
          {
            "lineNum": 1508,
            "content": "        index,"
          },
          {
            "lineNum": 1509,
            "content": "        lines,"
          },
          {
            "lineNum": 1510,
            "content": "        arrowIndex,"
          },
          {
            "lineNum": 1511,
            "content": "        isArrowFunctionParam,"
          },
          {
            "lineNum": 1512,
            "content": "        boundary,"
          },
          {
            "lineNum": 1513,
            "content": "        hasFunctionSig,"
          },
          {
            "lineNum": 1514,
            "content": "        paramListEnd,"
          },
          {
            "lineNum": 1515,
            "content": "        functionLine,"
          },
          {
            "lineNum": 1516,
            "content": "        decisionPoints"
          },
          {
            "lineNum": 1517,
            "content": "      );"
          },
          {
            "lineNum": 1518,
            "content": "    }"
          },
          {
            "lineNum": 1519,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "shouldStopConditionLookback",
        "file": "scripts/decision-points.js",
        "line": 2949,
        "actualComplexity": 6,
        "calculatedTotal": 3,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 2951,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 2952,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2949,
          "end": 2967
        },
        "functionCode": [
          {
            "lineNum": 2949,
            "content": "  const shouldStopConditionLookback = (checkLine, checkLineHasLogicalOp, checkLineIsBooleanAssignment) => {"
          },
          {
            "lineNum": 2950,
            "content": "    // Skip if this is a JSX expression line"
          },
          {
            "lineNum": 2951,
            "content": "    const checkLineIsJSX = checkLine.includes('{') && /[&|]{2}/.test(checkLine);"
          },
          {
            "lineNum": 2952,
            "content": "    if (checkLineIsJSX) {"
          },
          {
            "lineNum": 2953,
            "content": "      return true;"
          },
          {
            "lineNum": 2954,
            "content": "    }"
          },
          {
            "lineNum": 2955,
            "content": "    "
          },
          {
            "lineNum": 2956,
            "content": "    // Skip boolean assignments - they're handled separately"
          },
          {
            "lineNum": 2957,
            "content": "    if (checkLineIsBooleanAssignment) {"
          },
          {
            "lineNum": 2958,
            "content": "      return true;"
          },
          {
            "lineNum": 2959,
            "content": "    }"
          },
          {
            "lineNum": 2960,
            "content": "    "
          },
          {
            "lineNum": 2961,
            "content": "    // Stop if we hit a closing brace or semicolon (end of condition)"
          },
          {
            "lineNum": 2962,
            "content": "    if (/[;}]/.test(checkLine) && !checkLineHasLogicalOp) {"
          },
          {
            "lineNum": 2963,
            "content": "      return true;"
          },
          {
            "lineNum": 2964,
            "content": "    }"
          },
          {
            "lineNum": 2965,
            "content": "    "
          },
          {
            "lineNum": 2966,
            "content": "    return false;"
          },
          {
            "lineNum": 2967,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "AudioControl",
        "file": "src/components/AudioControl/AudioControl.tsx",
        "line": 6,
        "actualComplexity": 9,
        "calculatedTotal": 6,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 20,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 20,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 20,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 20,
            "name": "logical OR"
          },
          {
            "type": "ternary",
            "line": 122,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 4,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 6,
          "end": 128
        },
        "functionCode": [
          {
            "lineNum": 6,
            "content": "export function AudioControl() {"
          },
          {
            "lineNum": 7,
            "content": "  const { currentPresetId } = useTheme();"
          },
          {
            "lineNum": 8,
            "content": "  const [isPlaying, setIsPlaying] = useState(false);"
          },
          {
            "lineNum": 9,
            "content": "  const audioRef = useRef<HTMLAudioElement | null>(null);"
          },
          {
            "lineNum": 10,
            "content": "  // Store the audio file path (lazy-loaded - only create Audio on user interaction)"
          },
          {
            "lineNum": 11,
            "content": "  const audioFileRef = useRef<string | null>(null);"
          },
          {
            "lineNum": 12,
            "content": "  // Store handlers so we can remove them properly"
          },
          {
            "lineNum": 13,
            "content": "  const handlersRef = useRef<{"
          },
          {
            "lineNum": 14,
            "content": "    handlePlay: () => void;"
          },
          {
            "lineNum": 15,
            "content": "    handlePause: () => void;"
          },
          {
            "lineNum": 16,
            "content": "    handleEnded: () => void;"
          },
          {
            "lineNum": 17,
            "content": "  } | null>(null);"
          },
          {
            "lineNum": 18,
            "content": ""
          },
          {
            "lineNum": 19,
            "content": "  // Show when noname, samson, vapor-wave, king, or planet theme is active"
          },
          {
            "lineNum": 20,
            "content": "  const isThemeWithAudio = currentPresetId === 'noname' || currentPresetId === 'samson' || currentPresetId === 'vapor-wave' || currentPresetId === 'king' || currentPresetId === 'planet';"
          },
          {
            "lineNum": 21,
            "content": ""
          },
          {
            "lineNum": 22,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 23,
            "content": "    // Determine audio file based on theme (but don't create Audio yet - lazy load on interaction)"
          },
          {
            "lineNum": 24,
            "content": "    let audioFile: string | null = null;"
          },
          {
            "lineNum": 25,
            "content": "    if (currentPresetId === 'samson') {"
          },
          {
            "lineNum": 26,
            "content": "      audioFile = '/samson.mp3';"
          },
          {
            "lineNum": 27,
            "content": "    } else if (currentPresetId === 'noname') {"
          },
          {
            "lineNum": 28,
            "content": "      audioFile = '/noname.mp3';"
          },
          {
            "lineNum": 29,
            "content": "    } else if (currentPresetId === 'vapor-wave') {"
          },
          {
            "lineNum": 30,
            "content": "      audioFile = 'http://radio.plaza.one/mp3';"
          },
          {
            "lineNum": 31,
            "content": "    } else if (currentPresetId === 'king') {"
          },
          {
            "lineNum": 32,
            "content": "      audioFile = '/i_have_a_dream_speech.mp3';"
          },
          {
            "lineNum": 33,
            "content": "    } else if (currentPresetId === 'planet') {"
          },
          {
            "lineNum": 34,
            "content": "      audioFile = '/earth_song.mp3';"
          },
          {
            "lineNum": 35,
            "content": "    }"
          },
          {
            "lineNum": 36,
            "content": ""
          },
          {
            "lineNum": 37,
            "content": "    // Store audio file path, but don't create Audio instance yet (prevents eager download)"
          },
          {
            "lineNum": 38,
            "content": "    if (isThemeWithAudio && audioFile) {"
          },
          {
            "lineNum": 39,
            "content": "      audioFileRef.current = audioFile;"
          },
          {
            "lineNum": 40,
            "content": "    } else {"
          },
          {
            "lineNum": 41,
            "content": "      audioFileRef.current = null;"
          },
          {
            "lineNum": 42,
            "content": "    }"
          },
          {
            "lineNum": 43,
            "content": ""
          },
          {
            "lineNum": 44,
            "content": "    // Cleanup: if audio was created, clean it up when theme changes"
          },
          {
            "lineNum": 45,
            "content": "    return () => {"
          },
          {
            "lineNum": 46,
            "content": "      if (audioRef.current) {"
          },
          {
            "lineNum": 47,
            "content": "        audioRef.current.pause();"
          },
          {
            "lineNum": 48,
            "content": "        if (handlersRef.current) {"
          },
          {
            "lineNum": 49,
            "content": "          audioRef.current.removeEventListener('play', handlersRef.current.handlePlay);"
          },
          {
            "lineNum": 50,
            "content": "          audioRef.current.removeEventListener('pause', handlersRef.current.handlePause);"
          },
          {
            "lineNum": 51,
            "content": "          audioRef.current.removeEventListener('ended', handlersRef.current.handleEnded);"
          },
          {
            "lineNum": 52,
            "content": "        }"
          },
          {
            "lineNum": 53,
            "content": "        audioRef.current = null;"
          },
          {
            "lineNum": 54,
            "content": "      }"
          },
          {
            "lineNum": 55,
            "content": "      handlersRef.current = null;"
          }
        ]
      },
      {
        "functionName": "BlogFilters (filter callback)",
        "file": "src/sections/BlogFilters/index.tsx",
        "line": 42,
        "actualComplexity": 5,
        "calculatedTotal": 2,
        "difference": -3,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 43,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 42,
          "end": 43
        },
        "functionCode": [
          {
            "lineNum": 42,
            "content": "        (post) =>"
          },
          {
            "lineNum": 43,
            "content": "          post.title.toLowerCase().includes(query) ||"
          }
        ]
      },
      {
        "functionName": "isQuestionMarkInRegularString",
        "file": "scripts/decision-points.js",
        "line": 1615,
        "actualComplexity": 9,
        "calculatedTotal": 7,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for",
            "line": 1623,
            "name": "for loop"
          },
          {
            "type": "&&",
            "line": 1623,
            "name": "logical AND"
          },
          {
            "type": "ternary",
            "line": 1625,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 1630,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1636,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1647,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1615,
          "end": 1665
        },
        "functionCode": [
          {
            "lineNum": 1615,
            "content": "  const isQuestionMarkInRegularString = (line, questionIndex) => {"
          },
          {
            "lineNum": 1616,
            "content": "    let inSingleQuote = false;"
          },
          {
            "lineNum": 1617,
            "content": "    let inDoubleQuote = false;"
          },
          {
            "lineNum": 1618,
            "content": "    let inTemplateLiteral = false;"
          },
          {
            "lineNum": 1619,
            "content": "    let inTemplateExpression = false;"
          },
          {
            "lineNum": 1620,
            "content": "    let templateBraceDepth = 0;"
          },
          {
            "lineNum": 1621,
            "content": "    let escapeNext = false;"
          },
          {
            "lineNum": 1622,
            "content": "    "
          },
          {
            "lineNum": 1623,
            "content": "    for (let k = 0; k < questionIndex && k < line.length; k++) {"
          },
          {
            "lineNum": 1624,
            "content": "      const char = line[k];"
          },
          {
            "lineNum": 1625,
            "content": "      const nextChar = k + 1 < line.length ? line[k + 1] : '';"
          },
          {
            "lineNum": 1626,
            "content": "      "
          },
          {
            "lineNum": 1627,
            "content": "      // Handle escape sequences"
          },
          {
            "lineNum": 1628,
            "content": "      const escapeResult = handleEscapeSequence(char, escapeNext);"
          },
          {
            "lineNum": 1629,
            "content": "      escapeNext = escapeResult.escapeNext;"
          },
          {
            "lineNum": 1630,
            "content": "      if (escapeResult.shouldContinue) {"
          },
          {
            "lineNum": 1631,
            "content": "        continue;"
          },
          {
            "lineNum": 1632,
            "content": "      }"
          },
          {
            "lineNum": 1633,
            "content": "      "
          },
          {
            "lineNum": 1634,
            "content": "      // Handle template literal expression start"
          },
          {
            "lineNum": 1635,
            "content": "      const templateStart = handleTemplateExpressionStart(char, nextChar, inTemplateLiteral, inTemplateExpression);"
          },
          {
            "lineNum": 1636,
            "content": "      if (templateStart.shouldSkipNext) {"
          },
          {
            "lineNum": 1637,
            "content": "        inTemplateExpression = templateStart.inTemplateExpression;"
          },
          {
            "lineNum": 1638,
            "content": "        templateBraceDepth = templateStart.templateBraceDepth;"
          },
          {
            "lineNum": 1639,
            "content": "        k++; // Skip the '{'"
          },
          {
            "lineNum": 1640,
            "content": "        continue;"
          },
          {
            "lineNum": 1641,
            "content": "      }"
          },
          {
            "lineNum": 1642,
            "content": "      "
          },
          {
            "lineNum": 1643,
            "content": "      // Track brace depth in template expressions"
          },
          {
            "lineNum": 1644,
            "content": "      const braceResult = trackTemplateExpressionBraces(char, inTemplateExpression, templateBraceDepth);"
          },
          {
            "lineNum": 1645,
            "content": "      inTemplateExpression = braceResult.inTemplateExpression;"
          },
          {
            "lineNum": 1646,
            "content": "      templateBraceDepth = braceResult.templateBraceDepth;"
          },
          {
            "lineNum": 1647,
            "content": "      if (inTemplateExpression) {"
          },
          {
            "lineNum": 1648,
            "content": "        continue; // Don't process quotes/backticks inside template expressions"
          },
          {
            "lineNum": 1649,
            "content": "      }"
          },
          {
            "lineNum": 1650,
            "content": "      "
          },
          {
            "lineNum": 1651,
            "content": "      // Update quote states"
          },
          {
            "lineNum": 1652,
            "content": "      const quoteResult = updateQuoteStates(char, inSingleQuote, inDoubleQuote, inTemplateLiteral);"
          },
          {
            "lineNum": 1653,
            "content": "      inSingleQuote = quoteResult.inSingleQuote;"
          },
          {
            "lineNum": 1654,
            "content": "      inDoubleQuote = quoteResult.inDoubleQuote;"
          },
          {
            "lineNum": 1655,
            "content": "      inTemplateLiteral = quoteResult.inTemplateLiteral;"
          },
          {
            "lineNum": 1656,
            "content": "      "
          },
          {
            "lineNum": 1657,
            "content": "      // Reset template expression when template literal ends"
          },
          {
            "lineNum": 1658,
            "content": "      if (!inTemplateLiteral) {"
          },
          {
            "lineNum": 1659,
            "content": "        inTemplateExpression = false;"
          },
          {
            "lineNum": 1660,
            "content": "        templateBraceDepth = 0;"
          },
          {
            "lineNum": 1661,
            "content": "      }"
          },
          {
            "lineNum": 1662,
            "content": "    }"
          },
          {
            "lineNum": 1663,
            "content": "    "
          },
          {
            "lineNum": 1664,
            "content": "    return inSingleQuote || inDoubleQuote;"
          }
        ]
      },
      {
        "functionName": "getFunctionLineForControlStructure",
        "file": "scripts/decision-points.js",
        "line": 3535,
        "actualComplexity": 8,
        "calculatedTotal": 6,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 3536,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3546,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3558,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3564,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3570,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 5,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3535,
          "end": 3600
        },
        "functionCode": [
          {
            "lineNum": 3535,
            "content": "  const getFunctionLineForControlStructure = (isControlStructure, lineNum, containingFunctions, functionBoundaries, getInnermostFunction) => {"
          },
          {
            "lineNum": 3536,
            "content": "    if (!isControlStructure) {"
          },
          {
            "lineNum": 3537,
            "content": "      return getInnermostFunction(lineNum);"
          },
          {
            "lineNum": 3538,
            "content": "    }"
          },
          {
            "lineNum": 3539,
            "content": "    "
          },
          {
            "lineNum": 3540,
            "content": "    // For control structures, find the immediate parent function (not nested callbacks, not outermost function)"
          },
          {
            "lineNum": 3541,
            "content": "    // Filter to functions that actually contain this line"
          },
          {
            "lineNum": 3542,
            "content": "    const validFunctions = containingFunctions.filter(f => "
          },
          {
            "lineNum": 3543,
            "content": "      f.boundary.start <= lineNum && lineNum <= f.boundary.end"
          },
          {
            "lineNum": 3544,
            "content": "    );"
          },
          {
            "lineNum": 3545,
            "content": "    "
          },
          {
            "lineNum": 3546,
            "content": "    if (validFunctions.length === 0) {"
          },
          {
            "lineNum": 3547,
            "content": "      return getInnermostFunction(lineNum);"
          },
          {
            "lineNum": 3548,
            "content": "    }"
          },
          {
            "lineNum": 3549,
            "content": "    "
          },
          {
            "lineNum": 3550,
            "content": "    // Sort by start line (earliest first)"
          },
          {
            "lineNum": 3551,
            "content": "    const sortedFunctions = [...validFunctions].sort((a, b) => a.boundary.start - b.boundary.start);"
          },
          {
            "lineNum": 3552,
            "content": "    "
          },
          {
            "lineNum": 3553,
            "content": "    // Find nested functions starting on this line (callbacks)"
          },
          {
            "lineNum": 3554,
            "content": "    const nestedFunctionsOnThisLine = sortedFunctions.filter(f => "
          },
          {
            "lineNum": 3555,
            "content": "      f.boundary.start === lineNum && f.boundary.start > sortedFunctions[0].boundary.start"
          },
          {
            "lineNum": 3556,
            "content": "    );"
          },
          {
            "lineNum": 3557,
            "content": "    "
          },
          {
            "lineNum": 3558,
            "content": "    if (nestedFunctionsOnThisLine.length > 0) {"
          },
          {
            "lineNum": 3559,
            "content": "      // There are nested callbacks on this line - find the immediate parent (not the outermost)"
          },
          {
            "lineNum": 3560,
            "content": "      const nonNestedFunctions = sortedFunctions.filter(f => "
          },
          {
            "lineNum": 3561,
            "content": "        !nestedFunctionsOnThisLine.some(nested => nested.functionLine === f.functionLine)"
          },
          {
            "lineNum": 3562,
            "content": "      );"
          },
          {
            "lineNum": 3563,
            "content": "      "
          },
          {
            "lineNum": 3564,
            "content": "      if (nonNestedFunctions.length > 0) {"
          },
          {
            "lineNum": 3565,
            "content": "        // Find the function that starts most recently before this line (immediate parent)"
          },
          {
            "lineNum": 3566,
            "content": "        const immediateParent = nonNestedFunctions"
          },
          {
            "lineNum": 3567,
            "content": "          .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
          },
          {
            "lineNum": 3568,
            "content": "          .sort((a, b) => b.boundary.start - a.boundary.start)[0]; // Most recent start"
          },
          {
            "lineNum": 3569,
            "content": "        "
          },
          {
            "lineNum": 3570,
            "content": "        if (immediateParent) {"
          },
          {
            "lineNum": 3571,
            "content": "          return immediateParent.functionLine;"
          },
          {
            "lineNum": 3572,
            "content": "        }"
          },
          {
            "lineNum": 3573,
            "content": "        // Fallback: use the first non-nested function"
          },
          {
            "lineNum": 3574,
            "content": "        return nonNestedFunctions[0].functionLine;"
          },
          {
            "lineNum": 3575,
            "content": "      }"
          },
          {
            "lineNum": 3576,
            "content": "      // Fallback: use normal innermost function logic"
          },
          {
            "lineNum": 3577,
            "content": "      return getInnermostFunction(lineNum);"
          },
          {
            "lineNum": 3578,
            "content": "    }"
          },
          {
            "lineNum": 3579,
            "content": "    "
          },
          {
            "lineNum": 3580,
            "content": "    // No nested callbacks on this line - but check if we're after nested callbacks have ended"
          },
          {
            "lineNum": 3581,
            "content": "    const allContainingFunctions = Array.from(functionBoundaries.entries())"
          },
          {
            "lineNum": 3582,
            "content": "      .filter(([fl, b]) => b.start <= lineNum && lineNum <= b.end);"
          },
          {
            "lineNum": 3583,
            "content": "    "
          },
          {
            "lineNum": 3584,
            "content": "    if (allContainingFunctions.length > 1) {"
          }
        ]
      },
      {
        "functionName": "findAllTernaryOperators",
        "file": "scripts/decision-points.js",
        "line": 2330,
        "actualComplexity": 5,
        "calculatedTotal": 3,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "while",
            "line": 2334,
            "name": "while loop"
          },
          {
            "type": "if",
            "line": 2337,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 1,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2330,
          "end": 2372
        },
        "functionCode": [
          {
            "lineNum": 2330,
            "content": "  const findAllTernaryOperators = (lineWithoutComments, index, lines, isInsideStringLiteral) => {"
          },
          {
            "lineNum": 2331,
            "content": "    const ternaryMatches = [];"
          },
          {
            "lineNum": 2332,
            "content": "    let ternarySearchIndex = 0;"
          },
          {
            "lineNum": 2333,
            "content": "    "
          },
          {
            "lineNum": 2334,
            "content": "    while ((ternarySearchIndex = lineWithoutComments.indexOf('?', ternarySearchIndex)) !== -1) {"
          },
          {
            "lineNum": 2335,
            "content": "      // Check if we should skip this question mark (optional chaining, regex, etc.)"
          },
          {
            "lineNum": 2336,
            "content": "      const skipCount = shouldSkipQuestionMark(lineWithoutComments, ternarySearchIndex);"
          },
          {
            "lineNum": 2337,
            "content": "      if (skipCount > 0) {"
          },
          {
            "lineNum": 2338,
            "content": "        ternarySearchIndex += skipCount;"
          },
          {
            "lineNum": 2339,
            "content": "        continue;"
          },
          {
            "lineNum": 2340,
            "content": "      }"
          },
          {
            "lineNum": 2341,
            "content": "      "
          },
          {
            "lineNum": 2342,
            "content": "      // IMPORTANT: Check if this question mark is inside a string literal"
          },
          {
            "lineNum": 2343,
            "content": "      // If it is, skip it entirely (don't count it as a ternary operator)"
          },
          {
            "lineNum": 2344,
            "content": "      if (isInsideStringLiteral(lineWithoutComments, ternarySearchIndex)) {"
          },
          {
            "lineNum": 2345,
            "content": "        ternarySearchIndex++;"
          },
          {
            "lineNum": 2346,
            "content": "        continue;"
          },
          {
            "lineNum": 2347,
            "content": "      }"
          },
          {
            "lineNum": 2348,
            "content": "      "
          },
          {
            "lineNum": 2349,
            "content": "      // Calculate nesting depths up to this question mark"
          },
          {
            "lineNum": 2350,
            "content": "      const startDepths = calculateNestingDepths(lineWithoutComments, ternarySearchIndex);"
          },
          {
            "lineNum": 2351,
            "content": "      const jsxTernary = isJSXTernary(lineWithoutComments, ternarySearchIndex);"
          },
          {
            "lineNum": 2352,
            "content": "      "
          },
          {
            "lineNum": 2353,
            "content": "      // Find matching colon"
          },
          {
            "lineNum": 2354,
            "content": "      const foundColon = findMatchingColonForTernary("
          },
          {
            "lineNum": 2355,
            "content": "        lineWithoutComments,"
          },
          {
            "lineNum": 2356,
            "content": "        ternarySearchIndex,"
          },
          {
            "lineNum": 2357,
            "content": "        index,"
          },
          {
            "lineNum": 2358,
            "content": "        lines,"
          },
          {
            "lineNum": 2359,
            "content": "        startDepths,"
          },
          {
            "lineNum": 2360,
            "content": "        jsxTernary,"
          },
          {
            "lineNum": 2361,
            "content": "        isInsideStringLiteral"
          },
          {
            "lineNum": 2362,
            "content": "      );"
          },
          {
            "lineNum": 2363,
            "content": "      "
          },
          {
            "lineNum": 2364,
            "content": "      if (foundColon) {"
          },
          {
            "lineNum": 2365,
            "content": "        ternaryMatches.push({ index: ternarySearchIndex });"
          },
          {
            "lineNum": 2366,
            "content": "      }"
          },
          {
            "lineNum": 2367,
            "content": "      "
          },
          {
            "lineNum": 2368,
            "content": "      ternarySearchIndex++;"
          },
          {
            "lineNum": 2369,
            "content": "    }"
          },
          {
            "lineNum": 2370,
            "content": "    "
          },
          {
            "lineNum": 2371,
            "content": "    return ternaryMatches;"
          },
          {
            "lineNum": 2372,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "calculateFileStatistics",
        "file": "scripts/html-generators.js",
        "line": 1096,
        "actualComplexity": 7,
        "calculatedTotal": 5,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1101,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1102,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1102,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1102,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 4,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1096,
          "end": 1105
        },
        "functionCode": [
          {
            "lineNum": 1096,
            "content": "function calculateFileStatistics(functions) {"
          },
          {
            "lineNum": 1097,
            "content": "  const totalFunctions = functions.length;"
          },
          {
            "lineNum": 1098,
            "content": "  const withinThreshold = functions.filter(f => parseInt(f.complexity) <= 10).length;"
          },
          {
            "lineNum": 1099,
            "content": "  const maxComplexity = functions.length > 0 ? Math.max(...functions.map(f => parseInt(f.complexity))) : 0;"
          },
          {
            "lineNum": 1100,
            "content": "  const avgComplexity = functions.length > 0 ? Math.round(functions.reduce((sum, f) => sum + parseInt(f.complexity), 0) / functions.length) : 0;"
          },
          {
            "lineNum": 1101,
            "content": "  const percentage = totalFunctions > 0 ? Math.round((withinThreshold / totalFunctions) * 100) : 100;"
          },
          {
            "lineNum": 1102,
            "content": "  const level = percentage >= 80 ? 'high' : percentage >= 60 ? 'high' : percentage >= 40 ? 'medium' : 'low';"
          },
          {
            "lineNum": 1103,
            "content": "  "
          },
          {
            "lineNum": 1104,
            "content": "  return { totalFunctions, withinThreshold, maxComplexity, avgComplexity, percentage, level };"
          },
          {
            "lineNum": 1105,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "addEventListener callback",
        "file": "src/main.tsx",
        "line": 12,
        "actualComplexity": 9,
        "calculatedTotal": 7,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 13,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 13,
            "name": "logical OR"
          },
          {
            "type": "&&",
            "line": 15,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 16,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 17,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 21,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 4,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 12,
          "end": 31
        },
        "functionCode": [
          {
            "lineNum": 12,
            "content": "  window.addEventListener('error', (event) => {"
          },
          {
            "lineNum": 13,
            "content": "    const error = event.error || event.message || '';"
          },
          {
            "lineNum": 14,
            "content": "    const isChunkLoadError = "
          },
          {
            "lineNum": 15,
            "content": "      typeof error === 'string' && ("
          },
          {
            "lineNum": 16,
            "content": "        error.includes('Failed to fetch dynamically imported module') ||"
          },
          {
            "lineNum": 17,
            "content": "        error.includes('Loading chunk') ||"
          },
          {
            "lineNum": 18,
            "content": "        error.includes('Loading CSS chunk')"
          },
          {
            "lineNum": 19,
            "content": "      );"
          },
          {
            "lineNum": 20,
            "content": "    "
          },
          {
            "lineNum": 21,
            "content": "    if (isChunkLoadError) {"
          },
          {
            "lineNum": 22,
            "content": "      // Only reload if we haven't already tried recently (prevent infinite loops)"
          },
          {
            "lineNum": 23,
            "content": "      const lastReload = sessionStorage.getItem('chunkReloadAttempt');"
          },
          {
            "lineNum": 24,
            "content": "      const now = Date.now();"
          },
          {
            "lineNum": 25,
            "content": "      "
          },
          {
            "lineNum": 26,
            "content": "      if (!lastReload || (now - parseInt(lastReload)) > 10000) { // 10 second cooldown"
          },
          {
            "lineNum": 27,
            "content": "        sessionStorage.setItem('chunkReloadAttempt', now.toString());"
          },
          {
            "lineNum": 28,
            "content": "        window.location.reload();"
          },
          {
            "lineNum": 29,
            "content": "      }"
          },
          {
            "lineNum": 30,
            "content": "    }"
          },
          {
            "lineNum": 31,
            "content": "  });"
          }
        ]
      },
      {
        "functionName": "getGrayscaleImageUrl",
        "file": "src/utils/imageGrayscale.ts",
        "line": 11,
        "actualComplexity": 4,
        "calculatedTotal": 2,
        "difference": -2,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 12,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 11,
          "end": 28
        },
        "functionCode": [
          {
            "lineNum": 11,
            "content": "export function getGrayscaleImageUrl(imageUrl: string, isNoirTheme: boolean): string {"
          },
          {
            "lineNum": 12,
            "content": "  if (!isNoirTheme) {"
          },
          {
            "lineNum": 13,
            "content": "    return imageUrl;"
          },
          {
            "lineNum": 14,
            "content": "  }"
          },
          {
            "lineNum": 15,
            "content": ""
          },
          {
            "lineNum": 16,
            "content": "  // Check if it's a picsum.photos URL"
          },
          {
            "lineNum": 17,
            "content": "  if (imageUrl.includes('picsum.photos')) {"
          },
          {
            "lineNum": 18,
            "content": "    // Check if URL already has query parameters"
          },
          {
            "lineNum": 19,
            "content": "    const hasQuery = imageUrl.includes('?');"
          },
          {
            "lineNum": 20,
            "content": "    const separator = hasQuery ? '&' : '?';"
          },
          {
            "lineNum": 21,
            "content": "    "
          },
          {
            "lineNum": 22,
            "content": "    // Add grayscale parameter"
          },
          {
            "lineNum": 23,
            "content": "    return `${imageUrl}${separator}grayscale`;"
          },
          {
            "lineNum": 24,
            "content": "  }"
          },
          {
            "lineNum": 25,
            "content": ""
          },
          {
            "lineNum": 26,
            "content": "  // For non-picsum URLs, return as-is (will use CSS filter instead)"
          },
          {
            "lineNum": 27,
            "content": "  return imageUrl;"
          },
          {
            "lineNum": 28,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "processQuoteCharacters",
        "file": "scripts/decision-points.js",
        "line": 390,
        "actualComplexity": 11,
        "calculatedTotal": 10,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 391,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 391,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 391,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 399,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 399,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 399,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 407,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 407,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 407,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 6,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 390,
          "end": 436
        },
        "functionCode": [
          {
            "lineNum": 390,
            "content": "  const processQuoteCharacters = (char, inSingleQuote, inDoubleQuote, inTemplateLiteral, inTemplateExpression) => {"
          },
          {
            "lineNum": 391,
            "content": "    if (char === \"'\" && !inDoubleQuote && !inTemplateLiteral) {"
          },
          {
            "lineNum": 392,
            "content": "      return { "
          },
          {
            "lineNum": 393,
            "content": "        inSingleQuote: !inSingleQuote, "
          },
          {
            "lineNum": 394,
            "content": "        inDoubleQuote, "
          },
          {
            "lineNum": 395,
            "content": "        inTemplateLiteral,"
          },
          {
            "lineNum": 396,
            "content": "        resetTemplateExpression: false"
          },
          {
            "lineNum": 397,
            "content": "      };"
          },
          {
            "lineNum": 398,
            "content": "    }"
          },
          {
            "lineNum": 399,
            "content": "    if (char === '\"' && !inSingleQuote && !inTemplateLiteral) {"
          },
          {
            "lineNum": 400,
            "content": "      return { "
          },
          {
            "lineNum": 401,
            "content": "        inSingleQuote, "
          },
          {
            "lineNum": 402,
            "content": "        inDoubleQuote: !inDoubleQuote, "
          },
          {
            "lineNum": 403,
            "content": "        inTemplateLiteral,"
          },
          {
            "lineNum": 404,
            "content": "        resetTemplateExpression: false"
          },
          {
            "lineNum": 405,
            "content": "      };"
          },
          {
            "lineNum": 406,
            "content": "    }"
          },
          {
            "lineNum": 407,
            "content": "    if (char === '`' && !inSingleQuote && !inDoubleQuote) {"
          },
          {
            "lineNum": 408,
            "content": "      // IMPORTANT: When inside a template expression ${...}, backticks start nested template literals"
          },
          {
            "lineNum": 409,
            "content": "      // We should NOT toggle the outer template literal state in this case"
          },
          {
            "lineNum": 410,
            "content": "      // Only toggle if we're NOT inside a template expression"
          },
          {
            "lineNum": 411,
            "content": "      if (inTemplateExpression) {"
          },
          {
            "lineNum": 412,
            "content": "        // Inside ${...} - backtick starts a nested template literal, don't toggle outer state"
          },
          {
            "lineNum": 413,
            "content": "        return { "
          },
          {
            "lineNum": 414,
            "content": "          inSingleQuote, "
          },
          {
            "lineNum": 415,
            "content": "          inDoubleQuote, "
          },
          {
            "lineNum": 416,
            "content": "          inTemplateLiteral: inTemplateLiteral, // Keep outer template literal state unchanged"
          },
          {
            "lineNum": 417,
            "content": "          resetTemplateExpression: false"
          },
          {
            "lineNum": 418,
            "content": "        };"
          },
          {
            "lineNum": 419,
            "content": "      } else {"
          },
          {
            "lineNum": 420,
            "content": "        // Not inside ${...} - toggle template literal state normally"
          },
          {
            "lineNum": 421,
            "content": "        const newTemplateLiteral = !inTemplateLiteral;"
          },
          {
            "lineNum": 422,
            "content": "        return { "
          },
          {
            "lineNum": 423,
            "content": "          inSingleQuote, "
          },
          {
            "lineNum": 424,
            "content": "          inDoubleQuote, "
          },
          {
            "lineNum": 425,
            "content": "          inTemplateLiteral: newTemplateLiteral,"
          },
          {
            "lineNum": 426,
            "content": "          resetTemplateExpression: !newTemplateLiteral"
          },
          {
            "lineNum": 427,
            "content": "        };"
          },
          {
            "lineNum": 428,
            "content": "      }"
          },
          {
            "lineNum": 429,
            "content": "    }"
          },
          {
            "lineNum": 430,
            "content": "    return { "
          },
          {
            "lineNum": 431,
            "content": "      inSingleQuote, "
          },
          {
            "lineNum": 432,
            "content": "      inDoubleQuote, "
          },
          {
            "lineNum": 433,
            "content": "      inTemplateLiteral,"
          },
          {
            "lineNum": 434,
            "content": "      resetTemplateExpression: false"
          },
          {
            "lineNum": 435,
            "content": "    };"
          },
          {
            "lineNum": 436,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "isInDestructuredAssignment",
        "file": "scripts/decision-points.js",
        "line": 3110,
        "actualComplexity": 9,
        "calculatedTotal": 8,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 3112,
            "name": "if statement"
          },
          {
            "type": "for",
            "line": 3117,
            "name": "for loop"
          },
          {
            "type": "&&",
            "line": 3117,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3121,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3126,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 3126,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3131,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 4,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 2,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3110,
          "end": 3143
        },
        "functionCode": [
          {
            "lineNum": 3110,
            "content": "  const isInDestructuredAssignment = (lineWithoutComments, index, lineNum, lines, boundary) => {"
          },
          {
            "lineNum": 3111,
            "content": "    // Check if current line starts destructuring"
          },
          {
            "lineNum": 3112,
            "content": "    if (/^\\s*(const|let|var)\\s+\\{/.test(lineWithoutComments)) {"
          },
          {
            "lineNum": 3113,
            "content": "      return true;"
          },
          {
            "lineNum": 3114,
            "content": "    }"
          },
          {
            "lineNum": 3115,
            "content": "    "
          },
          {
            "lineNum": 3116,
            "content": "    // Look backwards up to 10 lines to find destructuring start"
          },
          {
            "lineNum": 3117,
            "content": "    for (let lookBack = 1; lookBack <= 10 && index - lookBack >= 0; lookBack++) {"
          },
          {
            "lineNum": 3118,
            "content": "      const prevLine = lines[index - lookBack].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
          },
          {
            "lineNum": 3119,
            "content": "      "
          },
          {
            "lineNum": 3120,
            "content": "      // Check if previous line starts destructuring"
          },
          {
            "lineNum": 3121,
            "content": "      if (/^\\s*(const|let|var)\\s+\\{/.test(prevLine)) {"
          },
          {
            "lineNum": 3122,
            "content": "        return true;"
          },
          {
            "lineNum": 3123,
            "content": "      }"
          },
          {
            "lineNum": 3124,
            "content": "      "
          },
          {
            "lineNum": 3125,
            "content": "      // Stop if we hit a closing brace followed by = (end of destructuring: } = obj)"
          },
          {
            "lineNum": 3126,
            "content": "      if (prevLine.includes('}') && prevLine.includes('=')) {"
          },
          {
            "lineNum": 3127,
            "content": "        break;"
          },
          {
            "lineNum": 3128,
            "content": "      }"
          },
          {
            "lineNum": 3129,
            "content": "      "
          },
          {
            "lineNum": 3130,
            "content": "      // Stop if we hit a semicolon (end of statement)"
          },
          {
            "lineNum": 3131,
            "content": "      if (prevLine.endsWith(';')) {"
          },
          {
            "lineNum": 3132,
            "content": "        break;"
          },
          {
            "lineNum": 3133,
            "content": "      }"
          },
          {
            "lineNum": 3134,
            "content": "      "
          },
          {
            "lineNum": 3135,
            "content": "      // Stop if we're past the function start"
          },
          {
            "lineNum": 3136,
            "content": "      const prevLineNum = lineNum - lookBack;"
          },
          {
            "lineNum": 3137,
            "content": "      if (prevLineNum < boundary.start) {"
          },
          {
            "lineNum": 3138,
            "content": "        break;"
          },
          {
            "lineNum": 3139,
            "content": "      }"
          },
          {
            "lineNum": 3140,
            "content": "    }"
          },
          {
            "lineNum": 3141,
            "content": "    "
          },
          {
            "lineNum": 3142,
            "content": "    return false;"
          },
          {
            "lineNum": 3143,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "detectMultiLineTernaries",
        "file": "scripts/decision-points.js",
        "line": 2151,
        "actualComplexity": 8,
        "calculatedTotal": 7,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 2155,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 2162,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 2164,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 2164,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 2165,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 2165,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 4,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2151,
          "end": 2174
        },
        "functionCode": [
          {
            "lineNum": 2151,
            "content": "  const detectMultiLineTernaries = (lineWithoutComments, index, lines, hasQuestionMarkOutsideString) => {"
          },
          {
            "lineNum": 2152,
            "content": "    const hasQuestionMark = hasQuestionMarkOutsideString(lineWithoutComments);"
          },
          {
            "lineNum": 2153,
            "content": "    const hasColon = lineWithoutComments.includes(':');"
          },
          {
            "lineNum": 2154,
            "content": "    "
          },
          {
            "lineNum": 2155,
            "content": "    const nextLine = index + 1 < lines.length ? lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
          },
          {
            "lineNum": 2156,
            "content": "    const nextLineHasColon = nextLine.includes(':');"
          },
          {
            "lineNum": 2157,
            "content": "    const nextLineHasQuestionMark = hasQuestionMarkOutsideString(nextLine);"
          },
          {
            "lineNum": 2158,
            "content": "    "
          },
          {
            "lineNum": 2159,
            "content": "    const prevLine = index > 0 ? lines[index - 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
          },
          {
            "lineNum": 2160,
            "content": "    const prevLineHasQuestionMark = hasQuestionMarkOutsideString(prevLine);"
          },
          {
            "lineNum": 2161,
            "content": "    "
          },
          {
            "lineNum": 2162,
            "content": "    const isMultiLineTernaryWithQuestionOnThisLine = hasQuestionMark && nextLineHasColon;"
          },
          {
            "lineNum": 2163,
            "content": "    // Check if this line is a ternary condition line (has &&/|| but ? is on previous OR next line)"
          },
          {
            "lineNum": 2164,
            "content": "    const isMultiLineTernaryConditionLine = !hasQuestionMark && !hasColon && "
          },
          {
            "lineNum": 2165,
            "content": "                                            (prevLineHasQuestionMark || nextLineHasQuestionMark) && "
          },
          {
            "lineNum": 2166,
            "content": "                                            /[&|]{2}/.test(lineWithoutComments);"
          },
          {
            "lineNum": 2167,
            "content": "    "
          },
          {
            "lineNum": 2168,
            "content": "    return {"
          },
          {
            "lineNum": 2169,
            "content": "      isMultiLineTernaryWithQuestionOnThisLine,"
          },
          {
            "lineNum": 2170,
            "content": "      isMultiLineTernaryConditionLine,"
          },
          {
            "lineNum": 2171,
            "content": "      hasQuestionMark,"
          },
          {
            "lineNum": 2172,
            "content": "      prevLine"
          },
          {
            "lineNum": 2173,
            "content": "    };"
          },
          {
            "lineNum": 2174,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "parseMultiLineConditions",
        "file": "scripts/decision-points.js",
        "line": 3069,
        "actualComplexity": 7,
        "calculatedTotal": 6,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 3096,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 3096,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3096,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3096,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3096,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 4,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3069,
          "end": 3099
        },
        "functionCode": [
          {
            "lineNum": 3069,
            "content": "  const parseMultiLineConditions = (lineWithoutComments, lineNum, index, lines, functionLine, isIfStatement, isElseIfStatement, isForLoop, isWhileLoop, isJSXExpression, isContinuationOfJSXExpression, isBooleanAssignment, isBooleanExpression, decisionPoints) => {"
          },
          {
            "lineNum": 3070,
            "content": "    // EXCLUDE JSX expressions and boolean expressions - they're already handled above"
          },
          {
            "lineNum": 3071,
            "content": "    if (shouldExcludeFromMultiLineConditions(index, isIfStatement, isElseIfStatement, isJSXExpression, isContinuationOfJSXExpression, isBooleanAssignment, isBooleanExpression)) {"
          },
          {
            "lineNum": 3072,
            "content": "      return;"
          },
          {
            "lineNum": 3073,
            "content": "    }"
          },
          {
            "lineNum": 3074,
            "content": "    "
          },
          {
            "lineNum": 3075,
            "content": "    const prevLine = lines[index - 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
          },
          {
            "lineNum": 3076,
            "content": "    const prevLineHasLogicalOp = /[&|]{2}/.test(prevLine);"
          },
          {
            "lineNum": 3077,
            "content": "    const currentLineHasLogicalOp = /[&|]{2}/.test(lineWithoutComments);"
          },
          {
            "lineNum": 3078,
            "content": "    const prevLineIsCondition = isConditionStart(prevLine);"
          },
          {
            "lineNum": 3079,
            "content": "    const prevLineIsBooleanAssignment = isBooleanAssignmentLine(prevLine);"
          },
          {
            "lineNum": 3080,
            "content": "    const prevLineIsBooleanExpression = isBooleanExpressionLine(prevLine);"
          },
          {
            "lineNum": 3081,
            "content": "    "
          },
          {
            "lineNum": 3082,
            "content": "    // Check if we're continuing a multi-line condition"
          },
          {
            "lineNum": 3083,
            "content": "    const isContinuingCondition = isContinuingMultiLineCondition(index, lines, currentLineHasLogicalOp);"
          },
          {
            "lineNum": 3084,
            "content": "    "
          },
          {
            "lineNum": 3085,
            "content": "    // Determine if we should process"
          },
          {
            "lineNum": 3086,
            "content": "    const shouldProcess = shouldProcessMultiLineCondition("
          },
          {
            "lineNum": 3087,
            "content": "      isBooleanAssignment,"
          },
          {
            "lineNum": 3088,
            "content": "      isBooleanExpression,"
          },
          {
            "lineNum": 3089,
            "content": "      prevLineIsCondition,"
          },
          {
            "lineNum": 3090,
            "content": "      currentLineHasLogicalOp,"
          },
          {
            "lineNum": 3091,
            "content": "      prevLineIsBooleanAssignment,"
          },
          {
            "lineNum": 3092,
            "content": "      prevLineIsBooleanExpression,"
          },
          {
            "lineNum": 3093,
            "content": "      isContinuingCondition"
          },
          {
            "lineNum": 3094,
            "content": "    );"
          },
          {
            "lineNum": 3095,
            "content": "    "
          },
          {
            "lineNum": 3096,
            "content": "    if (shouldProcess && !isIfStatement && !isElseIfStatement && !isForLoop && !isWhileLoop) {"
          },
          {
            "lineNum": 3097,
            "content": "      processMultiLineConditionOperators(lineWithoutComments, lineNum, functionLine, decisionPoints);"
          },
          {
            "lineNum": 3098,
            "content": "    }"
          },
          {
            "lineNum": 3099,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "findBooleanExpressionFunctionLine",
        "file": "scripts/decision-points.js",
        "line": 2580,
        "actualComplexity": 6,
        "calculatedTotal": 5,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 2584,
            "name": "if statement"
          },
          {
            "type": "ternary",
            "line": 2592,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 2591,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 2596,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2580,
          "end": 2616
        },
        "functionCode": [
          {
            "lineNum": 2580,
            "content": "  const findBooleanExpressionFunctionLine = (lineWithoutComments, lineNum, operatorIndex, functionLine, functionBoundaries) => {"
          },
          {
            "lineNum": 2581,
            "content": "    const callbacksOnThisLine = Array.from(functionBoundaries.entries())"
          },
          {
            "lineNum": 2582,
            "content": "      .filter(([fl, b]) => b.start === lineNum);"
          },
          {
            "lineNum": 2583,
            "content": "    "
          },
          {
            "lineNum": 2584,
            "content": "    if (callbacksOnThisLine.length === 0) {"
          },
          {
            "lineNum": 2585,
            "content": "      return functionLine;"
          },
          {
            "lineNum": 2586,
            "content": "    }"
          },
          {
            "lineNum": 2587,
            "content": "    "
          },
          {
            "lineNum": 2588,
            "content": "    // Find where callbacks start (look for => or function keyword)"
          },
          {
            "lineNum": 2589,
            "content": "    const callbackStartPattern = /(?:=>|function\\s*\\()/;"
          },
          {
            "lineNum": 2590,
            "content": "    const callbackStartMatch = lineWithoutComments.match(callbackStartPattern);"
          },
          {
            "lineNum": 2591,
            "content": "    const callbackStartIndex = callbackStartMatch && callbackStartMatch.index !== undefined "
          },
          {
            "lineNum": 2592,
            "content": "      ? callbackStartMatch.index "
          },
          {
            "lineNum": 2593,
            "content": "      : -1;"
          },
          {
            "lineNum": 2594,
            "content": "    "
          },
          {
            "lineNum": 2595,
            "content": "    // If operator appears before any callback starts, it belongs to the parent function"
          },
          {
            "lineNum": 2596,
            "content": "    if (callbackStartIndex > operatorIndex) {"
          },
          {
            "lineNum": 2597,
            "content": "      // Find parent function (function that contains this line but isn't a callback on this line)"
          },
          {
            "lineNum": 2598,
            "content": "      const parentFunctions = Array.from(functionBoundaries.entries())"
          },
          {
            "lineNum": 2599,
            "content": "        .filter(([fl, b]) => "
          },
          {
            "lineNum": 2600,
            "content": "          b.start <= lineNum && lineNum <= b.end && "
          },
          {
            "lineNum": 2601,
            "content": "          !callbacksOnThisLine.some(([cfl]) => cfl === fl)"
          },
          {
            "lineNum": 2602,
            "content": "        );"
          },
          {
            "lineNum": 2603,
            "content": "      "
          },
          {
            "lineNum": 2604,
            "content": "      if (parentFunctions.length > 0) {"
          },
          {
            "lineNum": 2605,
            "content": "        // Use the most recent parent (smallest boundary that's larger than callbacks)"
          },
          {
            "lineNum": 2606,
            "content": "        const sortedParents = parentFunctions.sort((a, b) => {"
          },
          {
            "lineNum": 2607,
            "content": "          const aSize = a[1].end - a[1].start;"
          },
          {
            "lineNum": 2608,
            "content": "          const bSize = b[1].end - b[1].start;"
          },
          {
            "lineNum": 2609,
            "content": "          return aSize - bSize; // Prefer smaller boundary (more nested parent)"
          },
          {
            "lineNum": 2610,
            "content": "        });"
          },
          {
            "lineNum": 2611,
            "content": "        return sortedParents[0][0];"
          },
          {
            "lineNum": 2612,
            "content": "      }"
          },
          {
            "lineNum": 2613,
            "content": "    }"
          },
          {
            "lineNum": 2614,
            "content": "    "
          },
          {
            "lineNum": 2615,
            "content": "    return functionLine;"
          },
          {
            "lineNum": 2616,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "detectMultiLineArrowParameter",
        "file": "scripts/decision-points.js",
        "line": 735,
        "actualComplexity": 5,
        "calculatedTotal": 4,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 741,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 741,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 741,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 3,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 735,
          "end": 742
        },
        "functionCode": [
          {
            "lineNum": 735,
            "content": "  const detectMultiLineArrowParameter = (lineWithoutComments, index, lines) => {"
          },
          {
            "lineNum": 736,
            "content": "    // Check for default parameters including booleans, numbers, strings, etc."
          },
          {
            "lineNum": 737,
            "content": "    const hasDefaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/.test(lineWithoutComments);"
          },
          {
            "lineNum": 738,
            "content": "    const hasOpeningParen = lineWithoutComments.includes('(');"
          },
          {
            "lineNum": 739,
            "content": "    const hasArrowOnLaterLine = index + 1 < lines.length && "
          },
          {
            "lineNum": 740,
            "content": "                                lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').includes('=>');"
          },
          {
            "lineNum": 741,
            "content": "    return hasDefaultParamPattern && hasOpeningParen && hasArrowOnLaterLine && !lineWithoutComments.includes('=>');"
          },
          {
            "lineNum": 742,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "analyzeMismatches",
        "file": "scripts/analyze-mismatches.js",
        "line": 29,
        "actualComplexity": 3,
        "calculatedTotal": 2,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "for...of",
            "line": 52,
            "name": "for...of loop"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 1,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 29,
          "end": 285
        },
        "functionCode": [
          {
            "lineNum": 29,
            "content": "async function analyzeMismatches() {"
          },
          {
            "lineNum": 30,
            "content": "  console.log(' Analyzing complexity mismatches...\\n');"
          },
          {
            "lineNum": 31,
            "content": ""
          },
          {
            "lineNum": 32,
            "content": "  // Run ESLint to collect complexity data"
          },
          {
            "lineNum": 33,
            "content": "  const eslintResults = runESLintComplexityCheck(projectRoot);"
          },
          {
            "lineNum": 34,
            "content": ""
          },
          {
            "lineNum": 35,
            "content": "  // Extract complexity for ALL functions"
          },
          {
            "lineNum": 36,
            "content": "  const allFunctions = extractFunctionsFromESLintResults(eslintResults, projectRoot, extractFunctionName);"
          },
          {
            "lineNum": 37,
            "content": ""
          },
          {
            "lineNum": 38,
            "content": "  // Group functions by file to process source code"
          },
          {
            "lineNum": 39,
            "content": "  const fileMap = new Map();"
          },
          {
            "lineNum": 40,
            "content": "  allFunctions.forEach(func => {"
          },
          {
            "lineNum": 41,
            "content": "    if (!fileMap.has(func.file)) {"
          },
          {
            "lineNum": 42,
            "content": "      fileMap.set(func.file, []);"
          },
          {
            "lineNum": 43,
            "content": "    }"
          },
          {
            "lineNum": 44,
            "content": "    fileMap.get(func.file).push(func);"
          },
          {
            "lineNum": 45,
            "content": "  });"
          },
          {
            "lineNum": 46,
            "content": ""
          },
          {
            "lineNum": 47,
            "content": "  // Process each file"
          },
          {
            "lineNum": 48,
            "content": "  const mismatches = [];"
          },
          {
            "lineNum": 49,
            "content": "  const allDecisionPoints = [];"
          },
          {
            "lineNum": 50,
            "content": "  const allFunctionBoundaries = new Map();"
          },
          {
            "lineNum": 51,
            "content": ""
          },
          {
            "lineNum": 52,
            "content": "  for (const [filePath, functions] of fileMap.entries()) {"
          },
          {
            "lineNum": 53,
            "content": "    try {"
          },
          {
            "lineNum": 54,
            "content": "      const fullPath = resolve(projectRoot, filePath);"
          },
          {
            "lineNum": 55,
            "content": "      const sourceCode = readFileSync(fullPath, 'utf-8');"
          },
          {
            "lineNum": 56,
            "content": ""
          },
          {
            "lineNum": 57,
            "content": "      // Find function boundaries for this file"
          },
          {
            "lineNum": 58,
            "content": "      const fileBoundaries = findFunctionBoundaries(sourceCode, functions);"
          },
          {
            "lineNum": 59,
            "content": "      fileBoundaries.forEach((boundary, functionLine) => {"
          },
          {
            "lineNum": 60,
            "content": "        allFunctionBoundaries.set(functionLine, boundary);"
          },
          {
            "lineNum": 61,
            "content": "      });"
          },
          {
            "lineNum": 62,
            "content": ""
          },
          {
            "lineNum": 63,
            "content": "      // Parse decision points for this file"
          },
          {
            "lineNum": 64,
            "content": "      const fileDecisionPoints = parseDecisionPoints(sourceCode, fileBoundaries, functions);"
          },
          {
            "lineNum": 65,
            "content": "      allDecisionPoints.push(...fileDecisionPoints);"
          },
          {
            "lineNum": 66,
            "content": ""
          },
          {
            "lineNum": 67,
            "content": "      // Calculate breakdowns for each function"
          },
          {
            "lineNum": 68,
            "content": "      functions.forEach(func => {"
          },
          {
            "lineNum": 69,
            "content": "        const boundary = findBoundaryForFunction(func.line, fileBoundaries);"
          },
          {
            "lineNum": 70,
            "content": "        const breakdown = calculateComplexityBreakdown("
          },
          {
            "lineNum": 71,
            "content": "          func.line,"
          },
          {
            "lineNum": 72,
            "content": "          fileDecisionPoints,"
          },
          {
            "lineNum": 73,
            "content": "          1 // base complexity"
          },
          {
            "lineNum": 74,
            "content": "        );"
          },
          {
            "lineNum": 75,
            "content": ""
          },
          {
            "lineNum": 76,
            "content": "        const actualComplexity = parseInt(func.complexity);"
          },
          {
            "lineNum": 77,
            "content": "        const calculatedTotal = breakdown.calculatedTotal;"
          },
          {
            "lineNum": 78,
            "content": "        const difference = calculatedTotal - actualComplexity;"
          }
        ]
      },
      {
        "functionName": "fixFunctionNameForCallback",
        "file": "scripts/function-hierarchy.js",
        "line": 573,
        "actualComplexity": 9,
        "calculatedTotal": 8,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 577,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 577,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 584,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 586,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 586,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 587,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 588,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 3,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 573,
          "end": 595
        },
        "functionCode": [
          {
            "lineNum": 573,
            "content": "function fixFunctionNameForCallback(func, functionBoundaries, sortedFunctions) {"
          },
          {
            "lineNum": 574,
            "content": "  let displayName = func.functionName || 'unknown';"
          },
          {
            "lineNum": 575,
            "content": "  const callbackMatch = displayName.match(/^(.+?)\\s+\\((.+?)\\s+callback\\)$/);"
          },
          {
            "lineNum": 576,
            "content": "  "
          },
          {
            "lineNum": 577,
            "content": "  if (!callbackMatch || !functionBoundaries) {"
          },
          {
            "lineNum": 578,
            "content": "    return displayName;"
          },
          {
            "lineNum": 579,
            "content": "  }"
          },
          {
            "lineNum": 580,
            "content": "  "
          },
          {
            "lineNum": 581,
            "content": "  const [, parentName, callbackType] = callbackMatch;"
          },
          {
            "lineNum": 582,
            "content": "  const immediateParentFunc = findImmediateParentFunction(func, functionBoundaries, sortedFunctions);"
          },
          {
            "lineNum": 583,
            "content": "  "
          },
          {
            "lineNum": 584,
            "content": "  if (immediateParentFunc) {"
          },
          {
            "lineNum": 585,
            "content": "    const correctParentName = getBaseFunctionName(immediateParentFunc.functionName);"
          },
          {
            "lineNum": 586,
            "content": "    if (correctParentName && "
          },
          {
            "lineNum": 587,
            "content": "        correctParentName !== parentName && "
          },
          {
            "lineNum": 588,
            "content": "        correctParentName !== 'unknown' && "
          },
          {
            "lineNum": 589,
            "content": "        correctParentName !== 'anonymous') {"
          },
          {
            "lineNum": 590,
            "content": "      displayName = `${correctParentName} (${callbackType} callback)`;"
          },
          {
            "lineNum": 591,
            "content": "    }"
          },
          {
            "lineNum": 592,
            "content": "  }"
          },
          {
            "lineNum": 593,
            "content": "  "
          },
          {
            "lineNum": 594,
            "content": "  return displayName;"
          },
          {
            "lineNum": 595,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "findImmediateParentFunction",
        "file": "scripts/function-hierarchy.js",
        "line": 544,
        "actualComplexity": 4,
        "calculatedTotal": 3,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 546,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 558,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 544,
          "end": 564
        },
        "functionCode": [
          {
            "lineNum": 544,
            "content": "function findImmediateParentFunction(func, functionBoundaries, sortedFunctions) {"
          },
          {
            "lineNum": 545,
            "content": "  const funcBoundary = functionBoundaries.get(func.line);"
          },
          {
            "lineNum": 546,
            "content": "  if (!funcBoundary) {"
          },
          {
            "lineNum": 547,
            "content": "    return null;"
          },
          {
            "lineNum": 548,
            "content": "  }"
          },
          {
            "lineNum": 549,
            "content": "  "
          },
          {
            "lineNum": 550,
            "content": "  const containingFunctions = Array.from(functionBoundaries.entries())"
          },
          {
            "lineNum": 551,
            "content": "    .filter(([fl, boundary]) => "
          },
          {
            "lineNum": 552,
            "content": "      fl !== func.line && "
          },
          {
            "lineNum": 553,
            "content": "      boundary.start < funcBoundary.start && "
          },
          {
            "lineNum": 554,
            "content": "      boundary.end >= funcBoundary.end"
          },
          {
            "lineNum": 555,
            "content": "    )"
          },
          {
            "lineNum": 556,
            "content": "    .sort((a, b) => b[1].start - a[1].start);"
          },
          {
            "lineNum": 557,
            "content": "  "
          },
          {
            "lineNum": 558,
            "content": "  if (containingFunctions.length === 0) {"
          },
          {
            "lineNum": 559,
            "content": "    return null;"
          },
          {
            "lineNum": 560,
            "content": "  }"
          },
          {
            "lineNum": 561,
            "content": "  "
          },
          {
            "lineNum": 562,
            "content": "  const immediateParentLine = containingFunctions[0][0];"
          },
          {
            "lineNum": 563,
            "content": "  return sortedFunctions.find(f => f.line === immediateParentLine) || null;"
          },
          {
            "lineNum": 564,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "determineLineClasses",
        "file": "scripts/html-generators.js",
        "line": 1159,
        "actualComplexity": 9,
        "calculatedTotal": 8,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1164,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 1171,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 1171,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 1174,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1175,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1176,
            "name": "if statement"
          },
          {
            "type": "ternary",
            "line": 1181,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 4,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 2,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1159,
          "end": 1184
        },
        "functionCode": [
          {
            "lineNum": 1159,
            "content": "function determineLineClasses(decisionPointsOnLine, lineNum, functionStartLines, functionEndLines, functionClosingLines) {"
          },
          {
            "lineNum": 1160,
            "content": "  const isDecisionPoint = decisionPointsOnLine.length > 0;"
          },
          {
            "lineNum": 1161,
            "content": "  const decisionPointTitle = isDecisionPoint "
          },
          {
            "lineNum": 1162,
            "content": "    ? ` title=\"${decisionPointsOnLine.map(dp => dp.name).join(', ')}\"`"
          },
          {
            "lineNum": 1163,
            "content": "    : '';"
          },
          {
            "lineNum": 1164,
            "content": "  const decisionPointClass = isDecisionPoint ? 'decision-point' : '';"
          },
          {
            "lineNum": 1165,
            "content": "  "
          },
          {
            "lineNum": 1166,
            "content": "  const isFunctionStart = functionStartLines.has(lineNum);"
          },
          {
            "lineNum": 1167,
            "content": "  const isFunctionEnd = functionEndLines.has(lineNum);"
          },
          {
            "lineNum": 1168,
            "content": "  const isFunctionClosing = functionClosingLines.has(lineNum);"
          },
          {
            "lineNum": 1169,
            "content": "  "
          },
          {
            "lineNum": 1170,
            "content": "  const boundaryParts = [];"
          },
          {
            "lineNum": 1171,
            "content": "  if (isFunctionStart && isFunctionEnd) {"
          },
          {
            "lineNum": 1172,
            "content": "    boundaryParts.push('function-boundary-single');"
          },
          {
            "lineNum": 1173,
            "content": "  } else {"
          },
          {
            "lineNum": 1174,
            "content": "    if (isFunctionStart) boundaryParts.push('function-boundary-start');"
          },
          {
            "lineNum": 1175,
            "content": "    if (isFunctionEnd) boundaryParts.push('function-boundary-end');"
          },
          {
            "lineNum": 1176,
            "content": "    if (isFunctionClosing) boundaryParts.push('function-boundary-closing');"
          },
          {
            "lineNum": 1177,
            "content": "  }"
          },
          {
            "lineNum": 1178,
            "content": "  "
          },
          {
            "lineNum": 1179,
            "content": "  const boundaryClass = boundaryParts.join(' ');"
          },
          {
            "lineNum": 1180,
            "content": "  const allClasses = [decisionPointClass, boundaryClass].filter(Boolean).join(' ');"
          },
          {
            "lineNum": 1181,
            "content": "  const classAttr = allClasses ? ` class=\"${allClasses}\"` : '';"
          },
          {
            "lineNum": 1182,
            "content": "  "
          },
          {
            "lineNum": 1183,
            "content": "  return { classAttr, decisionPointTitle, isDecisionPoint, isFunctionStart, isFunctionClosing };"
          },
          {
            "lineNum": 1184,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "generateFileHTML",
        "file": "scripts/html-generators.js",
        "line": 1255,
        "actualComplexity": 8,
        "calculatedTotal": 7,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 1272,
            "name": "if statement"
          },
          {
            "type": "catch",
            "line": 1276,
            "name": "catch block"
          },
          {
            "type": "ternary",
            "line": 1315,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1357,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1597,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1611,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 1,
          "ternary": 4,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1255,
          "end": 1637
        },
        "functionCode": [
          {
            "lineNum": 1255,
            "content": "export function generateFileHTML("
          },
          {
            "lineNum": 1256,
            "content": "  filePath,"
          },
          {
            "lineNum": 1257,
            "content": "  functions,"
          },
          {
            "lineNum": 1258,
            "content": "  projectRoot,"
          },
          {
            "lineNum": 1259,
            "content": "  findFunctionBoundaries,"
          },
          {
            "lineNum": 1260,
            "content": "  parseDecisionPoints,"
          },
          {
            "lineNum": 1261,
            "content": "  calculateComplexityBreakdown,"
          },
          {
            "lineNum": 1262,
            "content": "  formatFunctionHierarchy,"
          },
          {
            "lineNum": 1263,
            "content": "  getComplexityLevel,"
          },
          {
            "lineNum": 1264,
            "content": "  getDirectory,"
          },
          {
            "lineNum": 1265,
            "content": "  escapeHtml"
          },
          {
            "lineNum": 1266,
            "content": ") {"
          },
          {
            "lineNum": 1267,
            "content": "  const fullPath = resolve(projectRoot, filePath);"
          },
          {
            "lineNum": 1268,
            "content": "  let sourceCode = '';"
          },
          {
            "lineNum": 1269,
            "content": "  let sourceLines = [];"
          },
          {
            "lineNum": 1270,
            "content": "  "
          },
          {
            "lineNum": 1271,
            "content": "  try {"
          },
          {
            "lineNum": 1272,
            "content": "    if (existsSync(fullPath)) {"
          },
          {
            "lineNum": 1273,
            "content": "      sourceCode = readFileSync(fullPath, 'utf-8');"
          },
          {
            "lineNum": 1274,
            "content": "      sourceLines = sourceCode.split('\\n');"
          },
          {
            "lineNum": 1275,
            "content": "    }"
          },
          {
            "lineNum": 1276,
            "content": "  } catch (error) {"
          },
          {
            "lineNum": 1277,
            "content": "    console.warn(`Warning: Could not read source file ${filePath}:`, error.message);"
          },
          {
            "lineNum": 1278,
            "content": "  }"
          },
          {
            "lineNum": 1279,
            "content": "  "
          },
          {
            "lineNum": 1280,
            "content": "  // Create a map of line numbers to functions for quick lookup"
          },
          {
            "lineNum": 1281,
            "content": "  const lineToFunction = new Map();"
          },
          {
            "lineNum": 1282,
            "content": "  functions.forEach(func => {"
          },
          {
            "lineNum": 1283,
            "content": "    lineToFunction.set(func.line, func);"
          },
          {
            "lineNum": 1284,
            "content": "  });"
          },
          {
            "lineNum": 1285,
            "content": "  "
          },
          {
            "lineNum": 1286,
            "content": "  // Parse decision points"
          },
          {
            "lineNum": 1287,
            "content": "  const functionBoundaries = findFunctionBoundaries(sourceCode, functions);"
          },
          {
            "lineNum": 1288,
            "content": "  const decisionPoints = parseDecisionPoints(sourceCode, functionBoundaries, functions);"
          },
          {
            "lineNum": 1289,
            "content": "  "
          },
          {
            "lineNum": 1290,
            "content": "  // Calculate complexity breakdowns for each function"
          },
          {
            "lineNum": 1291,
            "content": "  const functionBreakdowns = calculateFunctionBreakdowns("
          },
          {
            "lineNum": 1292,
            "content": "    functions,"
          },
          {
            "lineNum": 1293,
            "content": "    functionBoundaries,"
          },
          {
            "lineNum": 1294,
            "content": "    decisionPoints,"
          },
          {
            "lineNum": 1295,
            "content": "    calculateComplexityBreakdown"
          },
          {
            "lineNum": 1296,
            "content": "  );"
          },
          {
            "lineNum": 1297,
            "content": "  "
          },
          {
            "lineNum": 1298,
            "content": "  // Create decision point line map for highlighting"
          },
          {
            "lineNum": 1299,
            "content": "  const lineToDecisionPoint = new Map();"
          },
          {
            "lineNum": 1300,
            "content": "  decisionPoints.forEach(dp => {"
          },
          {
            "lineNum": 1301,
            "content": "    if (!lineToDecisionPoint.has(dp.line)) {"
          },
          {
            "lineNum": 1302,
            "content": "      lineToDecisionPoint.set(dp.line, []);"
          },
          {
            "lineNum": 1303,
            "content": "    }"
          },
          {
            "lineNum": 1304,
            "content": "    lineToDecisionPoint.get(dp.line).push(dp);"
          }
        ]
      },
      {
        "functionName": "existing (map callback)",
        "file": "scripts/html-generators.js",
        "line": 835,
        "actualComplexity": 5,
        "calculatedTotal": 4,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 845,
            "name": "logical OR"
          },
          {
            "type": "ternary",
            "line": 847,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 847,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 835,
          "end": 861
        },
        "functionCode": [
          {
            "lineNum": 835,
            "content": "            .map(issue => {"
          },
          {
            "lineNum": 836,
            "content": "              const level = getComplexityLevel(issue.complexity);"
          },
          {
            "lineNum": 837,
            "content": "              const complexityNum = parseInt(issue.complexity);"
          },
          {
            "lineNum": 838,
            "content": "              const isOverThreshold = complexityNum > 10;"
          },
          {
            "lineNum": 839,
            "content": "              const maxComplexityForBar = Math.max(30, complexityNum);"
          },
          {
            "lineNum": 840,
            "content": "              const percentage = Math.min(100, (complexityNum / maxComplexityForBar) * 100);"
          },
          {
            "lineNum": 841,
            "content": "              // Extract filename from full path for link (relative to current folder)"
          },
          {
            "lineNum": 842,
            "content": "              const fileName = issue.file.split('/').pop();"
          },
          {
            "lineNum": 843,
            "content": "              // File link is relative to the folder index.html, so just use filename"
          },
          {
            "lineNum": 844,
            "content": "              const fileLinkPath = `${fileName}.html`;"
          },
          {
            "lineNum": 845,
            "content": "              const baseFunctionName = getBaseFunctionName(issue.functionName || 'unknown');"
          },
          {
            "lineNum": 846,
            "content": "              return `"
          },
          {
            "lineNum": 847,
            "content": "                <tr data-over-threshold=\"${isOverThreshold}\" data-file=\"${issue.file}\" data-function=\"${baseFunctionName}\" data-complexity=\"${complexityNum}\" data-line=\"${issue.line}\" ${!showAllInitially && !isOverThreshold ? 'style=\"display: none;\"' : ''}>"
          },
          {
            "lineNum": 848,
            "content": "                  <td class=\"file\"><a href=\"${fileLinkPath}\">${issue.file}</a></td>"
          },
          {
            "lineNum": 849,
            "content": "                  <td class=\"bar ${level}\">"
          },
          {
            "lineNum": 850,
            "content": "                    <div class=\"chart\"><div class=\"cover-fill ${level} ${percentage === 100 ? 'cover-full' : ''}\" style=\"width: ${percentage}%\"></div><div class=\"cover-empty\" style=\"width: ${100 - percentage}%\"></div></div>"
          },
          {
            "lineNum": 851,
            "content": "                  </td>"
          },
          {
            "lineNum": 852,
            "content": "                  <td class=\"file\">"
          },
          {
            "lineNum": 853,
            "content": "                    <span style=\"font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 13px;\">${baseFunctionName}</span>"
          },
          {
            "lineNum": 854,
            "content": "                  </td>"
          },
          {
            "lineNum": 855,
            "content": "                  <td class=\"pct\">"
          },
          {
            "lineNum": 856,
            "content": "                    <span class=\"complexity-value ${level}\">${complexityNum}</span>"
          },
          {
            "lineNum": 857,
            "content": "                  </td>"
          },
          {
            "lineNum": 858,
            "content": "                  <td class=\"abs\">${issue.line}</td>"
          },
          {
            "lineNum": 859,
            "content": "                </tr>"
          },
          {
            "lineNum": 860,
            "content": "              `;"
          },
          {
            "lineNum": 861,
            "content": "            }).join('');"
          }
        ]
      },
      {
        "functionName": "applyThemeToDom",
        "file": "src/main.tsx",
        "line": 63,
        "actualComplexity": 3,
        "calculatedTotal": 2,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 65,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 63,
          "end": 77
        },
        "functionCode": [
          {
            "lineNum": 63,
            "content": "const applyThemeToDom = (theme: typeof defaultTheme) => {"
          },
          {
            "lineNum": 64,
            "content": "  const root = document.getElementById('root');"
          },
          {
            "lineNum": 65,
            "content": "  if (!root) return;"
          },
          {
            "lineNum": 66,
            "content": ""
          },
          {
            "lineNum": 67,
            "content": "  Object.entries(theme).forEach(([key, value]) => {"
          },
          {
            "lineNum": 68,
            "content": "    const cssVar = themeKeyToCssVar(key);"
          },
          {
            "lineNum": 69,
            "content": "    root.style.setProperty(cssVar, value as string);"
          },
          {
            "lineNum": 70,
            "content": "  });"
          },
          {
            "lineNum": 71,
            "content": ""
          },
          {
            "lineNum": 72,
            "content": "  // Also apply --color-bg to html so body element can use it"
          },
          {
            "lineNum": 73,
            "content": "  // (body is a parent of #root, so it can't access variables defined on #root)"
          },
          {
            "lineNum": 74,
            "content": "  if (theme.bg) {"
          },
          {
            "lineNum": 75,
            "content": "    document.documentElement.style.setProperty('--color-bg', theme.bg);"
          },
          {
            "lineNum": 76,
            "content": "  }"
          },
          {
            "lineNum": 77,
            "content": "};"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/components/AudioControl/AudioControl.tsx",
        "line": 61,
        "actualComplexity": 3,
        "calculatedTotal": 2,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 63,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 61,
          "end": 91
        },
        "functionCode": [
          {
            "lineNum": 61,
            "content": "  const initializeAudio = (): HTMLAudioElement | null => {"
          },
          {
            "lineNum": 62,
            "content": "    // If audio already exists, return it"
          },
          {
            "lineNum": 63,
            "content": "    if (audioRef.current) {"
          },
          {
            "lineNum": 64,
            "content": "      return audioRef.current;"
          },
          {
            "lineNum": 65,
            "content": "    }"
          },
          {
            "lineNum": 66,
            "content": ""
          },
          {
            "lineNum": 67,
            "content": "    // If no audio file configured, can't create audio"
          },
          {
            "lineNum": 68,
            "content": "    if (!audioFileRef.current) {"
          },
          {
            "lineNum": 69,
            "content": "      return null;"
          },
          {
            "lineNum": 70,
            "content": "    }"
          },
          {
            "lineNum": 71,
            "content": ""
          },
          {
            "lineNum": 72,
            "content": "    // Create audio element only on user interaction (lazy load)"
          },
          {
            "lineNum": 73,
            "content": "    const audio = new Audio(audioFileRef.current);"
          },
          {
            "lineNum": 74,
            "content": "    audio.loop = true; // Loop the audio"
          },
          {
            "lineNum": 75,
            "content": "    audioRef.current = audio;"
          },
          {
            "lineNum": 76,
            "content": ""
          },
          {
            "lineNum": 77,
            "content": "    // Create event handlers"
          },
          {
            "lineNum": 78,
            "content": "    const handlePlay = () => setIsPlaying(true);"
          },
          {
            "lineNum": 79,
            "content": "    const handlePause = () => setIsPlaying(false);"
          },
          {
            "lineNum": 80,
            "content": "    const handleEnded = () => setIsPlaying(false);"
          },
          {
            "lineNum": 81,
            "content": ""
          },
          {
            "lineNum": 82,
            "content": "    // Store handlers in ref so we can remove them properly"
          },
          {
            "lineNum": 83,
            "content": "    handlersRef.current = { handlePlay, handlePause, handleEnded };"
          },
          {
            "lineNum": 84,
            "content": ""
          },
          {
            "lineNum": 85,
            "content": "    // Listen for play/pause events to update state"
          },
          {
            "lineNum": 86,
            "content": "    audio.addEventListener('play', handlePlay);"
          },
          {
            "lineNum": 87,
            "content": "    audio.addEventListener('pause', handlePause);"
          },
          {
            "lineNum": 88,
            "content": "    audio.addEventListener('ended', handleEnded);"
          },
          {
            "lineNum": 89,
            "content": ""
          },
          {
            "lineNum": 90,
            "content": "    return audio;"
          },
          {
            "lineNum": 91,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "getRelatedPosts",
        "file": "src/data/blog/index.ts",
        "line": 141,
        "actualComplexity": 4,
        "calculatedTotal": 3,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 141,
            "name": "default parameter"
          },
          {
            "type": "if",
            "line": 152,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 141,
          "end": 206
        },
        "functionCode": [
          {
            "lineNum": 141,
            "content": "export function getRelatedPosts(currentPost: BlogPost, limit: number = 3): BlogPosts {"
          },
          {
            "lineNum": 142,
            "content": "  const allPosts = getAllBlogPosts();"
          },
          {
            "lineNum": 143,
            "content": "  "
          },
          {
            "lineNum": 144,
            "content": "  // Exclude current post using slug comparison (not ID) because IDs can be"
          },
          {
            "lineNum": 145,
            "content": "  // duplicated across different topics, but slugs are unique"
          },
          {
            "lineNum": 146,
            "content": "  const otherPosts = allPosts.filter((p) => {"
          },
          {
            "lineNum": 147,
            "content": "    const currentSlug = getBlogPostSlug(currentPost);"
          },
          {
            "lineNum": 148,
            "content": "    const postSlug = getBlogPostSlug(p);"
          },
          {
            "lineNum": 149,
            "content": "    return currentSlug !== postSlug;"
          },
          {
            "lineNum": 150,
            "content": "  });"
          },
          {
            "lineNum": 151,
            "content": "  "
          },
          {
            "lineNum": 152,
            "content": "  if (otherPosts.length === 0) {"
          },
          {
            "lineNum": 153,
            "content": "    return [];"
          },
          {
            "lineNum": 154,
            "content": "  }"
          },
          {
            "lineNum": 155,
            "content": "  "
          },
          {
            "lineNum": 156,
            "content": "  // Score each post based on tag/category matches"
          },
          {
            "lineNum": 157,
            "content": "  const scoredPosts = otherPosts.map((post) => {"
          },
          {
            "lineNum": 158,
            "content": "    let score = 0;"
          },
          {
            "lineNum": 159,
            "content": "    "
          },
          {
            "lineNum": 160,
            "content": "    // Category match: +10 points"
          },
          {
            "lineNum": 161,
            "content": "    // Category is weighted higher because it represents broader topic alignment"
          },
          {
            "lineNum": 162,
            "content": "    if (currentPost.category && post.category && currentPost.category === post.category) {"
          },
          {
            "lineNum": 163,
            "content": "      score += 10;"
          },
          {
            "lineNum": 164,
            "content": "    }"
          },
          {
            "lineNum": 165,
            "content": "    "
          },
          {
            "lineNum": 166,
            "content": "    // Tag matches: +5 points per matching tag"
          },
          {
            "lineNum": 167,
            "content": "    // Tags are case-insensitive to handle variations like \"React\" vs \"react\""
          },
          {
            "lineNum": 168,
            "content": "    if (currentPost.tags && post.tags) {"
          },
          {
            "lineNum": 169,
            "content": "      const currentTags = new Set(currentPost.tags.map(t => t.toLowerCase()));"
          },
          {
            "lineNum": 170,
            "content": "      const postTags = new Set(post.tags.map(t => t.toLowerCase()));"
          },
          {
            "lineNum": 171,
            "content": "      "
          },
          {
            "lineNum": 172,
            "content": "      currentTags.forEach(tag => {"
          },
          {
            "lineNum": 173,
            "content": "        if (postTags.has(tag)) {"
          },
          {
            "lineNum": 174,
            "content": "          score += 5;"
          },
          {
            "lineNum": 175,
            "content": "        }"
          },
          {
            "lineNum": 176,
            "content": "      });"
          },
          {
            "lineNum": 177,
            "content": "    }"
          },
          {
            "lineNum": 178,
            "content": "    "
          },
          {
            "lineNum": 179,
            "content": "    return { post, score };"
          },
          {
            "lineNum": 180,
            "content": "  });"
          },
          {
            "lineNum": 181,
            "content": "  "
          },
          {
            "lineNum": 182,
            "content": "  // Filter to posts with at least one match, sort by score (descending), take top N"
          },
          {
            "lineNum": 183,
            "content": "  const related = scoredPosts"
          },
          {
            "lineNum": 184,
            "content": "    .filter(item => item.score > 0) // Only include posts with at least one match"
          },
          {
            "lineNum": 185,
            "content": "    .sort((a, b) => b.score - a.score)"
          },
          {
            "lineNum": 186,
            "content": "    .slice(0, limit)"
          },
          {
            "lineNum": 187,
            "content": "    .map(item => item.post);"
          },
          {
            "lineNum": 188,
            "content": "  "
          },
          {
            "lineNum": 189,
            "content": "  // Fallback: If we don't have enough matching posts, fill remaining slots"
          },
          {
            "lineNum": 190,
            "content": "  // with random posts to ensure the \"Related Content\" section always displays"
          }
        ]
      },
      {
        "functionName": "currentOnSelect (IntersectionObserver callback)",
        "file": "src/sections/AgencyLogos/index.tsx",
        "line": 141,
        "actualComplexity": 4,
        "calculatedTotal": 3,
        "difference": -1,
        "category": "under-counting",
        "decisionPoints": [
          {
            "type": "?.",
            "line": 142,
            "name": "optional chaining"
          },
          {
            "type": "??",
            "line": 142,
            "name": "nullish coalescing"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 1,
          "?.": 1,
          "default parameter": 0
        },
        "boundary": {
          "start": 141,
          "end": 147
        },
        "functionCode": [
          {
            "lineNum": 141,
            "content": "      (entries) => {"
          },
          {
            "lineNum": 142,
            "content": "        const isVisible = entries[0]?.isIntersecting ?? false;"
          },
          {
            "lineNum": 143,
            "content": "        // Only enable autoplay when visible and user hasn't disabled it"
          },
          {
            "lineNum": 144,
            "content": "        if (!isVisible) {"
          },
          {
            "lineNum": 145,
            "content": "          setAutoplayEnabled(false);"
          },
          {
            "lineNum": 146,
            "content": "        }"
          },
          {
            "lineNum": 147,
            "content": "      },"
          }
        ]
      }
    ],
    "over-counting": [
      {
        "functionName": "useMetaTags",
        "file": "src/hooks/useMetaTags.ts",
        "line": 132,
        "actualComplexity": 6,
        "calculatedTotal": 9,
        "difference": 3,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 138,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 139,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 140,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 140,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 141,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 141,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 142,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 142,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 8
        },
        "boundary": {
          "start": 132,
          "end": 160
        },
        "functionCode": [
          {
            "lineNum": 132,
            "content": "export function useMetaTags(config: MetaTagsConfig) {"
          },
          {
            "lineNum": 133,
            "content": "  const {"
          },
          {
            "lineNum": 134,
            "content": "    title,"
          },
          {
            "lineNum": 135,
            "content": "    description,"
          },
          {
            "lineNum": 136,
            "content": "    image,"
          },
          {
            "lineNum": 137,
            "content": "    url,"
          },
          {
            "lineNum": 138,
            "content": "    type = 'website',"
          },
          {
            "lineNum": 139,
            "content": "    siteName = 'Johnny H.',"
          },
          {
            "lineNum": 140,
            "content": "    twitterCard = 'summary_large_image',"
          },
          {
            "lineNum": 141,
            "content": "    noindex = false,"
          },
          {
            "lineNum": 142,
            "content": "    nofollow = false,"
          },
          {
            "lineNum": 143,
            "content": "  } = config;"
          },
          {
            "lineNum": 144,
            "content": ""
          },
          {
            "lineNum": 145,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 146,
            "content": "    const baseUrl = getBaseUrl();"
          },
          {
            "lineNum": 147,
            "content": "    const fullUrl = resolveUrl(url, baseUrl);"
          },
          {
            "lineNum": 148,
            "content": "    const fullImage = resolveImageUrl(image, baseUrl);"
          },
          {
            "lineNum": 149,
            "content": ""
          },
          {
            "lineNum": 150,
            "content": "    if (title) {"
          },
          {
            "lineNum": 151,
            "content": "      document.title = title;"
          },
          {
            "lineNum": 152,
            "content": "    }"
          },
          {
            "lineNum": 153,
            "content": ""
          },
          {
            "lineNum": 154,
            "content": "    setConditionalMetaTags([{ property: 'description', content: description }]);"
          },
          {
            "lineNum": 155,
            "content": "    setOpenGraphTags(title, description, fullImage, fullUrl, type, siteName);"
          },
          {
            "lineNum": 156,
            "content": "    setTwitterCardTags(twitterCard, title, description, fullImage);"
          },
          {
            "lineNum": 157,
            "content": "    setCanonicalLink(fullUrl);"
          },
          {
            "lineNum": 158,
            "content": "    setMetaTag('robots', generateRobotsContent(noindex, nofollow));"
          },
          {
            "lineNum": 159,
            "content": "  }, [title, description, image, url, type, siteName, twitterCard, noindex, nofollow]);"
          },
          {
            "lineNum": 160,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "BlogFilters (useEffect callback)",
        "file": "src/sections/BlogFilters/index.tsx",
        "line": 26,
        "actualComplexity": 3,
        "calculatedTotal": 6,
        "difference": 3,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 30,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 39,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 44,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 45,
            "name": "logical OR"
          },
          {
            "type": "&&",
            "line": 46,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 26,
          "end": 51
        },
        "functionCode": [
          {
            "lineNum": 26,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 27,
            "content": "    let filtered = [...posts]; // Create a copy to avoid mutating"
          },
          {
            "lineNum": 28,
            "content": ""
          },
          {
            "lineNum": 29,
            "content": "    // Filter by category or tag"
          },
          {
            "lineNum": 30,
            "content": "    if (selectedCategory !== \"all\") {"
          },
          {
            "lineNum": 31,
            "content": "      filtered = filtered.filter("
          },
          {
            "lineNum": 32,
            "content": "        (post) => "
          },
          {
            "lineNum": 33,
            "content": "          post.category === selectedCategory || "
          },
          {
            "lineNum": 34,
            "content": "          (post.tags && post.tags.includes(selectedCategory))"
          },
          {
            "lineNum": 35,
            "content": "      );"
          },
          {
            "lineNum": 36,
            "content": "    }"
          },
          {
            "lineNum": 37,
            "content": ""
          },
          {
            "lineNum": 38,
            "content": "    // Filter by search query"
          },
          {
            "lineNum": 39,
            "content": "    if (searchQuery.trim()) {"
          },
          {
            "lineNum": 40,
            "content": "      const query = searchQuery.toLowerCase();"
          },
          {
            "lineNum": 41,
            "content": "      filtered = filtered.filter("
          },
          {
            "lineNum": 42,
            "content": "        (post) =>"
          },
          {
            "lineNum": 43,
            "content": "          post.title.toLowerCase().includes(query) ||"
          },
          {
            "lineNum": 44,
            "content": "          post.excerpt.toLowerCase().includes(query) ||"
          },
          {
            "lineNum": 45,
            "content": "          post.category.toLowerCase().includes(query) ||"
          },
          {
            "lineNum": 46,
            "content": "          (post.tags && post.tags.some(tag => tag.toLowerCase().includes(query)))"
          },
          {
            "lineNum": 47,
            "content": "      );"
          },
          {
            "lineNum": 48,
            "content": "    }"
          },
          {
            "lineNum": 49,
            "content": ""
          },
          {
            "lineNum": 50,
            "content": "    onFilterChange(filtered);"
          },
          {
            "lineNum": 51,
            "content": "  }, [posts, searchQuery, selectedCategory, onFilterChange]);"
          }
        ]
      },
      {
        "functionName": "findNamedFunctionStart",
        "file": "scripts/function-boundaries.js",
        "line": 993,
        "actualComplexity": 6,
        "calculatedTotal": 8,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1000,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1001,
            "name": "ternary operator"
          },
          {
            "type": "for",
            "line": 1010,
            "name": "for loop"
          },
          {
            "type": "for...of",
            "line": 1012,
            "name": "for...of loop"
          },
          {
            "type": "if",
            "line": 1014,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 1014,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 1019,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 1,
          "for...of": 1,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 2,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 993,
          "end": 1023
        },
        "functionCode": [
          {
            "lineNum": 993,
            "content": "function findNamedFunctionStart(lines, functionLine, functionName) {"
          },
          {
            "lineNum": 994,
            "content": "  // Named function: look backwards from the reported line to find function declaration"
          },
          {
            "lineNum": 995,
            "content": "  // Check up to 50 lines back"
          },
          {
            "lineNum": 996,
            "content": "  const startLine = Math.max(0, functionLine - 50);"
          },
          {
            "lineNum": 997,
            "content": "  "
          },
          {
            "lineNum": 998,
            "content": "  // Try various function patterns to find the actual declaration line"
          },
          {
            "lineNum": 999,
            "content": "  const patterns = ["
          },
          {
            "lineNum": 1000,
            "content": "    /(?:export\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
          },
          {
            "lineNum": 1001,
            "content": "    /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
          },
          {
            "lineNum": 1002,
            "content": "    /export\\s+const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
          },
          {
            "lineNum": 1003,
            "content": "    /export\\s+default\\s+function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
          },
          {
            "lineNum": 1004,
            "content": "    /(?:export\\s+default\\s+|const\\s+)([A-Z][a-zA-Z0-9_$]*)\\s*[:=]\\s*(?:\\([^)]*\\)\\s*)?=>/,"
          },
          {
            "lineNum": 1005,
            "content": "  ];"
          },
          {
            "lineNum": 1006,
            "content": "  "
          },
          {
            "lineNum": 1007,
            "content": "  // Find the actual function declaration line"
          },
          {
            "lineNum": 1008,
            "content": "  // Match the function name to ensure we find the correct function"
          },
          {
            "lineNum": 1009,
            "content": "  let start = functionLine;"
          },
          {
            "lineNum": 1010,
            "content": "  for (let i = functionLine - 1; i >= startLine; i--) {"
          },
          {
            "lineNum": 1011,
            "content": "    const line = lines[i];"
          },
          {
            "lineNum": 1012,
            "content": "    for (const pattern of patterns) {"
          },
          {
            "lineNum": 1013,
            "content": "      const match = line.match(pattern);"
          },
          {
            "lineNum": 1014,
            "content": "      if (match && match[1] === functionName) {"
          },
          {
            "lineNum": 1015,
            "content": "        start = i + 1; // Convert to 1-based line number"
          },
          {
            "lineNum": 1016,
            "content": "        break;"
          },
          {
            "lineNum": 1017,
            "content": "      }"
          },
          {
            "lineNum": 1018,
            "content": "    }"
          },
          {
            "lineNum": 1019,
            "content": "    if (start !== functionLine) break;"
          },
          {
            "lineNum": 1020,
            "content": "  }"
          },
          {
            "lineNum": 1021,
            "content": "  "
          },
          {
            "lineNum": 1022,
            "content": "  return start;"
          },
          {
            "lineNum": 1023,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "processSwitchAndCatch",
        "file": "scripts/decision-points.js",
        "line": 3399,
        "actualComplexity": 9,
        "calculatedTotal": 11,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 3402,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 3404,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3406,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3407,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3412,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 3412,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 3419,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 3421,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3423,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3424,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 7,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 2,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3399,
          "end": 3426
        },
        "functionCode": [
          {
            "lineNum": 3399,
            "content": "  const processSwitchAndCatch = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 3400,
            "content": "    // Switch statement"
          },
          {
            "lineNum": 3401,
            "content": "    const isSwitchStatement = /^\\s*switch\\s*\\(/.test(lineWithoutComments);"
          },
          {
            "lineNum": 3402,
            "content": "    if (isSwitchStatement) {"
          },
          {
            "lineNum": 3403,
            "content": "      decisionPoints.push({ line: lineNum, type: 'switch', name: 'switch statement', functionLine });"
          },
          {
            "lineNum": 3404,
            "content": "      const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 3405,
            "content": "      const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 3406,
            "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3407,
            "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3408,
            "content": "      return;"
          },
          {
            "lineNum": 3409,
            "content": "    }"
          },
          {
            "lineNum": 3410,
            "content": "    "
          },
          {
            "lineNum": 3411,
            "content": "    // Case statements"
          },
          {
            "lineNum": 3412,
            "content": "    if (/^\\s*case\\s+/.test(lineWithoutComments) || /^\\s*default\\s*:/.test(lineWithoutComments)) {"
          },
          {
            "lineNum": 3413,
            "content": "      decisionPoints.push({ line: lineNum, type: 'case', name: 'case/default', functionLine });"
          },
          {
            "lineNum": 3414,
            "content": "      return;"
          },
          {
            "lineNum": 3415,
            "content": "    }"
          },
          {
            "lineNum": 3416,
            "content": "    "
          },
          {
            "lineNum": 3417,
            "content": "    // Catch blocks"
          },
          {
            "lineNum": 3418,
            "content": "    const isCatchBlock = /\\bcatch\\s*[({]/.test(lineWithoutComments);"
          },
          {
            "lineNum": 3419,
            "content": "    if (isCatchBlock) {"
          },
          {
            "lineNum": 3420,
            "content": "      decisionPoints.push({ line: lineNum, type: 'catch', name: 'catch block', functionLine });"
          },
          {
            "lineNum": 3421,
            "content": "      const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 3422,
            "content": "      const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 3423,
            "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3424,
            "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3425,
            "content": "    }"
          },
          {
            "lineNum": 3426,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "hasFunctionSignature",
        "file": "scripts/decision-points.js",
        "line": 1008,
        "actualComplexity": 7,
        "calculatedTotal": 9,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1009,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1009,
            "name": "ternary operator"
          },
          {
            "type": "||",
            "line": 1009,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1010,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1011,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1012,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1013,
            "name": "logical OR"
          },
          {
            "type": "&&",
            "line": 1014,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 2,
          "&&": 1,
          "||": 5,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1008,
          "end": 1015
        },
        "functionCode": [
          {
            "lineNum": 1008,
            "content": "  const hasFunctionSignature = (lineWithoutComments, isArrowFunctionParam) => {"
          },
          {
            "lineNum": 1009,
            "content": "    return /^\\s*(?:export\\s+)?(?:function|const|let|var)\\s+\\w+\\s*[=(]/.test(lineWithoutComments) ||"
          },
          {
            "lineNum": 1010,
            "content": "           /^\\s*\\([^)]*/.test(lineWithoutComments) ||"
          },
          {
            "lineNum": 1011,
            "content": "           /=>\\s*\\([^)]*/.test(lineWithoutComments) ||"
          },
          {
            "lineNum": 1012,
            "content": "           /\\.\\w+\\s*\\([^)]*/.test(lineWithoutComments) ||"
          },
          {
            "lineNum": 1013,
            "content": "           /\\([^)]*\\{[^}]*\\}/.test(lineWithoutComments) ||"
          },
          {
            "lineNum": 1014,
            "content": "           (isArrowFunctionParam && /\\(/.test(lineWithoutComments));"
          },
          {
            "lineNum": 1015,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "handleFunctionDeclaration",
        "file": "scripts/function-extraction.js",
        "line": 236,
        "actualComplexity": 5,
        "calculatedTotal": 7,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 241,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 242,
            "name": "ternary operator"
          },
          {
            "type": "for...of",
            "line": 251,
            "name": "for...of loop"
          },
          {
            "type": "if",
            "line": 253,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 256,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 263,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 1,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 2,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 236,
          "end": 264
        },
        "functionCode": [
          {
            "lineNum": 236,
            "content": "function handleFunctionDeclaration(lines, lineNumber) {"
          },
          {
            "lineNum": 237,
            "content": "  const startLine = Math.max(0, lineNumber - 50);"
          },
          {
            "lineNum": 238,
            "content": "  const context = lines.slice(startLine, lineNumber).join('\\n');"
          },
          {
            "lineNum": 239,
            "content": "  "
          },
          {
            "lineNum": 240,
            "content": "  const patterns = ["
          },
          {
            "lineNum": 241,
            "content": "    /(?:export\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
          },
          {
            "lineNum": 242,
            "content": "    /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
          },
          {
            "lineNum": 243,
            "content": "    /export\\s+const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
          },
          {
            "lineNum": 244,
            "content": "    /export\\s+default\\s+function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
          },
          {
            "lineNum": 245,
            "content": "    /(?:export\\s+default\\s+|const\\s+)([A-Z][a-zA-Z0-9_$]*)\\s*[:=]\\s*(?:\\([^)]*\\)\\s*)?=>/,"
          },
          {
            "lineNum": 246,
            "content": "  ];"
          },
          {
            "lineNum": 247,
            "content": "  "
          },
          {
            "lineNum": 248,
            "content": "  let lastMatch = null;"
          },
          {
            "lineNum": 249,
            "content": "  let lastIndex = -1;"
          },
          {
            "lineNum": 250,
            "content": "  "
          },
          {
            "lineNum": 251,
            "content": "  for (const pattern of patterns) {"
          },
          {
            "lineNum": 252,
            "content": "    const matches = [...context.matchAll(new RegExp(pattern.source, 'g'))];"
          },
          {
            "lineNum": 253,
            "content": "    if (matches.length > 0) {"
          },
          {
            "lineNum": 254,
            "content": "      const match = matches[matches.length - 1];"
          },
          {
            "lineNum": 255,
            "content": "      const matchIndex = context.lastIndexOf(match[0]);"
          },
          {
            "lineNum": 256,
            "content": "      if (matchIndex > lastIndex) {"
          },
          {
            "lineNum": 257,
            "content": "        lastMatch = match[1];"
          },
          {
            "lineNum": 258,
            "content": "        lastIndex = matchIndex;"
          },
          {
            "lineNum": 259,
            "content": "      }"
          },
          {
            "lineNum": 260,
            "content": "    }"
          },
          {
            "lineNum": 261,
            "content": "  }"
          },
          {
            "lineNum": 262,
            "content": "  "
          },
          {
            "lineNum": 263,
            "content": "  return lastMatch || 'anonymous';"
          },
          {
            "lineNum": 264,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "getDefaultCallbackLabel",
        "file": "scripts/function-hierarchy.js",
        "line": 416,
        "actualComplexity": 7,
        "calculatedTotal": 9,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 417,
            "name": "if statement"
          },
          {
            "type": "ternary",
            "line": 421,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 422,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 422,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 422,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 422,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 422,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 423,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 4,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 416,
          "end": 429
        },
        "functionCode": [
          {
            "lineNum": 416,
            "content": "function getDefaultCallbackLabel(functionName, parentNode) {"
          },
          {
            "lineNum": 417,
            "content": "  if (!functionName.includes('(arrow function)')) {"
          },
          {
            "lineNum": 418,
            "content": "    return 'callback';"
          },
          {
            "lineNum": 419,
            "content": "  }"
          },
          {
            "lineNum": 420,
            "content": "  "
          },
          {
            "lineNum": 421,
            "content": "  const parentName = parentNode ? parentNode.functionName : '';"
          },
          {
            "lineNum": 422,
            "content": "  if (parentName && parentName !== 'unknown' && parentName !== 'anonymous') {"
          },
          {
            "lineNum": 423,
            "content": "    if (!functionName.includes(parentName)) {"
          },
          {
            "lineNum": 424,
            "content": "      return `${parentName} callback`;"
          },
          {
            "lineNum": 425,
            "content": "    }"
          },
          {
            "lineNum": 426,
            "content": "  }"
          },
          {
            "lineNum": 427,
            "content": "  "
          },
          {
            "lineNum": 428,
            "content": "  return 'callback';"
          },
          {
            "lineNum": 429,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "determineLineClasses (map callback)",
        "file": "scripts/html-generators.js",
        "line": 1162,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 1162,
            "name": "default parameter"
          },
          {
            "type": "ternary",
            "line": 1162,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 1162,
          "end": 1162
        },
        "functionCode": [
          {
            "lineNum": 1162,
            "content": "    ? ` title=\"${decisionPointsOnLine.map(dp => dp.name).join(', ')}\"`"
          }
        ]
      },
      {
        "functionName": "setConditionalMetaTags",
        "file": "src/hooks/useMetaTags.ts",
        "line": 80,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 81,
            "name": "ternary operator"
          },
          {
            "type": "default parameter",
            "line": 83,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 80,
          "end": 88
        },
        "functionCode": [
          {
            "lineNum": 80,
            "content": "function setConditionalMetaTags("
          },
          {
            "lineNum": 81,
            "content": "  tags: Array<{ property: string; content: string | undefined; isProperty?: boolean }>"
          },
          {
            "lineNum": 82,
            "content": "): void {"
          },
          {
            "lineNum": 83,
            "content": "  tags.forEach(({ property, content, isProperty = false }) => {"
          },
          {
            "lineNum": 84,
            "content": "    if (content) {"
          },
          {
            "lineNum": 85,
            "content": "      setMetaTag(property, content, isProperty);"
          },
          {
            "lineNum": 86,
            "content": "    }"
          },
          {
            "lineNum": 87,
            "content": "  });"
          },
          {
            "lineNum": 88,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "useImagePreload (useEffect callback)",
        "file": "src/hooks/useImagePreload.ts",
        "line": 13,
        "actualComplexity": 3,
        "calculatedTotal": 5,
        "difference": 2,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 14,
            "name": "if statement"
          },
          {
            "type": "default parameter",
            "line": 28,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 31,
            "name": "default parameter"
          },
          {
            "type": "if",
            "line": 38,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 2
        },
        "boundary": {
          "start": 13,
          "end": 47
        },
        "functionCode": [
          {
            "lineNum": 13,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 14,
            "content": "    if (!imageUrl) return;"
          },
          {
            "lineNum": 15,
            "content": ""
          },
          {
            "lineNum": 16,
            "content": "    const processedUrl = getGrayscaleImageUrl(imageUrl, isNoirTheme);"
          },
          {
            "lineNum": 17,
            "content": ""
          },
          {
            "lineNum": 18,
            "content": "    // Create preload link for faster LCP"
          },
          {
            "lineNum": 19,
            "content": "    const link = document.createElement(\"link\");"
          },
          {
            "lineNum": 20,
            "content": "    link.setAttribute(\"rel\", \"preload\");"
          },
          {
            "lineNum": 21,
            "content": "    link.setAttribute(\"as\", \"image\");"
          },
          {
            "lineNum": 22,
            "content": "    link.setAttribute(\"href\", processedUrl);"
          },
          {
            "lineNum": 23,
            "content": "    link.setAttribute(\"fetchPriority\", \"high\");"
          },
          {
            "lineNum": 24,
            "content": "    document.head.appendChild(link);"
          },
          {
            "lineNum": 25,
            "content": ""
          },
          {
            "lineNum": 26,
            "content": "    // Detect when the image is loaded"
          },
          {
            "lineNum": 27,
            "content": "    const img = new Image();"
          },
          {
            "lineNum": 28,
            "content": "    img.onload = () => {"
          },
          {
            "lineNum": 29,
            "content": "      setImageLoaded(true);"
          },
          {
            "lineNum": 30,
            "content": "    };"
          },
          {
            "lineNum": 31,
            "content": "    img.onerror = () => {"
          },
          {
            "lineNum": 32,
            "content": "      // Show content even if image fails to load"
          },
          {
            "lineNum": 33,
            "content": "      setImageLoaded(true);"
          },
          {
            "lineNum": 34,
            "content": "    };"
          },
          {
            "lineNum": 35,
            "content": "    img.src = processedUrl;"
          },
          {
            "lineNum": 36,
            "content": "    "
          },
          {
            "lineNum": 37,
            "content": "    // Handle already cached images"
          },
          {
            "lineNum": 38,
            "content": "    if (img.complete) {"
          },
          {
            "lineNum": 39,
            "content": "      setTimeout(() => setImageLoaded(true), 0);"
          },
          {
            "lineNum": 40,
            "content": "    }"
          },
          {
            "lineNum": 41,
            "content": ""
          },
          {
            "lineNum": 42,
            "content": "    return () => {"
          },
          {
            "lineNum": 43,
            "content": "      if (document.head.contains(link)) {"
          },
          {
            "lineNum": 44,
            "content": "        document.head.removeChild(link);"
          },
          {
            "lineNum": 45,
            "content": "      }"
          },
          {
            "lineNum": 46,
            "content": "    };"
          },
          {
            "lineNum": 47,
            "content": "  }, [imageUrl, isNoirTheme]);"
          }
        ]
      },
      {
        "functionName": "findArrowFunctionEnd",
        "file": "scripts/function-boundaries.js",
        "line": 474,
        "actualComplexity": 7,
        "calculatedTotal": 8,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 482,
            "name": "default parameter"
          },
          {
            "type": "for",
            "line": 482,
            "name": "for loop"
          },
          {
            "type": "if",
            "line": 485,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 490,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 492,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 498,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 500,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 5,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 474,
          "end": 512
        },
        "functionCode": [
          {
            "lineNum": 474,
            "content": "function findArrowFunctionEnd(lines, start, functionLine, boundaries) {"
          },
          {
            "lineNum": 475,
            "content": "  let end = functionLine;"
          },
          {
            "lineNum": 476,
            "content": "  let arrowFunctionHandled = false;"
          },
          {
            "lineNum": 477,
            "content": "  let arrowFunctionEndSet = false;"
          },
          {
            "lineNum": 478,
            "content": "  let inFunctionBody = false;"
          },
          {
            "lineNum": 479,
            "content": "  let braceCount = 0;"
          },
          {
            "lineNum": 480,
            "content": "  "
          },
          {
            "lineNum": 481,
            "content": "  // Find the arrow function body start (where { appears after =>)"
          },
          {
            "lineNum": 482,
            "content": "  for (let i = start - 1; i < lines.length; i++) {"
          },
          {
            "lineNum": 483,
            "content": "    const line = lines[i];"
          },
          {
            "lineNum": 484,
            "content": "    // Look for => followed by { or ( on same or next line"
          },
          {
            "lineNum": 485,
            "content": "    if (line.includes('=>')) {"
          },
          {
            "lineNum": 486,
            "content": "      const arrowIndex = line.indexOf('=>');"
          },
          {
            "lineNum": 487,
            "content": "      const afterArrow = line.substring(arrowIndex + 2).trim();"
          },
          {
            "lineNum": 488,
            "content": "      "
          },
          {
            "lineNum": 489,
            "content": "      // Try JSX return pattern first"
          },
          {
            "lineNum": 490,
            "content": "      if (afterArrow.startsWith('(')) {"
          },
          {
            "lineNum": 491,
            "content": "        const jsxResult = handleJSXReturnPattern(lines, i, arrowIndex, functionLine, boundaries);"
          },
          {
            "lineNum": 492,
            "content": "        if (jsxResult) {"
          },
          {
            "lineNum": 493,
            "content": "          return { ...jsxResult, inFunctionBody, braceCount };"
          },
          {
            "lineNum": 494,
            "content": "        }"
          },
          {
            "lineNum": 495,
            "content": "      }"
          },
          {
            "lineNum": 496,
            "content": "      "
          },
          {
            "lineNum": 497,
            "content": "      // Check if { is on the same line after =>"
          },
          {
            "lineNum": 498,
            "content": "      if (line.includes('{')) {"
          },
          {
            "lineNum": 499,
            "content": "        const braceResult = handleBraceOnSameLine(lines, i, arrowIndex, functionLine, boundaries, line);"
          },
          {
            "lineNum": 500,
            "content": "        if (braceResult) {"
          },
          {
            "lineNum": 501,
            "content": "          return braceResult;"
          },
          {
            "lineNum": 502,
            "content": "        }"
          },
          {
            "lineNum": 503,
            "content": "      } else {"
          },
          {
            "lineNum": 504,
            "content": "        const noBraceResult = handleNoBraceOnSameLine(lines, i, arrowIndex, functionLine, boundaries);"
          },
          {
            "lineNum": 505,
            "content": "        return noBraceResult;"
          },
          {
            "lineNum": 506,
            "content": "      }"
          },
          {
            "lineNum": 507,
            "content": "      break;"
          },
          {
            "lineNum": 508,
            "content": "    }"
          },
          {
            "lineNum": 509,
            "content": "  }"
          },
          {
            "lineNum": 510,
            "content": "  "
          },
          {
            "lineNum": 511,
            "content": "  return { end, found: false, arrowFunctionHandled, arrowFunctionEndSet, inFunctionBody, braceCount };"
          },
          {
            "lineNum": 512,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "isFunctionDeclarationPattern",
        "file": "scripts/function-boundaries.js",
        "line": 519,
        "actualComplexity": 4,
        "calculatedTotal": 5,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 520,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 520,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 521,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 522,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 3,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 519,
          "end": 524
        },
        "functionCode": [
          {
            "lineNum": 519,
            "content": "function isFunctionDeclarationPattern(line) {"
          },
          {
            "lineNum": 520,
            "content": "  return /^\\s*(?:export\\s+)?function\\s+\\w+/.test(line) && "
          },
          {
            "lineNum": 521,
            "content": "         line.includes('(') && "
          },
          {
            "lineNum": 522,
            "content": "         line.includes('{') && "
          },
          {
            "lineNum": 523,
            "content": "         !line.includes('=>');"
          },
          {
            "lineNum": 524,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "parseDecisionPoints",
        "file": "scripts/decision-points.js",
        "line": 8,
        "actualComplexity": 9,
        "calculatedTotal": 10,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 8,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 509,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 613,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 1198,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 1198,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 1335,
            "name": "default parameter"
          },
          {
            "type": "default parameter",
            "line": 1335,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 9
        },
        "boundary": {
          "start": 8,
          "end": 1406
        },
        "functionCode": [
          {
            "lineNum": 8,
            "content": "export function parseDecisionPoints(sourceCode, functionBoundaries, functions = []) {"
          },
          {
            "lineNum": 9,
            "content": "  const decisionPoints = [];"
          },
          {
            "lineNum": 10,
            "content": "  const lines = sourceCode.split('\\n');"
          },
          {
            "lineNum": 11,
            "content": "  "
          },
          {
            "lineNum": 12,
            "content": "  // Create a reverse map: line number -> array of function lines that contain it"
          },
          {
            "lineNum": 13,
            "content": "  // We'll assign decision points to the innermost function"
          },
          {
            "lineNum": 14,
            "content": "  const lineToFunctions = new Map();"
          },
          {
            "lineNum": 15,
            "content": "  functionBoundaries.forEach((boundary, functionLine) => {"
          },
          {
            "lineNum": 16,
            "content": "    for (let line = boundary.start; line <= boundary.end; line++) {"
          },
          {
            "lineNum": 17,
            "content": "      if (!lineToFunctions.has(line)) {"
          },
          {
            "lineNum": 18,
            "content": "        lineToFunctions.set(line, []);"
          },
          {
            "lineNum": 19,
            "content": "      }"
          },
          {
            "lineNum": 20,
            "content": "      lineToFunctions.get(line).push({ functionLine, boundary });"
          },
          {
            "lineNum": 21,
            "content": "    }"
          },
          {
            "lineNum": 22,
            "content": "  });"
          },
          {
            "lineNum": 23,
            "content": "  "
          },
          {
            "lineNum": 24,
            "content": "  // Helper functions for finding innermost function"
          },
          {
            "lineNum": 25,
            "content": "  "
          },
          {
            "lineNum": 26,
            "content": "  /**"
          },
          {
            "lineNum": 27,
            "content": "   * Filters functions to only those that actually contain the line"
          },
          {
            "lineNum": 28,
            "content": "   * @param {Array} containingFunctions - Array of functions"
          },
          {
            "lineNum": 29,
            "content": "   * @param {number} lineNum - Line number"
          },
          {
            "lineNum": 30,
            "content": "   * @returns {Array} Valid functions that contain the line"
          },
          {
            "lineNum": 31,
            "content": "   */"
          },
          {
            "lineNum": 32,
            "content": "  const getValidFunctions = (containingFunctions, lineNum) => {"
          },
          {
            "lineNum": 33,
            "content": "    return containingFunctions.filter(f => "
          },
          {
            "lineNum": 34,
            "content": "      f.boundary.start <= lineNum && lineNum <= f.boundary.end"
          },
          {
            "lineNum": 35,
            "content": "    );"
          },
          {
            "lineNum": 36,
            "content": "  };"
          },
          {
            "lineNum": 37,
            "content": "  "
          },
          {
            "lineNum": 38,
            "content": "  /**"
          },
          {
            "lineNum": 39,
            "content": "   * Finds the immediate parent function"
          },
          {
            "lineNum": 40,
            "content": "   * @param {Array} sortedFunctions - Functions sorted by start line"
          },
          {
            "lineNum": 41,
            "content": "   * @param {number} lineNum - Line number"
          },
          {
            "lineNum": 42,
            "content": "   * @returns {Object|null} Immediate parent function or null"
          },
          {
            "lineNum": 43,
            "content": "   */"
          },
          {
            "lineNum": 44,
            "content": "  const findImmediateParent = (sortedFunctions, lineNum) => {"
          },
          {
            "lineNum": 45,
            "content": "    return sortedFunctions"
          },
          {
            "lineNum": 46,
            "content": "      .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
          },
          {
            "lineNum": 47,
            "content": "      .sort((a, b) => {"
          },
          {
            "lineNum": 48,
            "content": "        const aSize = a.boundary.end - a.boundary.start;"
          },
          {
            "lineNum": 49,
            "content": "        const bSize = b.boundary.end - b.boundary.start;"
          },
          {
            "lineNum": 50,
            "content": "        if (aSize !== bSize) {"
          },
          {
            "lineNum": 51,
            "content": "          return aSize - bSize;"
          },
          {
            "lineNum": 52,
            "content": "        }"
          },
          {
            "lineNum": 53,
            "content": "        return b.boundary.start - a.boundary.start;"
          },
          {
            "lineNum": 54,
            "content": "      })[0] || null;"
          },
          {
            "lineNum": 55,
            "content": "  };"
          },
          {
            "lineNum": 56,
            "content": "  "
          },
          {
            "lineNum": 57,
            "content": "  /**"
          }
        ]
      },
      {
        "functionName": "processPreviousLineLogicalOperators",
        "file": "scripts/decision-points.js",
        "line": 2395,
        "actualComplexity": 5,
        "calculatedTotal": 6,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 2396,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 2396,
            "name": "logical OR"
          },
          {
            "type": "&&",
            "line": 2400,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 2402,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 2403,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2395,
          "end": 2404
        },
        "functionCode": [
          {
            "lineNum": 2395,
            "content": "  const processPreviousLineLogicalOperators = (prevLine, prevLineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 2396,
            "content": "    if (!prevLine || !/[&|]{2}/.test(prevLine)) {"
          },
          {
            "lineNum": 2397,
            "content": "      return;"
          },
          {
            "lineNum": 2398,
            "content": "    }"
          },
          {
            "lineNum": 2399,
            "content": "    "
          },
          {
            "lineNum": 2400,
            "content": "    const prevAndMatches = prevLine.match(/&&/g);"
          },
          {
            "lineNum": 2401,
            "content": "    const prevOrMatches = prevLine.match(/\\|\\|/g);"
          },
          {
            "lineNum": 2402,
            "content": "    if (prevAndMatches) prevAndMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 2403,
            "content": "    if (prevOrMatches) prevOrMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 2404,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processTernaryLogicalOperators",
        "file": "scripts/decision-points.js",
        "line": 2381,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 2382,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 2384,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 2385,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2381,
          "end": 2386
        },
        "functionCode": [
          {
            "lineNum": 2381,
            "content": "  const processTernaryLogicalOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 2382,
            "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 2383,
            "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 2384,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 2385,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 2386,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processMultiLineConditionOperators",
        "file": "scripts/decision-points.js",
        "line": 3062,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3063,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3065,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3066,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3062,
          "end": 3067
        },
        "functionCode": [
          {
            "lineNum": 3062,
            "content": "  const processMultiLineConditionOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 3063,
            "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 3064,
            "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 3065,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3066,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3067,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processElseIfStatement",
        "file": "scripts/decision-points.js",
        "line": 3311,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3313,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3315,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3320,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3311,
          "end": 3325
        },
        "functionCode": [
          {
            "lineNum": 3311,
            "content": "  const processElseIfStatement = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 3312,
            "content": "    decisionPoints.push({ line: lineNum, type: 'else if', name: 'else if statement', functionLine });"
          },
          {
            "lineNum": 3313,
            "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 3314,
            "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 3315,
            "content": "    if (andMatches) {"
          },
          {
            "lineNum": 3316,
            "content": "      andMatches.forEach(() => {"
          },
          {
            "lineNum": 3317,
            "content": "        decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine });"
          },
          {
            "lineNum": 3318,
            "content": "      });"
          },
          {
            "lineNum": 3319,
            "content": "    }"
          },
          {
            "lineNum": 3320,
            "content": "    if (orMatches) {"
          },
          {
            "lineNum": 3321,
            "content": "      orMatches.forEach(() => {"
          },
          {
            "lineNum": 3322,
            "content": "        decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine });"
          },
          {
            "lineNum": 3323,
            "content": "      });"
          },
          {
            "lineNum": 3324,
            "content": "    }"
          },
          {
            "lineNum": 3325,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processLoopLogicalOperators",
        "file": "scripts/decision-points.js",
        "line": 3345,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3346,
            "name": "logical AND"
          },
          {
            "type": "if",
            "line": 3348,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 3349,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3345,
          "end": 3350
        },
        "functionCode": [
          {
            "lineNum": 3345,
            "content": "  const processLoopLogicalOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
          },
          {
            "lineNum": 3346,
            "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
          },
          {
            "lineNum": 3347,
            "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
          },
          {
            "lineNum": 3348,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3349,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3350,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "findImmediateParent (sort callback)",
        "file": "scripts/decision-points.js",
        "line": 47,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 50,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 54,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 47,
          "end": 54
        },
        "functionCode": [
          {
            "lineNum": 47,
            "content": "      .sort((a, b) => {"
          },
          {
            "lineNum": 48,
            "content": "        const aSize = a.boundary.end - a.boundary.start;"
          },
          {
            "lineNum": 49,
            "content": "        const bSize = b.boundary.end - b.boundary.start;"
          },
          {
            "lineNum": 50,
            "content": "        if (aSize !== bSize) {"
          },
          {
            "lineNum": 51,
            "content": "          return aSize - bSize;"
          },
          {
            "lineNum": 52,
            "content": "        }"
          },
          {
            "lineNum": 53,
            "content": "        return b.boundary.start - a.boundary.start;"
          },
          {
            "lineNum": 54,
            "content": "      })[0] || null;"
          }
        ]
      },
      {
        "functionName": "processIfStatementLogicalOperators",
        "file": "scripts/decision-points.js",
        "line": 3288,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3292,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 3295,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 2,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3288,
          "end": 3302
        },
        "functionCode": [
          {
            "lineNum": 3288,
            "content": "  const processIfStatementLogicalOperators = (lineWithoutComments, lineNum, functionLine, functionBoundaries, getInnermostFunction, decisionPoints) => {"
          },
          {
            "lineNum": 3289,
            "content": "    const callbacksOnThisLine = Array.from(functionBoundaries.entries())"
          },
          {
            "lineNum": 3290,
            "content": "      .filter(([fl, boundary]) => boundary.start === lineNum && fl !== functionLine);"
          },
          {
            "lineNum": 3291,
            "content": "    "
          },
          {
            "lineNum": 3292,
            "content": "    const andMatches = Array.from(lineWithoutComments.matchAll(/&&/g));"
          },
          {
            "lineNum": 3293,
            "content": "    const orMatches = Array.from(lineWithoutComments.matchAll(/\\|\\|/g));"
          },
          {
            "lineNum": 3294,
            "content": "    const arrowIndex = lineWithoutComments.indexOf('=>');"
          },
          {
            "lineNum": 3295,
            "content": "    const hasArrowFunction = arrowIndex !== -1 && callbacksOnThisLine.length > 0;"
          },
          {
            "lineNum": 3296,
            "content": "    "
          },
          {
            "lineNum": 3297,
            "content": "    // Process && operators"
          },
          {
            "lineNum": 3298,
            "content": "    processIfStatementOperatorType(andMatches, '&&', 'logical AND', lineWithoutComments, lineNum, functionLine, arrowIndex, hasArrowFunction, callbacksOnThisLine, getInnermostFunction, decisionPoints);"
          },
          {
            "lineNum": 3299,
            "content": "    "
          },
          {
            "lineNum": 3300,
            "content": "    // Process || operators"
          },
          {
            "lineNum": 3301,
            "content": "    processIfStatementOperatorType(orMatches, '||', 'logical OR', lineWithoutComments, lineNum, functionLine, arrowIndex, hasArrowFunction, callbacksOnThisLine, getInnermostFunction, decisionPoints);"
          },
          {
            "lineNum": 3302,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "isTypeScriptOptionalParameter",
        "file": "scripts/decision-points.js",
        "line": 1673,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1677,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1673,
          "end": 1678
        },
        "functionCode": [
          {
            "lineNum": 1673,
            "content": "  const isTypeScriptOptionalParameter = (line, questionIndex) => {"
          },
          {
            "lineNum": 1674,
            "content": "    const contextStart = Math.max(0, questionIndex - 30);"
          },
          {
            "lineNum": 1675,
            "content": "    const contextEnd = Math.min(line.length, questionIndex + 50);"
          },
          {
            "lineNum": 1676,
            "content": "    const context = line.substring(contextStart, contextEnd);"
          },
          {
            "lineNum": 1677,
            "content": "    return /\\b[a-zA-Z_$][a-zA-Z0-9_$]*\\s*\\?\\s*:\\s*[A-Z][a-zA-Z0-9_$<>[\\]]*/.test(context);"
          },
          {
            "lineNum": 1678,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "catch callback",
        "file": "scripts/analyze-mismatches.js",
        "line": 288,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "catch",
            "line": 288,
            "name": "catch block"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 1,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 288,
          "end": 291
        },
        "functionCode": [
          {
            "lineNum": 288,
            "content": "analyzeMismatches().catch(error => {"
          },
          {
            "lineNum": 289,
            "content": "  console.error('Error analyzing mismatches:', error);"
          },
          {
            "lineNum": 290,
            "content": "  process.exit(1);"
          },
          {
            "lineNum": 291,
            "content": "});"
          }
        ]
      },
      {
        "functionName": "checkNamedArrowFunction",
        "file": "scripts/function-extraction.js",
        "line": 78,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 79,
            "name": "default parameter"
          },
          {
            "type": "ternary",
            "line": 82,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 82,
            "name": "logical AND"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 1,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 78,
          "end": 83
        },
        "functionCode": [
          {
            "lineNum": 78,
            "content": "function checkNamedArrowFunction(prevLine, currentLine) {"
          },
          {
            "lineNum": 79,
            "content": "  const combinedContext = (prevLine + ' ' + currentLine).trim();"
          },
          {
            "lineNum": 80,
            "content": "  const namedArrowPattern = /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?=>/;"
          },
          {
            "lineNum": 81,
            "content": "  const namedMatch = combinedContext.match(namedArrowPattern);"
          },
          {
            "lineNum": 82,
            "content": "  return namedMatch && namedMatch[1] ? namedMatch[1] : null;"
          },
          {
            "lineNum": 83,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "findFunctionCallCallback",
        "file": "scripts/function-extraction.js",
        "line": 114,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 116,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 116,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 116,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 114,
          "end": 123
        },
        "functionCode": [
          {
            "lineNum": 114,
            "content": "function findFunctionCallCallback(beforeArrow, filePath, lineNumber, projectRoot, lines) {"
          },
          {
            "lineNum": 115,
            "content": "  const functionCallMatch = beforeArrow.match(/(?!if|for|while|switch)\\b(\\w+)\\s*\\(/);"
          },
          {
            "lineNum": 116,
            "content": "  if (!functionCallMatch || !functionCallMatch[1]) {"
          },
          {
            "lineNum": 117,
            "content": "    return null;"
          },
          {
            "lineNum": 118,
            "content": "  }"
          },
          {
            "lineNum": 119,
            "content": "  "
          },
          {
            "lineNum": 120,
            "content": "  const callbackType = functionCallMatch[1];"
          },
          {
            "lineNum": 121,
            "content": "  const parentFunction = findParentFunctionWithFallback(filePath, lineNumber, projectRoot, lines);"
          },
          {
            "lineNum": 122,
            "content": "  return formatCallbackName(callbackType, parentFunction);"
          },
          {
            "lineNum": 123,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "funcBoundary (find callback)",
        "file": "scripts/function-hierarchy.js",
        "line": 563,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 563,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 563,
          "end": 563
        },
        "functionCode": [
          {
            "lineNum": 563,
            "content": "  return sortedFunctions.find(f => f.line === immediateParentLine) || null;"
          }
        ]
      },
      {
        "functionName": "buildCodeLineHTML",
        "file": "scripts/html-generators.js",
        "line": 1195,
        "actualComplexity": 10,
        "calculatedTotal": 11,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1196,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1197,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1198,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 1199,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 1201,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 1201,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 1201,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 1203,
            "name": "if statement"
          },
          {
            "type": "else if",
            "line": 1205,
            "name": "else if statement"
          },
          {
            "type": "||",
            "line": 1205,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 1,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 4,
          "&&": 0,
          "||": 3,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1195,
          "end": 1213
        },
        "functionCode": [
          {
            "lineNum": 1195,
            "content": "function buildCodeLineHTML(line, escapeHtml, isDecisionPoint, isFunctionStart, isFunctionClosing) {"
          },
          {
            "lineNum": 1196,
            "content": "  const lineMatch = line.match(/^(\\s*)(.*?)(\\s*)$/);"
          },
          {
            "lineNum": 1197,
            "content": "  const leadingWhitespace = lineMatch ? escapeHtml(lineMatch[1]) : '';"
          },
          {
            "lineNum": 1198,
            "content": "  const content = lineMatch ? escapeHtml(lineMatch[2]) : escapeHtml(line);"
          },
          {
            "lineNum": 1199,
            "content": "  const trailingWhitespace = lineMatch ? escapeHtml(lineMatch[3]) : '';"
          },
          {
            "lineNum": 1200,
            "content": "  "
          },
          {
            "lineNum": 1201,
            "content": "  if (isDecisionPoint || isFunctionStart || isFunctionClosing) {"
          },
          {
            "lineNum": 1202,
            "content": "    const codeLineParts = ['code-line'];"
          },
          {
            "lineNum": 1203,
            "content": "    if (isDecisionPoint) {"
          },
          {
            "lineNum": 1204,
            "content": "      codeLineParts.push('decision-point-line');"
          },
          {
            "lineNum": 1205,
            "content": "    } else if (isFunctionStart || isFunctionClosing) {"
          },
          {
            "lineNum": 1206,
            "content": "      codeLineParts.push('function-boundary-highlight');"
          },
          {
            "lineNum": 1207,
            "content": "    }"
          },
          {
            "lineNum": 1208,
            "content": "    const codeLineClass = codeLineParts.join(' ');"
          },
          {
            "lineNum": 1209,
            "content": "    return `${leadingWhitespace}<span class=\"${codeLineClass}\">${content}</span>${trailingWhitespace}`;"
          },
          {
            "lineNum": 1210,
            "content": "  }"
          },
          {
            "lineNum": 1211,
            "content": "  "
          },
          {
            "lineNum": 1212,
            "content": "  return `<span class=\"code-line\">${leadingWhitespace}${content}${trailingWhitespace}</span>`;"
          },
          {
            "lineNum": 1213,
            "content": "}"
          }
        ]
      },
      {
        "functionName": "boundary (warn callback)",
        "file": "scripts/html-generators.js",
        "line": 1053,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "if",
            "line": 1055,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1053,
          "end": 1059
        },
        "functionCode": [
          {
            "lineNum": 1053,
            "content": "          console.warn(`  Line 49 is in other function boundaries:`, line49Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
          },
          {
            "lineNum": 1054,
            "content": "        }"
          },
          {
            "lineNum": 1055,
            "content": "        if (line54Funcs.length > 0) {"
          },
          {
            "lineNum": 1056,
            "content": "          console.warn(`  Line 54 is in other function boundaries:`, line54Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
          },
          {
            "lineNum": 1057,
            "content": "        }"
          },
          {
            "lineNum": 1058,
            "content": "      }"
          },
          {
            "lineNum": 1059,
            "content": "    }"
          }
        ]
      },
      {
        "functionName": "withinThreshold (max callback)",
        "file": "scripts/html-generators.js",
        "line": 1099,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1099,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1099,
          "end": 1099
        },
        "functionCode": [
          {
            "lineNum": 1099,
            "content": "  const maxComplexity = functions.length > 0 ? Math.max(...functions.map(f => parseInt(f.complexity))) : 0;"
          }
        ]
      },
      {
        "functionName": "maxComplexity (round callback)",
        "file": "scripts/html-generators.js",
        "line": 1100,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 1100,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1100,
          "end": 1100
        },
        "functionCode": [
          {
            "lineNum": 1100,
            "content": "  const avgComplexity = functions.length > 0 ? Math.round(functions.reduce((sum, f) => sum + parseInt(f.complexity), 0) / functions.length) : 0;"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/Header/index.tsx",
        "line": 246,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 246,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 246,
          "end": 246
        },
        "functionCode": [
          {
            "lineNum": 246,
            "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#experience\")}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/Header/index.tsx",
        "line": 256,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 256,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 256,
          "end": 256
        },
        "functionCode": [
          {
            "lineNum": 256,
            "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#projects\")}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/Header/index.tsx",
        "line": 266,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 266,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 266,
          "end": 266
        },
        "functionCode": [
          {
            "lineNum": 266,
            "content": "                onClick={(e) => handleMenuLinkClick(e, \"/resources/blog\")}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/Header/index.tsx",
        "line": 276,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 276,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 276,
          "end": 276
        },
        "functionCode": [
          {
            "lineNum": 276,
            "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#contact\")}"
          }
        ]
      },
      {
        "functionName": "PresetSection (map callback)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 325,
        "actualComplexity": 4,
        "calculatedTotal": 5,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 337,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 338,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 339,
            "name": "logical AND"
          },
          {
            "type": "default parameter",
            "line": 342,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 3,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 325,
          "end": 356
        },
        "functionCode": [
          {
            "lineNum": 325,
            "content": "        {presets.map((preset) => {"
          },
          {
            "lineNum": 326,
            "content": "          const isBuiltIn = isBuiltInPreset(preset.id);"
          },
          {
            "lineNum": 327,
            "content": "          const showEasterEgg = hasAudioEasterEgg(preset.id);"
          },
          {
            "lineNum": 328,
            "content": "          const isSelected = preset.id === currentPresetId;"
          },
          {
            "lineNum": 329,
            "content": "          return ("
          },
          {
            "lineNum": 330,
            "content": "            <div key={preset.id} className={styles.presetButtonWrapper}>"
          },
          {
            "lineNum": 331,
            "content": "              <button"
          },
          {
            "lineNum": 332,
            "content": "                className={styles.presetButton}"
          },
          {
            "lineNum": 333,
            "content": "                onClick={() => onLoadPreset(preset.id)}"
          },
          {
            "lineNum": 334,
            "content": "              >"
          },
          {
            "lineNum": 335,
            "content": "                <span className={styles.presetName}>{preset.name}</span>"
          },
          {
            "lineNum": 336,
            "content": "                <div className={styles.presetIconContainer}>"
          },
          {
            "lineNum": 337,
            "content": "                  {showEasterEgg && <Music size={16} className={styles.presetIcon} />}"
          },
          {
            "lineNum": 338,
            "content": "                  {isSelected && <Pin size={16} className={styles.presetIcon} fill=\"currentColor\" />}"
          },
          {
            "lineNum": 339,
            "content": "                  {!isBuiltIn && ("
          },
          {
            "lineNum": 340,
            "content": "                    <button"
          },
          {
            "lineNum": 341,
            "content": "                      className={styles.deletePresetBtn}"
          },
          {
            "lineNum": 342,
            "content": "                      onClick={(e) => {"
          },
          {
            "lineNum": 343,
            "content": "                        e.stopPropagation();"
          },
          {
            "lineNum": 344,
            "content": "                        onDeletePreset(preset.id, e);"
          },
          {
            "lineNum": 345,
            "content": "                      }}"
          },
          {
            "lineNum": 346,
            "content": "                      aria-label={`Delete ${preset.name} preset`}"
          },
          {
            "lineNum": 347,
            "content": "                      title=\"Delete preset\""
          },
          {
            "lineNum": 348,
            "content": "                    >"
          },
          {
            "lineNum": 349,
            "content": "                      <Trash2 size={14} />"
          },
          {
            "lineNum": 350,
            "content": "                    </button>"
          },
          {
            "lineNum": 351,
            "content": "                  )}"
          },
          {
            "lineNum": 352,
            "content": "                </div>"
          },
          {
            "lineNum": 353,
            "content": "              </button>"
          },
          {
            "lineNum": 354,
            "content": "            </div>"
          },
          {
            "lineNum": 355,
            "content": "          );"
          },
          {
            "lineNum": 356,
            "content": "        })}"
          }
        ]
      },
      {
        "functionName": "ColorItem (arrow function)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 105,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 105,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 105,
          "end": 105
        },
        "functionCode": [
          {
            "lineNum": 105,
            "content": "        onChange={(e) => onColorChange(token.key, e.target.value)}"
          }
        ]
      },
      {
        "functionName": "ColorItem (arrow function)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 110,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 110,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 110,
          "end": 110
        },
        "functionCode": [
          {
            "lineNum": 110,
            "content": "          onClick={() => onCancel(token.key)}"
          }
        ]
      },
      {
        "functionName": "PresetSection (arrow function)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 314,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 314,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 314,
          "end": 317
        },
        "functionCode": [
          {
            "lineNum": 314,
            "content": "          onClick={(e) => {"
          },
          {
            "lineNum": 315,
            "content": "            e.stopPropagation();"
          },
          {
            "lineNum": 316,
            "content": "            onToggleExpanded();"
          },
          {
            "lineNum": 317,
            "content": "          }}"
          }
        ]
      },
      {
        "functionName": "PresetSection (arrow function)",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 333,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 333,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 333,
          "end": 333
        },
        "functionCode": [
          {
            "lineNum": 333,
            "content": "                onClick={() => onLoadPreset(preset.id)}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/components/ThemePicker/ThemePicker.tsx",
        "line": 372,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 372,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 372,
          "end": 372
        },
        "functionCode": [
          {
            "lineNum": 372,
            "content": "                onChange={(e) => onPresetNameChange(e.target.value)}"
          }
        ]
      },
      {
        "functionName": "useCallback callback",
        "file": "src/context/ThemeContext.tsx",
        "line": 140,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "||",
            "line": 141,
            "name": "logical OR"
          },
          {
            "type": "default parameter",
            "line": 142,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 140,
          "end": 151
        },
        "functionCode": [
          {
            "lineNum": 140,
            "content": "  const savePreset = useCallback((name: string, themeToSave?: Theme) => {"
          },
          {
            "lineNum": 141,
            "content": "    const themeForPreset = themeToSave || theme;"
          },
          {
            "lineNum": 142,
            "content": "    const newPreset: Preset = {"
          },
          {
            "lineNum": 143,
            "content": "      id: `custom-${Date.now()}`,"
          },
          {
            "lineNum": 144,
            "content": "      name,"
          },
          {
            "lineNum": 145,
            "content": "      theme: { ...themeForPreset },"
          },
          {
            "lineNum": 146,
            "content": "    };"
          },
          {
            "lineNum": 147,
            "content": "    const customPresets = presets.filter((p) => !builtInPresets.find((bp) => bp.id === p.id));"
          },
          {
            "lineNum": 148,
            "content": "    const updated = [...builtInPresets, ...customPresets, newPreset];"
          },
          {
            "lineNum": 149,
            "content": "    setPresets(updated);"
          },
          {
            "lineNum": 150,
            "content": "    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(customPresets.concat(newPreset)));"
          },
          {
            "lineNum": 151,
            "content": "  }, [theme, presets]);"
          }
        ]
      },
      {
        "functionName": "BlogFilters (arrow function)",
        "file": "src/sections/BlogFilters/index.tsx",
        "line": 63,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 63,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 63,
          "end": 63
        },
        "functionCode": [
          {
            "lineNum": 63,
            "content": "            onChange={(e) => setSelectedCategory(e.target.value)}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/BlogFilters/index.tsx",
        "line": 83,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 83,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 83,
          "end": 83
        },
        "functionCode": [
          {
            "lineNum": 83,
            "content": "          onChange={(e) => setSearchQuery(e.target.value)}"
          }
        ]
      },
      {
        "functionName": "matchHeights (arrow function)",
        "file": "src/sections/FeatureAccordion/index.tsx",
        "line": 160,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 160,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 160,
          "end": 160
        },
        "functionCode": [
          {
            "lineNum": 160,
            "content": "                        onClick={() => setActiveId(item.id)}"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/FeatureAccordion/index.tsx",
        "line": 209,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 209,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 209,
          "end": 209
        },
        "functionCode": [
          {
            "lineNum": 209,
            "content": "                      onChange={() => setActiveId(item.id)}"
          }
        ]
      },
      {
        "functionName": "max callback",
        "file": "scripts/generate-complexity-report.js",
        "line": 33,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 33,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 33,
          "end": 33
        },
        "functionCode": [
          {
            "lineNum": 33,
            "content": "const maxComplexity = allFunctions.length > 0 ? Math.max(...allFunctions.map(i => parseInt(i.complexity))) : 0;"
          }
        ]
      },
      {
        "functionName": "round callback",
        "file": "scripts/generate-complexity-report.js",
        "line": 34,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 34,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 34,
          "end": 34
        },
        "functionCode": [
          {
            "lineNum": 34,
            "content": "const avgComplexity = allFunctions.length > 0 ? Math.round(allFunctions.reduce((sum, i) => sum + parseInt(i.complexity), 0) / allFunctions.length) : 0;"
          }
        ]
      },
      {
        "functionName": "map callback",
        "file": "src/sections/AgencyLogos/index.tsx",
        "line": 213,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 217,
            "name": "ternary operator"
          },
          {
            "type": "default parameter",
            "line": 220,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 213,
          "end": 222
        },
        "functionCode": [
          {
            "lineNum": 213,
            "content": "          {scrollSnaps.map((_, index) => ("
          },
          {
            "lineNum": 214,
            "content": "            <button"
          },
          {
            "lineNum": 215,
            "content": "              key={index}"
          },
          {
            "lineNum": 216,
            "content": "              className={`${styles.dot} ${"
          },
          {
            "lineNum": 217,
            "content": "                index === selectedIndex ? styles.dotActive : \"\""
          },
          {
            "lineNum": 218,
            "content": "              }`}"
          },
          {
            "lineNum": 219,
            "content": "              onClick={() => scrollTo(index)}"
          },
          {
            "lineNum": 220,
            "content": "              aria-label={`Go to slide ${index + 1}`}"
          },
          {
            "lineNum": 221,
            "content": "            />"
          },
          {
            "lineNum": 222,
            "content": "          ))}"
          }
        ]
      },
      {
        "functionName": "AgencyLogosComponent",
        "file": "src/sections/AgencyLogos/index.tsx",
        "line": 24,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 181,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 24,
          "end": 232
        },
        "functionCode": [
          {
            "lineNum": 24,
            "content": "function AgencyLogosComponent() {"
          },
          {
            "lineNum": 25,
            "content": "  const [emblaRef, emblaApi] = useEmblaCarousel({"
          },
          {
            "lineNum": 26,
            "content": "    loop: true,"
          },
          {
            "lineNum": 27,
            "content": "    align: \"start\","
          },
          {
            "lineNum": 28,
            "content": "    dragFree: true,"
          },
          {
            "lineNum": 29,
            "content": "    skipSnaps: false,"
          },
          {
            "lineNum": 30,
            "content": "    containScroll: \"trimSnaps\","
          },
          {
            "lineNum": 31,
            "content": "  });"
          },
          {
            "lineNum": 32,
            "content": "  const [selectedIndex, setSelectedIndex] = useState(0);"
          },
          {
            "lineNum": 33,
            "content": "  const [scrollSnaps, setScrollSnaps] = useState<number[]>([]);"
          },
          {
            "lineNum": 34,
            "content": "  const [autoplayEnabled, setAutoplayEnabled] = useState(true);"
          },
          {
            "lineNum": 35,
            "content": "  const viewportRef = useRef<HTMLDivElement>(null);"
          },
          {
            "lineNum": 36,
            "content": ""
          },
          {
            "lineNum": 37,
            "content": "  const scrollTo = useCallback("
          },
          {
            "lineNum": 38,
            "content": "    (index: number) => {"
          },
          {
            "lineNum": 39,
            "content": "      if (emblaApi) {"
          },
          {
            "lineNum": 40,
            "content": "        setAutoplayEnabled(false); // Stop autoplay on user interaction"
          },
          {
            "lineNum": 41,
            "content": "        emblaApi.scrollTo(index);"
          },
          {
            "lineNum": 42,
            "content": "      }"
          },
          {
            "lineNum": 43,
            "content": "    },"
          },
          {
            "lineNum": 44,
            "content": "    [emblaApi]"
          },
          {
            "lineNum": 45,
            "content": "  );"
          },
          {
            "lineNum": 46,
            "content": ""
          },
          {
            "lineNum": 47,
            "content": "  const onSelect = useCallback(() => {"
          },
          {
            "lineNum": 48,
            "content": "    if (!emblaApi) return;"
          },
          {
            "lineNum": 49,
            "content": "    setSelectedIndex(emblaApi.selectedScrollSnap());"
          },
          {
            "lineNum": 50,
            "content": "  }, [emblaApi]);"
          },
          {
            "lineNum": 51,
            "content": ""
          },
          {
            "lineNum": 52,
            "content": "  // Store onSelect in ref so effect only depends on emblaApi"
          },
          {
            "lineNum": 53,
            "content": "  const onSelectRef = useRef(onSelect);"
          },
          {
            "lineNum": 54,
            "content": "  useEffect(() => {"
          },
          {
            "lineNum": 55,
            "content": "    onSelectRef.current = onSelect;"
          },
          {
            "lineNum": 56,
            "content": "  }, [onSelect]);"
          },
          {
            "lineNum": 57,
            "content": ""
          },
          {
            "lineNum": 58,
            "content": "  // Track handlers for each emblaApi instance using a Map"
          },
          {
            "lineNum": 59,
            "content": "  const handlersMapRef = useRef<Map<typeof emblaApi, {"
          },
          {
            "lineNum": 60,
            "content": "    onSelect: () => void;"
          },
          {
            "lineNum": 61,
            "content": "    handleReInit: () => void;"
          },
          {
            "lineNum": 62,
            "content": "    handlePointerDown: () => void;"
          },
          {
            "lineNum": 63,
            "content": "  }>>(new Map());"
          },
          {
            "lineNum": 64,
            "content": ""
          },
          {
            "lineNum": 65,
            "content": "  // Track previous emblaApi for cleanup"
          },
          {
            "lineNum": 66,
            "content": "  const prevEmblaApiRef = useRef<typeof emblaApi>(null);"
          },
          {
            "lineNum": 67,
            "content": ""
          },
          {
            "lineNum": 68,
            "content": "  // Cleanup previous emblaApi when it changes (runs synchronously before main effect)"
          },
          {
            "lineNum": 69,
            "content": "  useLayoutEffect(() => {"
          },
          {
            "lineNum": 70,
            "content": "    const prevApi = prevEmblaApiRef.current;"
          },
          {
            "lineNum": 71,
            "content": "    if (prevApi && prevApi !== emblaApi) {"
          },
          {
            "lineNum": 72,
            "content": "      const prevHandlers = handlersMapRef.current.get(prevApi);"
          },
          {
            "lineNum": 73,
            "content": "      if (prevHandlers) {"
          }
        ]
      },
      {
        "functionName": "anonymous arrow function",
        "file": "src/sections/AgencyLogos/index.tsx",
        "line": 219,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 219,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 219,
          "end": 219
        },
        "functionCode": [
          {
            "lineNum": 219,
            "content": "              onClick={() => scrollTo(index)}"
          }
        ]
      },
      {
        "functionName": "onScroll (arrow function)",
        "file": "src/sections/TopBanner/index.tsx",
        "line": 63,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 63,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 63,
          "end": 63
        },
        "functionCode": [
          {
            "lineNum": 63,
            "content": "          onClick={() => setIsVisible(false)}"
          }
        ]
      },
      {
        "functionName": "CustomerSpotlight",
        "file": "src/sections/CustomerSpotlight/index.tsx",
        "line": 34,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 55,
            "name": "ternary operator"
          },
          {
            "type": "||",
            "line": 58,
            "name": "logical OR"
          },
          {
            "type": "default parameter",
            "line": 80,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 34,
          "end": 109
        },
        "functionCode": [
          {
            "lineNum": 34,
            "content": "export function CustomerSpotlight() {"
          },
          {
            "lineNum": 35,
            "content": ""
          },
          {
            "lineNum": 36,
            "content": "  const [selectedIndex, setSelectedIndex] = useState(0);"
          },
          {
            "lineNum": 37,
            "content": ""
          },
          {
            "lineNum": 38,
            "content": "  const scrollPrev = () => {"
          },
          {
            "lineNum": 39,
            "content": "    setSelectedIndex((prev) => (prev === 0 ? testimonials.length - 1 : prev - 1));"
          },
          {
            "lineNum": 40,
            "content": "  };"
          },
          {
            "lineNum": 41,
            "content": ""
          },
          {
            "lineNum": 42,
            "content": "  const scrollNext = () => {"
          },
          {
            "lineNum": 43,
            "content": "    setSelectedIndex((prev) => (prev === testimonials.length - 1 ? 0 : prev + 1));"
          },
          {
            "lineNum": 44,
            "content": "  };"
          },
          {
            "lineNum": 45,
            "content": ""
          },
          {
            "lineNum": 46,
            "content": "  const currentTestimonial = testimonials[selectedIndex];"
          },
          {
            "lineNum": 47,
            "content": ""
          },
          {
            "lineNum": 48,
            "content": "  return ("
          },
          {
            "lineNum": 49,
            "content": "    <Section variant=\"alt\">"
          },
          {
            "lineNum": 50,
            "content": "      <Container className={styles.referencesContainer}>"
          },
          {
            "lineNum": 51,
            "content": "        <h2 className={styles.heading}>References</h2>"
          },
          {
            "lineNum": 52,
            "content": "        <div className={styles.wrapper}>"
          },
          {
            "lineNum": 53,
            "content": "          <div className={styles.image}>"
          },
          {
            "lineNum": 54,
            "content": "            <div className={styles.imageContainer}>"
          },
          {
            "lineNum": 55,
            "content": "              {currentTestimonial.image ? ("
          },
          {
            "lineNum": 56,
            "content": "                <img"
          },
          {
            "lineNum": 57,
            "content": "                  src={currentTestimonial.image}"
          },
          {
            "lineNum": 58,
            "content": "                  alt={currentTestimonial.alt || currentTestimonial.author}"
          },
          {
            "lineNum": 59,
            "content": "                  className={styles.imageContent}"
          },
          {
            "lineNum": 60,
            "content": "                />"
          },
          {
            "lineNum": 61,
            "content": "              ) : ("
          },
          {
            "lineNum": 62,
            "content": "                <span className={styles.placeholderText}>Image</span>"
          },
          {
            "lineNum": 63,
            "content": "              )}"
          },
          {
            "lineNum": 64,
            "content": "            </div>"
          },
          {
            "lineNum": 65,
            "content": "          </div>"
          },
          {
            "lineNum": 66,
            "content": "          <div className={styles.quote}>"
          },
          {
            "lineNum": 67,
            "content": "            <div className={styles.quoteContent}>"
          },
          {
            "lineNum": 68,
            "content": "              <blockquote className={styles.blockquote}>"
          },
          {
            "lineNum": 69,
            "content": "                \"{currentTestimonial.quote}\""
          },
          {
            "lineNum": 70,
            "content": "              </blockquote>"
          },
          {
            "lineNum": 71,
            "content": "              <div className={styles.quoteAuthor}>"
          },
          {
            "lineNum": 72,
            "content": "                <div className={styles.authorName}>{currentTestimonial.author}</div>"
          },
          {
            "lineNum": 73,
            "content": "                <div className={styles.authorRole}>{currentTestimonial.role}</div>"
          },
          {
            "lineNum": 74,
            "content": "              </div>"
          },
          {
            "lineNum": 75,
            "content": "            </div>"
          },
          {
            "lineNum": 76,
            "content": "            <div className={styles.controls}>"
          },
          {
            "lineNum": 77,
            "content": "              <button"
          },
          {
            "lineNum": 78,
            "content": "                className={styles.arrow}"
          },
          {
            "lineNum": 79,
            "content": "                onClick={scrollPrev}"
          },
          {
            "lineNum": 80,
            "content": "                aria-label=\"Previous testimonial\""
          },
          {
            "lineNum": 81,
            "content": "              >"
          },
          {
            "lineNum": 82,
            "content": "                <ChevronLeft size={24} />"
          },
          {
            "lineNum": 83,
            "content": "              </button>"
          }
        ]
      },
      {
        "functionName": "scrollNext (map callback)",
        "file": "src/sections/CustomerSpotlight/index.tsx",
        "line": 85,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 89,
            "name": "ternary operator"
          },
          {
            "type": "default parameter",
            "line": 92,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 85,
          "end": 94
        },
        "functionCode": [
          {
            "lineNum": 85,
            "content": "                {testimonials.map((_, index) => ("
          },
          {
            "lineNum": 86,
            "content": "                  <button"
          },
          {
            "lineNum": 87,
            "content": "                    key={index}"
          },
          {
            "lineNum": 88,
            "content": "                    className={`${styles.dot} ${"
          },
          {
            "lineNum": 89,
            "content": "                      index === selectedIndex ? styles.dotActive : \"\""
          },
          {
            "lineNum": 90,
            "content": "                    }`}"
          },
          {
            "lineNum": 91,
            "content": "                    onClick={() => setSelectedIndex(index)}"
          },
          {
            "lineNum": 92,
            "content": "                    aria-label={`Go to testimonial ${index + 1}`}"
          },
          {
            "lineNum": 93,
            "content": "                  />"
          },
          {
            "lineNum": 94,
            "content": "                ))}"
          }
        ]
      },
      {
        "functionName": "scrollNext (arrow function)",
        "file": "src/sections/CustomerSpotlight/index.tsx",
        "line": 91,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 91,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 91,
          "end": 91
        },
        "functionCode": [
          {
            "lineNum": 91,
            "content": "                    onClick={() => setSelectedIndex(index)}"
          }
        ]
      },
      {
        "functionName": "CampaignBanner",
        "file": "src/sections/CampaignBanner/index.tsx",
        "line": 8,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "ternary",
            "line": 22,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 8,
          "end": 59
        },
        "functionCode": [
          {
            "lineNum": 8,
            "content": "export function CampaignBanner() {"
          },
          {
            "lineNum": 9,
            "content": "  const { currentPresetId } = useTheme();"
          },
          {
            "lineNum": 10,
            "content": "  const isNoirTheme = currentPresetId === 'noir';"
          },
          {
            "lineNum": 11,
            "content": ""
          },
          {
            "lineNum": 12,
            "content": "  return ("
          },
          {
            "lineNum": 13,
            "content": "    <Section className={styles.banner} id=\"contact\">"
          },
          {
            "lineNum": 14,
            "content": "      <Container className={styles.contactContainer}>"
          },
          {
            "lineNum": 15,
            "content": "        <div className={styles.wrapper}>"
          },
          {
            "lineNum": 16,
            "content": "          <div className={styles.content}>"
          },
          {
            "lineNum": 17,
            "content": "            <h2 className={styles.heading}>"
          },
          {
            "lineNum": 18,
            "content": "              Let's{\" \"}"
          },
          {
            "lineNum": 19,
            "content": "              <span className={styles.accent}>Connect</span>"
          },
          {
            "lineNum": 20,
            "content": "            </h2>"
          },
          {
            "lineNum": 21,
            "content": "            <p className={styles.text}>"
          },
          {
            "lineNum": 22,
            "content": "              Interested in working together? Reach out via{\" \"}"
          },
          {
            "lineNum": 23,
            "content": "              <a href=\"mailto:JHJonathanHammond@gmail.com\" className={styles.link}>"
          },
          {
            "lineNum": 24,
            "content": "                email"
          },
          {
            "lineNum": 25,
            "content": "              </a>"
          },
          {
            "lineNum": 26,
            "content": "              {\" \"}or connect on{\" \"}"
          },
          {
            "lineNum": 27,
            "content": "              <a "
          },
          {
            "lineNum": 28,
            "content": "                href=\"https://www.linkedin.com/in/jonamichahammo\" "
          },
          {
            "lineNum": 29,
            "content": "                target=\"_blank\" "
          },
          {
            "lineNum": 30,
            "content": "                rel=\"noopener noreferrer\""
          },
          {
            "lineNum": 31,
            "content": "                className={styles.link}"
          },
          {
            "lineNum": 32,
            "content": "              >"
          },
          {
            "lineNum": 33,
            "content": "                LinkedIn"
          },
          {
            "lineNum": 34,
            "content": "              </a>"
          },
          {
            "lineNum": 35,
            "content": "              {\" \"}to discuss opportunities."
          },
          {
            "lineNum": 36,
            "content": "            </p>"
          },
          {
            "lineNum": 37,
            "content": "            <div className={styles.cta}>"
          },
          {
            "lineNum": 38,
            "content": "              <a "
          },
          {
            "lineNum": 39,
            "content": "                href=\"/JonathanHammondResume.pdf\" "
          },
          {
            "lineNum": 40,
            "content": "                download=\"Jonathan-Hammond-Resume.pdf\""
          },
          {
            "lineNum": 41,
            "content": "                className={buttonStyles.primary}"
          },
          {
            "lineNum": 42,
            "content": "              >"
          },
          {
            "lineNum": 43,
            "content": "                Download Resume"
          },
          {
            "lineNum": 44,
            "content": "              </a>"
          },
          {
            "lineNum": 45,
            "content": "            </div>"
          },
          {
            "lineNum": 46,
            "content": "          </div>"
          },
          {
            "lineNum": 47,
            "content": "          <div className={styles.image}>"
          },
          {
            "lineNum": 48,
            "content": "            <img "
          },
          {
            "lineNum": 49,
            "content": "              src=\"/Jonathan_Hammond.webp\" "
          },
          {
            "lineNum": 50,
            "content": "              alt=\"Jonathan Hammond\""
          },
          {
            "lineNum": 51,
            "content": "              className={styles.imageContent}"
          },
          {
            "lineNum": 52,
            "content": "              style={{ filter: getGrayscaleFilter(isNoirTheme) }}"
          },
          {
            "lineNum": 53,
            "content": "            />"
          },
          {
            "lineNum": 54,
            "content": "          </div>"
          },
          {
            "lineNum": 55,
            "content": "        </div>"
          },
          {
            "lineNum": 56,
            "content": "      </Container>"
          },
          {
            "lineNum": 57,
            "content": "    </Section>"
          }
        ]
      },
      {
        "functionName": "Footer (map callback)",
        "file": "src/sections/Footer/index.tsx",
        "line": 52,
        "actualComplexity": 1,
        "calculatedTotal": 2,
        "difference": 1,
        "category": "over-counting",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 59,
            "name": "default parameter"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 52,
          "end": 65
        },
        "functionCode": [
          {
            "lineNum": 52,
            "content": "              {socialLinks.map((social) => {"
          },
          {
            "lineNum": 53,
            "content": "                const Icon = social.icon;"
          },
          {
            "lineNum": 54,
            "content": "                return ("
          },
          {
            "lineNum": 55,
            "content": "                  <a"
          },
          {
            "lineNum": 56,
            "content": "                    key={social.label}"
          },
          {
            "lineNum": 57,
            "content": "                    href={social.href}"
          },
          {
            "lineNum": 58,
            "content": "                    className={styles.socialLink}"
          },
          {
            "lineNum": 59,
            "content": "                    aria-label={social.label}"
          },
          {
            "lineNum": 60,
            "content": "                    target=\"_blank\""
          },
          {
            "lineNum": 61,
            "content": "                  >"
          },
          {
            "lineNum": 62,
            "content": "                    <Icon size={20} />"
          },
          {
            "lineNum": 63,
            "content": "                  </a>"
          },
          {
            "lineNum": 64,
            "content": "                );"
          },
          {
            "lineNum": 65,
            "content": "              })}"
          }
        ]
      }
    ],
    "forEach callback": [
      {
        "functionName": "formatComplexityBreakdownInline (forEach callback)",
        "file": "scripts/complexity-breakdown.js",
        "line": 91,
        "actualComplexity": 9,
        "calculatedTotal": 13,
        "difference": 4,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "||",
            "line": 92,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 93,
            "name": "if statement"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 96,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 96,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 96,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 96,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 96,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 6,
          "&&": 2,
          "||": 3,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 91,
          "end": 99
        },
        "functionCode": [
          {
            "lineNum": 91,
            "content": "  typeOrder.forEach(type => {"
          },
          {
            "lineNum": 92,
            "content": "    const count = breakdown[type] || 0;"
          },
          {
            "lineNum": 93,
            "content": "    if (count > 0) {"
          },
          {
            "lineNum": 94,
            "content": "      // Use ESLint symbols: ?: for ternary, && for AND, || for OR, ?? for nullish coalescing, ?. for optional chaining"
          },
          {
            "lineNum": 95,
            "content": "      // For default parameters, use \"default param\" as the display symbol"
          },
          {
            "lineNum": 96,
            "content": "      const symbol = type === 'ternary' ? '?:' : type === '&&' ? '&&' : type === '||' ? '||' : type === '??' ? '??' : type === '?.' ? '?.' : type === 'default parameter' ? 'default param' : type;"
          },
          {
            "lineNum": 97,
            "content": "      parts.push(`+${count} ${symbol}`);"
          },
          {
            "lineNum": 98,
            "content": "    }"
          },
          {
            "lineNum": 99,
            "content": "  });"
          }
        ]
      },
      {
        "functionName": "formatComplexityBreakdownStyled (forEach callback)",
        "file": "scripts/complexity-breakdown.js",
        "line": 123,
        "actualComplexity": 9,
        "calculatedTotal": 13,
        "difference": 4,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "||",
            "line": 124,
            "name": "logical OR"
          },
          {
            "type": "if",
            "line": 125,
            "name": "if statement"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 128,
            "name": "ternary operator"
          },
          {
            "type": "&&",
            "line": 128,
            "name": "logical AND"
          },
          {
            "type": "&&",
            "line": 128,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 128,
            "name": "logical OR"
          },
          {
            "type": "||",
            "line": 128,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 6,
          "&&": 2,
          "||": 3,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 123,
          "end": 131
        },
        "functionCode": [
          {
            "lineNum": 123,
            "content": "  typeOrder.forEach(type => {"
          },
          {
            "lineNum": 124,
            "content": "    const count = breakdown[type] || 0;"
          },
          {
            "lineNum": 125,
            "content": "    if (count > 0) {"
          },
          {
            "lineNum": 126,
            "content": "      // Use ESLint symbols: ?: for ternary, && for AND, || for OR, ?? for nullish coalescing, ?. for optional chaining"
          },
          {
            "lineNum": 127,
            "content": "      // For default parameters, use \"default param\" as the display symbol"
          },
          {
            "lineNum": 128,
            "content": "      const symbol = type === 'ternary' ? '?:' : type === '&&' ? '&&' : type === '||' ? '||' : type === '??' ? '??' : type === '?.' ? '?.' : type === 'default parameter' ? 'default param' : type;"
          },
          {
            "lineNum": 129,
            "content": "      parts.push(`${symbol} <span class=\"complexity-number\">${count}</span>`);"
          },
          {
            "lineNum": 130,
            "content": "    }"
          },
          {
            "lineNum": 131,
            "content": "  });"
          }
        ]
      },
      {
        "functionName": "findFunctionBoundaries (forEach callback)",
        "file": "scripts/function-boundaries.js",
        "line": 1035,
        "actualComplexity": 9,
        "calculatedTotal": 7,
        "difference": -2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "||",
            "line": 1037,
            "name": "logical OR"
          },
          {
            "type": "ternary",
            "line": 1041,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 1056,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1065,
            "name": "if statement"
          },
          {
            "type": "if",
            "line": 1080,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 1080,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 3,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 1,
          "&&": 0,
          "||": 2,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 1035,
          "end": 1088
        },
        "functionCode": [
          {
            "lineNum": 1035,
            "content": "  functions.forEach(func => {"
          },
          {
            "lineNum": 1036,
            "content": "    const functionLine = func.line;"
          },
          {
            "lineNum": 1037,
            "content": "    const nodeType = func.nodeType || 'FunctionDeclaration';"
          },
          {
            "lineNum": 1038,
            "content": "    "
          },
          {
            "lineNum": 1039,
            "content": "    // Find the start line"
          },
          {
            "lineNum": 1040,
            "content": "    const start = nodeType === 'ArrowFunctionExpression'"
          },
          {
            "lineNum": 1041,
            "content": "      ? findArrowFunctionStart(lines, functionLine)"
          },
          {
            "lineNum": 1042,
            "content": "      : findNamedFunctionStart(lines, functionLine, func.functionName);"
          },
          {
            "lineNum": 1043,
            "content": "    "
          },
          {
            "lineNum": 1044,
            "content": "    let end = functionLine;"
          },
          {
            "lineNum": 1045,
            "content": "    "
          },
          {
            "lineNum": 1046,
            "content": "    // Find the end of the function by tracking braces"
          },
          {
            "lineNum": 1047,
            "content": "    // For arrow functions, start tracking from the arrow function's body"
          },
          {
            "lineNum": 1048,
            "content": "    // For TypeScript functions, we need to skip type definition braces and only track function body braces"
          },
          {
            "lineNum": 1049,
            "content": "    let braceCount = 0;"
          },
          {
            "lineNum": 1050,
            "content": "    let inFunctionBody = false;"
          },
          {
            "lineNum": 1051,
            "content": "    let typeBraceCount = 0; // Track type definition braces separately"
          },
          {
            "lineNum": 1052,
            "content": "    let arrowFunctionEndSet = false; // Track if we've set the end for an arrow function (object literal case)"
          },
          {
            "lineNum": 1053,
            "content": "    let arrowFunctionHandled = false;"
          },
          {
            "lineNum": 1054,
            "content": "    "
          },
          {
            "lineNum": 1055,
            "content": "    // For arrow functions, use the dedicated helper function"
          },
          {
            "lineNum": 1056,
            "content": "    if (nodeType === 'ArrowFunctionExpression') {"
          },
          {
            "lineNum": 1057,
            "content": "      const arrowResult = findArrowFunctionEnd(lines, start, functionLine, boundaries);"
          },
          {
            "lineNum": 1058,
            "content": "      end = arrowResult.end;"
          },
          {
            "lineNum": 1059,
            "content": "      arrowFunctionHandled = arrowResult.arrowFunctionHandled;"
          },
          {
            "lineNum": 1060,
            "content": "      arrowFunctionEndSet = arrowResult.arrowFunctionEndSet;"
          },
          {
            "lineNum": 1061,
            "content": "      inFunctionBody = arrowResult.inFunctionBody;"
          },
          {
            "lineNum": 1062,
            "content": "      braceCount = arrowResult.braceCount;"
          },
          {
            "lineNum": 1063,
            "content": "      "
          },
          {
            "lineNum": 1064,
            "content": "      // If the arrow function end was already set (e.g., object literal, JSX return), skip rest"
          },
          {
            "lineNum": 1065,
            "content": "      if (arrowFunctionEndSet) {"
          },
          {
            "lineNum": 1066,
            "content": "        // Boundary already set, skip to next function"
          },
          {
            "lineNum": 1067,
            "content": "        return;"
          },
          {
            "lineNum": 1068,
            "content": "      }"
          },
          {
            "lineNum": 1069,
            "content": "    }"
          },
          {
            "lineNum": 1070,
            "content": "    "
          },
          {
            "lineNum": 1071,
            "content": "    // Now find the end of the function body"
          },
          {
            "lineNum": 1072,
            "content": "    // Skip if arrow function was already handled (with or without braces, including object literals)"
          },
          {
            "lineNum": 1073,
            "content": "    // If we've set the end for an arrow function (object literal case), skip the rest"
          },
          {
            "lineNum": 1074,
            "content": "    if (!arrowFunctionEndSet) {"
          },
          {
            "lineNum": 1075,
            "content": "      end = findNamedFunctionEnd(lines, start, functionLine, arrowFunctionHandled, inFunctionBody, braceCount);"
          },
          {
            "lineNum": 1076,
            "content": "    }"
          },
          {
            "lineNum": 1077,
            "content": "    "
          },
          {
            "lineNum": 1078,
            "content": "    // Fallback: if we couldn't find the end, use a reasonable default"
          },
          {
            "lineNum": 1079,
            "content": "    // Also fallback if we never entered the function body (might be a type-only function or parsing issue)"
          },
          {
            "lineNum": 1080,
            "content": "    if (end === functionLine || !inFunctionBody) {"
          },
          {
            "lineNum": 1081,
            "content": "      end = findFunctionEndFallback(lines, start, functionLine);"
          },
          {
            "lineNum": 1082,
            "content": "    }"
          },
          {
            "lineNum": 1083,
            "content": "    "
          },
          {
            "lineNum": 1084,
            "content": "    // Only set boundary if we haven't already set it (e.g., for object literal arrow functions)"
          }
        ]
      },
      {
        "functionName": "processTernaryLogicalOperators (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 2384,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 2384,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 2385,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2384,
          "end": 2386
        },
        "functionCode": [
          {
            "lineNum": 2384,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 2385,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 2386,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processPreviousLineLogicalOperators (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 2402,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 2402,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 2403,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 2402,
          "end": 2404
        },
        "functionCode": [
          {
            "lineNum": 2402,
            "content": "    if (prevAndMatches) prevAndMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 2403,
            "content": "    if (prevOrMatches) prevOrMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 2404,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processMultiLineConditionOperators (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 3065,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3065,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 3066,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3065,
          "end": 3067
        },
        "functionCode": [
          {
            "lineNum": 3065,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3066,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3067,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processLoopLogicalOperators (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 3348,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3348,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 3349,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3348,
          "end": 3350
        },
        "functionCode": [
          {
            "lineNum": 3348,
            "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3349,
            "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3350,
            "content": "  };"
          }
        ]
      },
      {
        "functionName": "processSwitchAndCatch (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 3406,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3406,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 3407,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3406,
          "end": 3409
        },
        "functionCode": [
          {
            "lineNum": 3406,
            "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3407,
            "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3408,
            "content": "      return;"
          },
          {
            "lineNum": 3409,
            "content": "    }"
          }
        ]
      },
      {
        "functionName": "processSwitchAndCatch (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 3423,
        "actualComplexity": 1,
        "calculatedTotal": 3,
        "difference": 2,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "&&",
            "line": 3423,
            "name": "logical AND"
          },
          {
            "type": "||",
            "line": 3424,
            "name": "logical OR"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 0,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 3423,
          "end": 3425
        },
        "functionCode": [
          {
            "lineNum": 3423,
            "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
          },
          {
            "lineNum": 3424,
            "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
          },
          {
            "lineNum": 3425,
            "content": "    }"
          }
        ]
      },
      {
        "functionName": "parseDecisionPoints (forEach callback)",
        "file": "scripts/decision-points.js",
        "line": 15,
        "actualComplexity": 3,
        "calculatedTotal": 4,
        "difference": 1,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 16,
            "name": "default parameter"
          },
          {
            "type": "for",
            "line": 16,
            "name": "for loop"
          },
          {
            "type": "if",
            "line": 17,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 1,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 15,
          "end": 22
        },
        "functionCode": [
          {
            "lineNum": 15,
            "content": "  functionBoundaries.forEach((boundary, functionLine) => {"
          },
          {
            "lineNum": 16,
            "content": "    for (let line = boundary.start; line <= boundary.end; line++) {"
          },
          {
            "lineNum": 17,
            "content": "      if (!lineToFunctions.has(line)) {"
          },
          {
            "lineNum": 18,
            "content": "        lineToFunctions.set(line, []);"
          },
          {
            "lineNum": 19,
            "content": "      }"
          },
          {
            "lineNum": 20,
            "content": "      lineToFunctions.get(line).push({ functionLine, boundary });"
          },
          {
            "lineNum": 21,
            "content": "    }"
          },
          {
            "lineNum": 22,
            "content": "  });"
          }
        ]
      },
      {
        "functionName": "analyzeMismatches (forEach callback)",
        "file": "scripts/analyze-mismatches.js",
        "line": 68,
        "actualComplexity": 11,
        "calculatedTotal": 10,
        "difference": -1,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "if",
            "line": 81,
            "name": "if statement"
          },
          {
            "type": "||",
            "line": 83,
            "name": "logical OR"
          },
          {
            "type": "ternary",
            "line": 88,
            "name": "ternary operator"
          },
          {
            "type": "if",
            "line": 96,
            "name": "if statement"
          },
          {
            "type": "&&",
            "line": 96,
            "name": "logical AND"
          },
          {
            "type": "else if",
            "line": 98,
            "name": "else if statement"
          },
          {
            "type": "else if",
            "line": 100,
            "name": "else if statement"
          },
          {
            "type": "ternary",
            "line": 115,
            "name": "ternary operator"
          },
          {
            "type": "ternary",
            "line": 122,
            "name": "ternary operator"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 2,
          "else if": 2,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 3,
          "&&": 1,
          "||": 1,
          "??": 0,
          "?.": 0,
          "default parameter": 0
        },
        "boundary": {
          "start": 68,
          "end": 129
        },
        "functionCode": [
          {
            "lineNum": 68,
            "content": "      functions.forEach(func => {"
          },
          {
            "lineNum": 69,
            "content": "        const boundary = findBoundaryForFunction(func.line, fileBoundaries);"
          },
          {
            "lineNum": 70,
            "content": "        const breakdown = calculateComplexityBreakdown("
          },
          {
            "lineNum": 71,
            "content": "          func.line,"
          },
          {
            "lineNum": 72,
            "content": "          fileDecisionPoints,"
          },
          {
            "lineNum": 73,
            "content": "          1 // base complexity"
          },
          {
            "lineNum": 74,
            "content": "        );"
          },
          {
            "lineNum": 75,
            "content": ""
          },
          {
            "lineNum": 76,
            "content": "        const actualComplexity = parseInt(func.complexity);"
          },
          {
            "lineNum": 77,
            "content": "        const calculatedTotal = breakdown.calculatedTotal;"
          },
          {
            "lineNum": 78,
            "content": "        const difference = calculatedTotal - actualComplexity;"
          },
          {
            "lineNum": 79,
            "content": ""
          },
          {
            "lineNum": 80,
            "content": "        // Record ALL mismatches (not just those > 1)"
          },
          {
            "lineNum": 81,
            "content": "        if (calculatedTotal !== actualComplexity) {"
          },
          {
            "lineNum": 82,
            "content": "          // Get decision points for this function"
          },
          {
            "lineNum": 83,
            "content": "          const functionDecisionPoints = breakdown.decisionPoints || [];"
          },
          {
            "lineNum": 84,
            "content": "          "
          },
          {
            "lineNum": 85,
            "content": "          // Get source code lines for context"
          },
          {
            "lineNum": 86,
            "content": "          const lines = sourceCode.split('\\n');"
          },
          {
            "lineNum": 87,
            "content": "          const functionCode = boundary "
          },
          {
            "lineNum": 88,
            "content": "            ? lines.slice(boundary.start - 1, boundary.end).map((line, idx) => ({"
          },
          {
            "lineNum": 89,
            "content": "                lineNum: boundary.start + idx,"
          },
          {
            "lineNum": 90,
            "content": "                content: line"
          },
          {
            "lineNum": 91,
            "content": "              }))"
          },
          {
            "lineNum": 92,
            "content": "            : [];"
          },
          {
            "lineNum": 93,
            "content": ""
          },
          {
            "lineNum": 94,
            "content": "          // Categorize the mismatch"
          },
          {
            "lineNum": 95,
            "content": "          let category = 'unknown';"
          },
          {
            "lineNum": 96,
            "content": "          if (functionDecisionPoints.length === 0 && actualComplexity > 1) {"
          },
          {
            "lineNum": 97,
            "content": "            category = '(none)';"
          },
          {
            "lineNum": 98,
            "content": "          } else if (difference < 0) {"
          },
          {
            "lineNum": 99,
            "content": "            category = 'under-counting';"
          },
          {
            "lineNum": 100,
            "content": "          } else if (difference > 0) {"
          },
          {
            "lineNum": 101,
            "content": "            category = 'over-counting';"
          },
          {
            "lineNum": 102,
            "content": "          }"
          },
          {
            "lineNum": 103,
            "content": ""
          },
          {
            "lineNum": 104,
            "content": "          // Check if it's a forEach callback"
          },
          {
            "lineNum": 105,
            "content": "          const isForEachCallback = func.functionName.includes('forEach callback') || "
          },
          {
            "lineNum": 106,
            "content": "                                   func.functionName.includes('forEach');"
          },
          {
            "lineNum": 107,
            "content": ""
          },
          {
            "lineNum": 108,
            "content": "          mismatches.push({"
          },
          {
            "lineNum": 109,
            "content": "            functionName: func.functionName,"
          },
          {
            "lineNum": 110,
            "content": "            file: func.file,"
          },
          {
            "lineNum": 111,
            "content": "            line: func.line,"
          },
          {
            "lineNum": 112,
            "content": "            actualComplexity,"
          },
          {
            "lineNum": 113,
            "content": "            calculatedTotal,"
          },
          {
            "lineNum": 114,
            "content": "            difference,"
          },
          {
            "lineNum": 115,
            "content": "            category: isForEachCallback ? 'forEach callback' : category,"
          },
          {
            "lineNum": 116,
            "content": "            decisionPoints: functionDecisionPoints.map(dp => ({"
          },
          {
            "lineNum": 117,
            "content": "              type: dp.type,"
          }
        ]
      },
      {
        "functionName": "findMaxComplexityInSubtree (forEach callback)",
        "file": "scripts/function-hierarchy.js",
        "line": 90,
        "actualComplexity": 2,
        "calculatedTotal": 3,
        "difference": 1,
        "category": "forEach callback",
        "decisionPoints": [
          {
            "type": "default parameter",
            "line": 92,
            "name": "default parameter"
          },
          {
            "type": "if",
            "line": 92,
            "name": "if statement"
          }
        ],
        "breakdown": {
          "base": 1,
          "if": 1,
          "else if": 0,
          "for": 0,
          "for...of": 0,
          "for...in": 0,
          "while": 0,
          "do...while": 0,
          "switch": 0,
          "case": 0,
          "catch": 0,
          "ternary": 0,
          "&&": 0,
          "||": 0,
          "??": 0,
          "?.": 0,
          "default parameter": 1
        },
        "boundary": {
          "start": 90,
          "end": 93
        },
        "functionCode": [
          {
            "lineNum": 90,
            "content": "  node.children.forEach(child => {"
          },
          {
            "lineNum": 91,
            "content": "    const childMax = findMaxComplexityInSubtree(child);"
          },
          {
            "lineNum": 92,
            "content": "    if (childMax > max) max = childMax;"
          },
          {
            "lineNum": 93,
            "content": "  });"
          }
        ]
      }
    ],
    "other": []
  },
  "allMismatches": [
    {
      "functionName": "processLineInFunctionBody",
      "file": "scripts/function-boundaries.js",
      "line": 736,
      "actualComplexity": 53,
      "calculatedTotal": 35,
      "difference": -18,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 752,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 788,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 788,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 793,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 793,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 793,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 794,
          "name": "if statement"
        },
        {
          "type": "else if",
          "line": 797,
          "name": "else if statement"
        },
        {
          "type": "if",
          "line": 806,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 806,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 806,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 806,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 806,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 810,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 810,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 810,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 810,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 811,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 811,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 818,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 818,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 818,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 818,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 824,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 824,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 825,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 826,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 833,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 833,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 837,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 837,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 839,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 844,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 851,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 14,
        "else if": 1,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 10,
        "||": 8,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 736,
        "end": 857
      },
      "functionCode": [
        {
          "lineNum": 736,
          "content": "function processLineInFunctionBody(line, i, functionLine, braceCount, lines) {"
        },
        {
          "lineNum": 737,
          "content": "  // Count braces, but exclude those inside regex patterns, string literals, and comments"
        },
        {
          "lineNum": 738,
          "content": "  // Regex patterns can contain braces in character classes (e.g., /[({]/ or /[&|]{2}/)"
        },
        {
          "lineNum": 739,
          "content": "  // String literals can contain braces (e.g., includes('{') or \"text { more }\")"
        },
        {
          "lineNum": 740,
          "content": "  // Comments can contain braces (e.g., // Check if the { is part of...)"
        },
        {
          "lineNum": 741,
          "content": "  let openBraces = 0;"
        },
        {
          "lineNum": 742,
          "content": "  let closeBraces = 0;"
        },
        {
          "lineNum": 743,
          "content": "  let inRegex = false;"
        },
        {
          "lineNum": 744,
          "content": "  let inString = false;"
        },
        {
          "lineNum": 745,
          "content": "  let inSingleLineComment = false;"
        },
        {
          "lineNum": 746,
          "content": "  let inMultiLineComment = false;"
        },
        {
          "lineNum": 747,
          "content": "  let stringChar = null; // Track which quote started the string (' or \")"
        },
        {
          "lineNum": 748,
          "content": "  let escapeNext = false;"
        },
        {
          "lineNum": 749,
          "content": "  "
        },
        {
          "lineNum": 750,
          "content": "  for (let j = 0; j < line.length; j++) {"
        },
        {
          "lineNum": 751,
          "content": "    const char = line[j];"
        },
        {
          "lineNum": 752,
          "content": "    const prevChar = j > 0 ? line[j - 1] : '';"
        },
        {
          "lineNum": 753,
          "content": "    const nextChar = j + 1 < line.length ? line[j + 1] : '';"
        },
        {
          "lineNum": 754,
          "content": "    "
        },
        {
          "lineNum": 755,
          "content": "    // Handle escape sequences in strings"
        },
        {
          "lineNum": 756,
          "content": "    if (escapeNext) {"
        },
        {
          "lineNum": 757,
          "content": "      escapeNext = false;"
        },
        {
          "lineNum": 758,
          "content": "      continue;"
        },
        {
          "lineNum": 759,
          "content": "    }"
        },
        {
          "lineNum": 760,
          "content": "    "
        },
        {
          "lineNum": 761,
          "content": "    if (char === '\\\\' && inString) {"
        },
        {
          "lineNum": 762,
          "content": "      escapeNext = true;"
        },
        {
          "lineNum": 763,
          "content": "      continue;"
        },
        {
          "lineNum": 764,
          "content": "    }"
        },
        {
          "lineNum": 765,
          "content": "    "
        },
        {
          "lineNum": 766,
          "content": "    // Handle single-line comments (//)"
        },
        {
          "lineNum": 767,
          "content": "    if (char === '/' && nextChar === '/' && !inString && !inRegex && !inMultiLineComment) {"
        },
        {
          "lineNum": 768,
          "content": "      inSingleLineComment = true;"
        },
        {
          "lineNum": 769,
          "content": "      // Rest of line is comment, break"
        },
        {
          "lineNum": 770,
          "content": "      break;"
        },
        {
          "lineNum": 771,
          "content": "    }"
        },
        {
          "lineNum": 772,
          "content": "    "
        },
        {
          "lineNum": 773,
          "content": "    // Handle multi-line comment start (/*)"
        },
        {
          "lineNum": 774,
          "content": "    if (char === '/' && nextChar === '*' && !inString && !inRegex && !inSingleLineComment) {"
        },
        {
          "lineNum": 775,
          "content": "      inMultiLineComment = true;"
        },
        {
          "lineNum": 776,
          "content": "      j++; // Skip the * character"
        },
        {
          "lineNum": 777,
          "content": "      continue;"
        },
        {
          "lineNum": 778,
          "content": "    }"
        },
        {
          "lineNum": 779,
          "content": "    "
        },
        {
          "lineNum": 780,
          "content": "    // Handle multi-line comment end (*/)"
        },
        {
          "lineNum": 781,
          "content": "    if (char === '*' && nextChar === '/' && inMultiLineComment) {"
        },
        {
          "lineNum": 782,
          "content": "      inMultiLineComment = false;"
        },
        {
          "lineNum": 783,
          "content": "      j++; // Skip the / character"
        },
        {
          "lineNum": 784,
          "content": "      continue;"
        },
        {
          "lineNum": 785,
          "content": "    }"
        }
      ]
    },
    {
      "functionName": "findNamedFunctionEnd",
      "file": "scripts/function-boundaries.js",
      "line": 869,
      "actualComplexity": 9,
      "calculatedTotal": 4,
      "difference": -5,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 906,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 906,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 913,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 869,
        "end": 923
      },
      "functionCode": [
        {
          "lineNum": 869,
          "content": "function findNamedFunctionEnd(lines, start, functionLine, arrowFunctionHandled, inFunctionBody, braceCount) {"
        },
        {
          "lineNum": 870,
          "content": "  let end = functionLine;"
        },
        {
          "lineNum": 871,
          "content": "  let typeBraceCount = 0;"
        },
        {
          "lineNum": 872,
          "content": "  "
        },
        {
          "lineNum": 873,
          "content": "  // For arrow functions that we've already handled, start from the body start line"
        },
        {
          "lineNum": 874,
          "content": "  // but skip counting braces on that line since we already counted them in handleBraceOnSameLine"
        },
        {
          "lineNum": 875,
          "content": "  // For other functions, start from start - 1 to find the body"
        },
        {
          "lineNum": 876,
          "content": "  // loopStart must be 0-based (array index)"
        },
        {
          "lineNum": 877,
          "content": "  const loopStart = start - 1; // Always 0-based array index (start is 1-based line number)"
        },
        {
          "lineNum": 878,
          "content": "  // Skip the first line if we already counted its braces in handleBraceOnSameLine"
        },
        {
          "lineNum": 879,
          "content": "  const skipFirstLine = (arrowFunctionHandled && inFunctionBody);"
        },
        {
          "lineNum": 880,
          "content": "  "
        },
        {
          "lineNum": 881,
          "content": "  for (let i = loopStart; i < lines.length; i++) {"
        },
        {
          "lineNum": 882,
          "content": "    const line = lines[i];"
        },
        {
          "lineNum": 883,
          "content": "    "
        },
        {
          "lineNum": 884,
          "content": "    if (!inFunctionBody) {"
        },
        {
          "lineNum": 885,
          "content": "      const result = processLineBeforeFunctionBody(line, i, lines, typeBraceCount);"
        },
        {
          "lineNum": 886,
          "content": "      "
        },
        {
          "lineNum": 887,
          "content": "      if (result.end !== null) {"
        },
        {
          "lineNum": 888,
          "content": "        // Arrow function without braces - end found"
        },
        {
          "lineNum": 889,
          "content": "        return result.end;"
        },
        {
          "lineNum": 890,
          "content": "      }"
        },
        {
          "lineNum": 891,
          "content": "      "
        },
        {
          "lineNum": 892,
          "content": "      if (result.inFunctionBody) {"
        },
        {
          "lineNum": 893,
          "content": "        // Function body found"
        },
        {
          "lineNum": 894,
          "content": "        inFunctionBody = true;"
        },
        {
          "lineNum": 895,
          "content": "        braceCount = result.braceCount;"
        },
        {
          "lineNum": 896,
          "content": "        typeBraceCount = result.typeBraceCount;"
        },
        {
          "lineNum": 897,
          "content": "        // Don't process this line's braces again in the function body tracking section"
        },
        {
          "lineNum": 898,
          "content": "        continue;"
        },
        {
          "lineNum": 899,
          "content": "      }"
        },
        {
          "lineNum": 900,
          "content": "      "
        },
        {
          "lineNum": 901,
          "content": "      typeBraceCount = result.typeBraceCount;"
        },
        {
          "lineNum": 902,
          "content": "    } else {"
        },
        {
          "lineNum": 903,
          "content": "      // We're in the function body, track its braces"
        },
        {
          "lineNum": 904,
          "content": "      // Skip the first line if we already counted its braces in handleBraceOnSameLine"
        },
        {
          "lineNum": 905,
          "content": "      // i is 0-based index, start is 1-based line number, so compare i + 1 === start"
        },
        {
          "lineNum": 906,
          "content": "      if (skipFirstLine && i + 1 === start) {"
        },
        {
          "lineNum": 907,
          "content": "        // Skip this line - braces already counted in handleBraceOnSameLine"
        },
        {
          "lineNum": 908,
          "content": "        continue;"
        },
        {
          "lineNum": 909,
          "content": "      }"
        },
        {
          "lineNum": 910,
          "content": "      "
        },
        {
          "lineNum": 911,
          "content": "      const result = processLineInFunctionBody(line, i, functionLine, braceCount, lines);"
        },
        {
          "lineNum": 912,
          "content": "      "
        },
        {
          "lineNum": 913,
          "content": "      if (result.end !== null) {"
        },
        {
          "lineNum": 914,
          "content": "        // Function end found"
        },
        {
          "lineNum": 915,
          "content": "        return result.end;"
        },
        {
          "lineNum": 916,
          "content": "      }"
        },
        {
          "lineNum": 917,
          "content": "      "
        },
        {
          "lineNum": 918,
          "content": "      braceCount = result.braceCount;"
        }
      ]
    },
    {
      "functionName": "findFunctionBoundaries (forEach callback)",
      "file": "scripts/function-boundaries.js",
      "line": 1035,
      "actualComplexity": 9,
      "calculatedTotal": 7,
      "difference": -2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "||",
          "line": 1037,
          "name": "logical OR"
        },
        {
          "type": "ternary",
          "line": 1041,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 1056,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1065,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1080,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 1080,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1035,
        "end": 1088
      },
      "functionCode": [
        {
          "lineNum": 1035,
          "content": "  functions.forEach(func => {"
        },
        {
          "lineNum": 1036,
          "content": "    const functionLine = func.line;"
        },
        {
          "lineNum": 1037,
          "content": "    const nodeType = func.nodeType || 'FunctionDeclaration';"
        },
        {
          "lineNum": 1038,
          "content": "    "
        },
        {
          "lineNum": 1039,
          "content": "    // Find the start line"
        },
        {
          "lineNum": 1040,
          "content": "    const start = nodeType === 'ArrowFunctionExpression'"
        },
        {
          "lineNum": 1041,
          "content": "      ? findArrowFunctionStart(lines, functionLine)"
        },
        {
          "lineNum": 1042,
          "content": "      : findNamedFunctionStart(lines, functionLine, func.functionName);"
        },
        {
          "lineNum": 1043,
          "content": "    "
        },
        {
          "lineNum": 1044,
          "content": "    let end = functionLine;"
        },
        {
          "lineNum": 1045,
          "content": "    "
        },
        {
          "lineNum": 1046,
          "content": "    // Find the end of the function by tracking braces"
        },
        {
          "lineNum": 1047,
          "content": "    // For arrow functions, start tracking from the arrow function's body"
        },
        {
          "lineNum": 1048,
          "content": "    // For TypeScript functions, we need to skip type definition braces and only track function body braces"
        },
        {
          "lineNum": 1049,
          "content": "    let braceCount = 0;"
        },
        {
          "lineNum": 1050,
          "content": "    let inFunctionBody = false;"
        },
        {
          "lineNum": 1051,
          "content": "    let typeBraceCount = 0; // Track type definition braces separately"
        },
        {
          "lineNum": 1052,
          "content": "    let arrowFunctionEndSet = false; // Track if we've set the end for an arrow function (object literal case)"
        },
        {
          "lineNum": 1053,
          "content": "    let arrowFunctionHandled = false;"
        },
        {
          "lineNum": 1054,
          "content": "    "
        },
        {
          "lineNum": 1055,
          "content": "    // For arrow functions, use the dedicated helper function"
        },
        {
          "lineNum": 1056,
          "content": "    if (nodeType === 'ArrowFunctionExpression') {"
        },
        {
          "lineNum": 1057,
          "content": "      const arrowResult = findArrowFunctionEnd(lines, start, functionLine, boundaries);"
        },
        {
          "lineNum": 1058,
          "content": "      end = arrowResult.end;"
        },
        {
          "lineNum": 1059,
          "content": "      arrowFunctionHandled = arrowResult.arrowFunctionHandled;"
        },
        {
          "lineNum": 1060,
          "content": "      arrowFunctionEndSet = arrowResult.arrowFunctionEndSet;"
        },
        {
          "lineNum": 1061,
          "content": "      inFunctionBody = arrowResult.inFunctionBody;"
        },
        {
          "lineNum": 1062,
          "content": "      braceCount = arrowResult.braceCount;"
        },
        {
          "lineNum": 1063,
          "content": "      "
        },
        {
          "lineNum": 1064,
          "content": "      // If the arrow function end was already set (e.g., object literal, JSX return), skip rest"
        },
        {
          "lineNum": 1065,
          "content": "      if (arrowFunctionEndSet) {"
        },
        {
          "lineNum": 1066,
          "content": "        // Boundary already set, skip to next function"
        },
        {
          "lineNum": 1067,
          "content": "        return;"
        },
        {
          "lineNum": 1068,
          "content": "      }"
        },
        {
          "lineNum": 1069,
          "content": "    }"
        },
        {
          "lineNum": 1070,
          "content": "    "
        },
        {
          "lineNum": 1071,
          "content": "    // Now find the end of the function body"
        },
        {
          "lineNum": 1072,
          "content": "    // Skip if arrow function was already handled (with or without braces, including object literals)"
        },
        {
          "lineNum": 1073,
          "content": "    // If we've set the end for an arrow function (object literal case), skip the rest"
        },
        {
          "lineNum": 1074,
          "content": "    if (!arrowFunctionEndSet) {"
        },
        {
          "lineNum": 1075,
          "content": "      end = findNamedFunctionEnd(lines, start, functionLine, arrowFunctionHandled, inFunctionBody, braceCount);"
        },
        {
          "lineNum": 1076,
          "content": "    }"
        },
        {
          "lineNum": 1077,
          "content": "    "
        },
        {
          "lineNum": 1078,
          "content": "    // Fallback: if we couldn't find the end, use a reasonable default"
        },
        {
          "lineNum": 1079,
          "content": "    // Also fallback if we never entered the function body (might be a type-only function or parsing issue)"
        },
        {
          "lineNum": 1080,
          "content": "    if (end === functionLine || !inFunctionBody) {"
        },
        {
          "lineNum": 1081,
          "content": "      end = findFunctionEndFallback(lines, start, functionLine);"
        },
        {
          "lineNum": 1082,
          "content": "    }"
        },
        {
          "lineNum": 1083,
          "content": "    "
        },
        {
          "lineNum": 1084,
          "content": "    // Only set boundary if we haven't already set it (e.g., for object literal arrow functions)"
        }
      ]
    },
    {
      "functionName": "findObjectLiteralClosingParen",
      "file": "scripts/function-boundaries.js",
      "line": 153,
      "actualComplexity": 7,
      "calculatedTotal": 3,
      "difference": -4,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 166,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 166,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 153,
        "end": 172
      },
      "functionCode": [
        {
          "lineNum": 153,
          "content": "function findObjectLiteralClosingParen(line, braceIndex) {"
        },
        {
          "lineNum": 154,
          "content": "  let parenCount = 1; // We know there's an opening ( before the {"
        },
        {
          "lineNum": 155,
          "content": "  "
        },
        {
          "lineNum": 156,
          "content": "  for (let k = braceIndex + 1; k < line.length; k++) {"
        },
        {
          "lineNum": 157,
          "content": "    if (line[k] === '(') {"
        },
        {
          "lineNum": 158,
          "content": "      parenCount++;"
        },
        {
          "lineNum": 159,
          "content": "    } else if (line[k] === ')') {"
        },
        {
          "lineNum": 160,
          "content": "      parenCount--;"
        },
        {
          "lineNum": 161,
          "content": "      if (parenCount === 0) {"
        },
        {
          "lineNum": 162,
          "content": "        // Found the closing paren of the object literal"
        },
        {
          "lineNum": 163,
          "content": "        // Check if there's a semicolon or closing paren after (end of expression)"
        },
        {
          "lineNum": 164,
          "content": "        const restOfLine = line.substring(k + 1).trim();"
        },
        {
          "lineNum": 165,
          "content": "        // Allow: ); or ; or ) or empty (end of expression)"
        },
        {
          "lineNum": 166,
          "content": "        return restOfLine.startsWith(';') || restOfLine.startsWith(')') || restOfLine === '';"
        },
        {
          "lineNum": 167,
          "content": "      }"
        },
        {
          "lineNum": 168,
          "content": "    }"
        },
        {
          "lineNum": 169,
          "content": "  }"
        },
        {
          "lineNum": 170,
          "content": "  "
        },
        {
          "lineNum": 171,
          "content": "  return false;"
        },
        {
          "lineNum": 172,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "findArrowFunctionEnd",
      "file": "scripts/function-boundaries.js",
      "line": 474,
      "actualComplexity": 7,
      "calculatedTotal": 8,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 482,
          "name": "default parameter"
        },
        {
          "type": "for",
          "line": 482,
          "name": "for loop"
        },
        {
          "type": "if",
          "line": 485,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 490,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 492,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 498,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 500,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 5,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 474,
        "end": 512
      },
      "functionCode": [
        {
          "lineNum": 474,
          "content": "function findArrowFunctionEnd(lines, start, functionLine, boundaries) {"
        },
        {
          "lineNum": 475,
          "content": "  let end = functionLine;"
        },
        {
          "lineNum": 476,
          "content": "  let arrowFunctionHandled = false;"
        },
        {
          "lineNum": 477,
          "content": "  let arrowFunctionEndSet = false;"
        },
        {
          "lineNum": 478,
          "content": "  let inFunctionBody = false;"
        },
        {
          "lineNum": 479,
          "content": "  let braceCount = 0;"
        },
        {
          "lineNum": 480,
          "content": "  "
        },
        {
          "lineNum": 481,
          "content": "  // Find the arrow function body start (where { appears after =>)"
        },
        {
          "lineNum": 482,
          "content": "  for (let i = start - 1; i < lines.length; i++) {"
        },
        {
          "lineNum": 483,
          "content": "    const line = lines[i];"
        },
        {
          "lineNum": 484,
          "content": "    // Look for => followed by { or ( on same or next line"
        },
        {
          "lineNum": 485,
          "content": "    if (line.includes('=>')) {"
        },
        {
          "lineNum": 486,
          "content": "      const arrowIndex = line.indexOf('=>');"
        },
        {
          "lineNum": 487,
          "content": "      const afterArrow = line.substring(arrowIndex + 2).trim();"
        },
        {
          "lineNum": 488,
          "content": "      "
        },
        {
          "lineNum": 489,
          "content": "      // Try JSX return pattern first"
        },
        {
          "lineNum": 490,
          "content": "      if (afterArrow.startsWith('(')) {"
        },
        {
          "lineNum": 491,
          "content": "        const jsxResult = handleJSXReturnPattern(lines, i, arrowIndex, functionLine, boundaries);"
        },
        {
          "lineNum": 492,
          "content": "        if (jsxResult) {"
        },
        {
          "lineNum": 493,
          "content": "          return { ...jsxResult, inFunctionBody, braceCount };"
        },
        {
          "lineNum": 494,
          "content": "        }"
        },
        {
          "lineNum": 495,
          "content": "      }"
        },
        {
          "lineNum": 496,
          "content": "      "
        },
        {
          "lineNum": 497,
          "content": "      // Check if { is on the same line after =>"
        },
        {
          "lineNum": 498,
          "content": "      if (line.includes('{')) {"
        },
        {
          "lineNum": 499,
          "content": "        const braceResult = handleBraceOnSameLine(lines, i, arrowIndex, functionLine, boundaries, line);"
        },
        {
          "lineNum": 500,
          "content": "        if (braceResult) {"
        },
        {
          "lineNum": 501,
          "content": "          return braceResult;"
        },
        {
          "lineNum": 502,
          "content": "        }"
        },
        {
          "lineNum": 503,
          "content": "      } else {"
        },
        {
          "lineNum": 504,
          "content": "        const noBraceResult = handleNoBraceOnSameLine(lines, i, arrowIndex, functionLine, boundaries);"
        },
        {
          "lineNum": 505,
          "content": "        return noBraceResult;"
        },
        {
          "lineNum": 506,
          "content": "      }"
        },
        {
          "lineNum": 507,
          "content": "      break;"
        },
        {
          "lineNum": 508,
          "content": "    }"
        },
        {
          "lineNum": 509,
          "content": "  }"
        },
        {
          "lineNum": 510,
          "content": "  "
        },
        {
          "lineNum": 511,
          "content": "  return { end, found: false, arrowFunctionHandled, arrowFunctionEndSet, inFunctionBody, braceCount };"
        },
        {
          "lineNum": 512,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "findNamedFunctionStart",
      "file": "scripts/function-boundaries.js",
      "line": 993,
      "actualComplexity": 6,
      "calculatedTotal": 8,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1000,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1001,
          "name": "ternary operator"
        },
        {
          "type": "for",
          "line": 1010,
          "name": "for loop"
        },
        {
          "type": "for...of",
          "line": 1012,
          "name": "for...of loop"
        },
        {
          "type": "if",
          "line": 1014,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 1014,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 1019,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 1,
        "for...of": 1,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 2,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 993,
        "end": 1023
      },
      "functionCode": [
        {
          "lineNum": 993,
          "content": "function findNamedFunctionStart(lines, functionLine, functionName) {"
        },
        {
          "lineNum": 994,
          "content": "  // Named function: look backwards from the reported line to find function declaration"
        },
        {
          "lineNum": 995,
          "content": "  // Check up to 50 lines back"
        },
        {
          "lineNum": 996,
          "content": "  const startLine = Math.max(0, functionLine - 50);"
        },
        {
          "lineNum": 997,
          "content": "  "
        },
        {
          "lineNum": 998,
          "content": "  // Try various function patterns to find the actual declaration line"
        },
        {
          "lineNum": 999,
          "content": "  const patterns = ["
        },
        {
          "lineNum": 1000,
          "content": "    /(?:export\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
        },
        {
          "lineNum": 1001,
          "content": "    /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
        },
        {
          "lineNum": 1002,
          "content": "    /export\\s+const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
        },
        {
          "lineNum": 1003,
          "content": "    /export\\s+default\\s+function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
        },
        {
          "lineNum": 1004,
          "content": "    /(?:export\\s+default\\s+|const\\s+)([A-Z][a-zA-Z0-9_$]*)\\s*[:=]\\s*(?:\\([^)]*\\)\\s*)?=>/,"
        },
        {
          "lineNum": 1005,
          "content": "  ];"
        },
        {
          "lineNum": 1006,
          "content": "  "
        },
        {
          "lineNum": 1007,
          "content": "  // Find the actual function declaration line"
        },
        {
          "lineNum": 1008,
          "content": "  // Match the function name to ensure we find the correct function"
        },
        {
          "lineNum": 1009,
          "content": "  let start = functionLine;"
        },
        {
          "lineNum": 1010,
          "content": "  for (let i = functionLine - 1; i >= startLine; i--) {"
        },
        {
          "lineNum": 1011,
          "content": "    const line = lines[i];"
        },
        {
          "lineNum": 1012,
          "content": "    for (const pattern of patterns) {"
        },
        {
          "lineNum": 1013,
          "content": "      const match = line.match(pattern);"
        },
        {
          "lineNum": 1014,
          "content": "      if (match && match[1] === functionName) {"
        },
        {
          "lineNum": 1015,
          "content": "        start = i + 1; // Convert to 1-based line number"
        },
        {
          "lineNum": 1016,
          "content": "        break;"
        },
        {
          "lineNum": 1017,
          "content": "      }"
        },
        {
          "lineNum": 1018,
          "content": "    }"
        },
        {
          "lineNum": 1019,
          "content": "    if (start !== functionLine) break;"
        },
        {
          "lineNum": 1020,
          "content": "  }"
        },
        {
          "lineNum": 1021,
          "content": "  "
        },
        {
          "lineNum": 1022,
          "content": "  return start;"
        },
        {
          "lineNum": 1023,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "handleFunctionBodyStart",
      "file": "scripts/function-boundaries.js",
      "line": 628,
      "actualComplexity": 5,
      "calculatedTotal": 1,
      "difference": -4,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 628,
        "end": 646
      },
      "functionCode": [
        {
          "lineNum": 628,
          "content": "function handleFunctionBodyStart(line, i, lines) {"
        },
        {
          "lineNum": 629,
          "content": "  const hasFunctionBodyPattern = /\\)\\s*[:\\w\\s<>\\[\\]|'\"]*\\s*\\{/.test(line);"
        },
        {
          "lineNum": 630,
          "content": "  const isFunctionDeclaration = isFunctionDeclarationPattern(line);"
        },
        {
          "lineNum": 631,
          "content": "  const hasArrowFunction = line.includes('=>') && !line.includes('{');"
        },
        {
          "lineNum": 632,
          "content": "  "
        },
        {
          "lineNum": 633,
          "content": "  if (hasFunctionBodyPattern || isFunctionDeclaration) {"
        },
        {
          "lineNum": 634,
          "content": "    // Function body starts here"
        },
        {
          "lineNum": 635,
          "content": "    const braceCount = calculateFunctionBodyBraceCount(line);"
        },
        {
          "lineNum": 636,
          "content": "    return { inFunctionBody: true, braceCount, end: null };"
        },
        {
          "lineNum": 637,
          "content": "  }"
        },
        {
          "lineNum": 638,
          "content": "  "
        },
        {
          "lineNum": 639,
          "content": "  if (hasArrowFunction) {"
        },
        {
          "lineNum": 640,
          "content": "    // Arrow function without braces"
        },
        {
          "lineNum": 641,
          "content": "    const end = handleArrowFunctionWithoutBraces(lines, i);"
        },
        {
          "lineNum": 642,
          "content": "    return { inFunctionBody: true, braceCount: 0, end };"
        },
        {
          "lineNum": 643,
          "content": "  }"
        },
        {
          "lineNum": 644,
          "content": "  "
        },
        {
          "lineNum": 645,
          "content": "  return { inFunctionBody: false, braceCount: 0, end: null };"
        },
        {
          "lineNum": 646,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "isFunctionDeclarationPattern",
      "file": "scripts/function-boundaries.js",
      "line": 519,
      "actualComplexity": 4,
      "calculatedTotal": 5,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 520,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 520,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 521,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 522,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 3,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 519,
        "end": 524
      },
      "functionCode": [
        {
          "lineNum": 519,
          "content": "function isFunctionDeclarationPattern(line) {"
        },
        {
          "lineNum": 520,
          "content": "  return /^\\s*(?:export\\s+)?function\\s+\\w+/.test(line) && "
        },
        {
          "lineNum": 521,
          "content": "         line.includes('(') && "
        },
        {
          "lineNum": 522,
          "content": "         line.includes('{') && "
        },
        {
          "lineNum": 523,
          "content": "         !line.includes('=>');"
        },
        {
          "lineNum": 524,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "processLineForDecisionPoints",
      "file": "scripts/decision-points.js",
      "line": 3614,
      "actualComplexity": 19,
      "calculatedTotal": 16,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 3616,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 3617,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3620,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 3620,
          "name": "logical OR"
        },
        {
          "type": "while",
          "line": 3720,
          "name": "while loop"
        },
        {
          "type": "ternary",
          "line": 3721,
          "name": "ternary operator"
        },
        {
          "type": "||",
          "line": 3722,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 3722,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 3723,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3726,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3728,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 3728,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3729,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3739,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3739,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 5,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 1,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 4,
        "||": 4,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3614,
        "end": 3824
      },
      "functionCode": [
        {
          "lineNum": 3614,
          "content": "  const processLineForDecisionPoints = (line, index, lines, lineToFunctions, functionBoundaries, getInnermostFunction, isInsideStringLiteral, hasQuestionMarkOutsideString, decisionPoints) => {"
        },
        {
          "lineNum": 3615,
          "content": "    const lineNum = index + 1;"
        },
        {
          "lineNum": 3616,
          "content": "    const containingFunctions = lineToFunctions.get(lineNum) || [];"
        },
        {
          "lineNum": 3617,
          "content": "    if (containingFunctions.length === 0) return; // Skip lines outside functions"
        },
        {
          "lineNum": 3618,
          "content": "    "
        },
        {
          "lineNum": 3619,
          "content": "    const trimmed = line.trim();"
        },
        {
          "lineNum": 3620,
          "content": "    if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('*')) {"
        },
        {
          "lineNum": 3621,
          "content": "      return; // Skip empty lines and comments"
        },
        {
          "lineNum": 3622,
          "content": "    }"
        },
        {
          "lineNum": 3623,
          "content": "    "
        },
        {
          "lineNum": 3624,
          "content": "    // Remove comments from line for parsing"
        },
        {
          "lineNum": 3625,
          "content": "    const lineWithoutComments = line.replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
        },
        {
          "lineNum": 3626,
          "content": "    "
        },
        {
          "lineNum": 3627,
          "content": "    // Special handling for control structures (if, for, while, etc.) that contain callbacks"
        },
        {
          "lineNum": 3628,
          "content": "    // These should always belong to the immediate parent function, not nested callbacks"
        },
        {
          "lineNum": 3629,
          "content": "    // Check if this line contains a control structure"
        },
        {
          "lineNum": 3630,
          "content": "    const isControlStructure = /^\\s*(if|for|while|switch)\\s*\\(/.test(lineWithoutComments);"
        },
        {
          "lineNum": 3631,
          "content": "    "
        },
        {
          "lineNum": 3632,
          "content": "    // Find the function to assign this decision point to"
        },
        {
          "lineNum": 3633,
          "content": "    // For control structures, prefer immediate parent function even if there's a nested callback on the same line"
        },
        {
          "lineNum": 3634,
          "content": "    const functionLine = getFunctionLineForControlStructure("
        },
        {
          "lineNum": 3635,
          "content": "      isControlStructure,"
        },
        {
          "lineNum": 3636,
          "content": "      lineNum,"
        },
        {
          "lineNum": 3637,
          "content": "      containingFunctions,"
        },
        {
          "lineNum": 3638,
          "content": "      functionBoundaries,"
        },
        {
          "lineNum": 3639,
          "content": "      getInnermostFunction"
        },
        {
          "lineNum": 3640,
          "content": "    );"
        },
        {
          "lineNum": 3641,
          "content": "    "
        },
        {
          "lineNum": 3642,
          "content": "    if (!functionLine) return; // Skip if no function found"
        },
        {
          "lineNum": 3643,
          "content": "    "
        },
        {
          "lineNum": 3644,
          "content": "    // Get function boundary to limit template literal lookback"
        },
        {
          "lineNum": 3645,
          "content": "    const boundary = functionBoundaries.get(functionLine);"
        },
        {
          "lineNum": 3646,
          "content": "    const functionStartIndex = boundary ? Math.max(0, boundary.start - 1) : 0;"
        },
        {
          "lineNum": 3647,
          "content": "    "
        },
        {
          "lineNum": 3648,
          "content": "    // Create a bound version of isInsideStringLiteral with line context for multi-line template literal support"
        },
        {
          "lineNum": 3649,
          "content": "    // Only look back within the function's boundary to avoid incorrectly excluding decision points from other functions"
        },
        {
          "lineNum": 3650,
          "content": "    // IMPORTANT: Always use the original line (with comments) for template literal detection"
        },
        {
          "lineNum": 3651,
          "content": "    // The lookback processes original lines, so we need consistency"
        },
        {
          "lineNum": 3652,
          "content": "    const isInsideStringLiteralWithContext = (lineToCheck, charIndex) => {"
        },
        {
          "lineNum": 3653,
          "content": "      // Always use the original line for template literal detection to match what lookback processes"
        },
        {
          "lineNum": 3654,
          "content": "      // Always pass lineIndex, allLines, and functionStartIndex for accurate multi-line template literal detection"
        },
        {
          "lineNum": 3655,
          "content": "      if (lineToCheck === line) {"
        },
        {
          "lineNum": 3656,
          "content": "        // Same line - use charIndex directly with full context"
        },
        {
          "lineNum": 3657,
          "content": "        return isInsideStringLiteral(line, charIndex, index, lines, functionStartIndex);"
        },
        {
          "lineNum": 3658,
          "content": "      }"
        },
        {
          "lineNum": 3659,
          "content": "      "
        },
        {
          "lineNum": 3660,
          "content": "      // Different line (lineWithoutComments) - find the character at charIndex in the original line"
        },
        {
          "lineNum": 3661,
          "content": "      // Since comments are removed with .replace().trim(), indices should mostly match"
        },
        {
          "lineNum": 3662,
          "content": "      // But to be safe, find the character sequence around charIndex"
        },
        {
          "lineNum": 3663,
          "content": "      const charAtPos = lineToCheck[charIndex];"
        }
      ]
    },
    {
      "functionName": "isInsideStringLiteral",
      "file": "scripts/decision-points.js",
      "line": 509,
      "actualComplexity": 16,
      "calculatedTotal": 13,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "for",
          "line": 524,
          "name": "for loop"
        },
        {
          "type": "if",
          "line": 526,
          "name": "if statement"
        },
        {
          "type": "for",
          "line": 529,
          "name": "for loop"
        },
        {
          "type": "ternary",
          "line": 531,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 534,
          "name": "if statement"
        },
        {
          "type": "for",
          "line": 542,
          "name": "for loop"
        },
        {
          "type": "&&",
          "line": 542,
          "name": "logical AND"
        },
        {
          "type": "ternary",
          "line": 544,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 549,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 3,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 2,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 3
      },
      "boundary": {
        "start": 509,
        "end": 558
      },
      "functionCode": [
        {
          "lineNum": 509,
          "content": "  const isInsideStringLiteral = (line, charIndex, lineIndex = -1, allLines = [], functionStartIndex = 0) => {"
        },
        {
          "lineNum": 510,
          "content": "    let state = {"
        },
        {
          "lineNum": 511,
          "content": "      inSingleQuote: false,"
        },
        {
          "lineNum": 512,
          "content": "      inDoubleQuote: false,"
        },
        {
          "lineNum": 513,
          "content": "      inTemplateLiteral: false,"
        },
        {
          "lineNum": 514,
          "content": "      inTemplateExpression: false,"
        },
        {
          "lineNum": 515,
          "content": "      braceDepth: 0,"
        },
        {
          "lineNum": 516,
          "content": "      escapeNext: false"
        },
        {
          "lineNum": 517,
          "content": "    };"
        },
        {
          "lineNum": 518,
          "content": "    "
        },
        {
          "lineNum": 519,
          "content": "    // If we have line context, look backwards to find template literal starts"
        },
        {
          "lineNum": 520,
          "content": "    // Only look back within the function's boundary to avoid incorrectly excluding decision points"
        },
        {
          "lineNum": 521,
          "content": "    // Process ALL lines from function start to current line to correctly track template literal state"
        },
        {
          "lineNum": 522,
          "content": "    if (lineIndex >= 0 && allLines.length > 0 && functionStartIndex >= 0) {"
        },
        {
          "lineNum": 523,
          "content": "      // Process all lines from function start to current line (excluding current line - we'll process it separately)"
        },
        {
          "lineNum": 524,
          "content": "      for (let i = functionStartIndex; i < lineIndex; i++) {"
        },
        {
          "lineNum": 525,
          "content": "        const prevLine = allLines[i];"
        },
        {
          "lineNum": 526,
          "content": "        if (!prevLine) continue;"
        },
        {
          "lineNum": 527,
          "content": "        "
        },
        {
          "lineNum": 528,
          "content": "        // Process the previous line to update template literal state"
        },
        {
          "lineNum": 529,
          "content": "        for (let j = 0; j < prevLine.length; j++) {"
        },
        {
          "lineNum": 530,
          "content": "          const char = prevLine[j];"
        },
        {
          "lineNum": 531,
          "content": "          const nextChar = j + 1 < prevLine.length ? prevLine[j + 1] : '';"
        },
        {
          "lineNum": 532,
          "content": "          const result = processCharacterForStringLiteral(char, nextChar, state);"
        },
        {
          "lineNum": 533,
          "content": "          state = result;"
        },
        {
          "lineNum": 534,
          "content": "          if (result.skipNext) {"
        },
        {
          "lineNum": 535,
          "content": "            j++; // Skip the next character"
        },
        {
          "lineNum": 536,
          "content": "          }"
        },
        {
          "lineNum": 537,
          "content": "        }"
        },
        {
          "lineNum": 538,
          "content": "      }"
        },
        {
          "lineNum": 539,
          "content": "    }"
        },
        {
          "lineNum": 540,
          "content": "    "
        },
        {
          "lineNum": 541,
          "content": "    // Process current line up to charIndex"
        },
        {
          "lineNum": 542,
          "content": "    for (let i = 0; i < charIndex && i < line.length; i++) {"
        },
        {
          "lineNum": 543,
          "content": "      const char = line[i];"
        },
        {
          "lineNum": 544,
          "content": "      const nextChar = i + 1 < line.length ? line[i + 1] : '';"
        },
        {
          "lineNum": 545,
          "content": "      "
        },
        {
          "lineNum": 546,
          "content": "      const result = processCharacterForStringLiteral(char, nextChar, state);"
        },
        {
          "lineNum": 547,
          "content": "      state = result;"
        },
        {
          "lineNum": 548,
          "content": "      "
        },
        {
          "lineNum": 549,
          "content": "      if (result.skipNext) {"
        },
        {
          "lineNum": 550,
          "content": "        i++; // Skip the next character (e.g., '{' in ${)"
        },
        {
          "lineNum": 551,
          "content": "      }"
        },
        {
          "lineNum": 552,
          "content": "    }"
        },
        {
          "lineNum": 553,
          "content": "    "
        },
        {
          "lineNum": 554,
          "content": "    // Use isInStringLiteralFromState which correctly handles template literals:"
        },
        {
          "lineNum": 555,
          "content": "    // - Inside template literal string (not in expression): returns true (skip decision point)"
        },
        {
          "lineNum": 556,
          "content": "    // - Inside template literal expression (${...}): returns false (count decision point)"
        },
        {
          "lineNum": 557,
          "content": "    return isInStringLiteralFromState(state);"
        },
        {
          "lineNum": 558,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processQuoteCharacters",
      "file": "scripts/decision-points.js",
      "line": 390,
      "actualComplexity": 11,
      "calculatedTotal": 10,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 391,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 391,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 391,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 399,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 399,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 399,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 407,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 407,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 407,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 6,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 390,
        "end": 436
      },
      "functionCode": [
        {
          "lineNum": 390,
          "content": "  const processQuoteCharacters = (char, inSingleQuote, inDoubleQuote, inTemplateLiteral, inTemplateExpression) => {"
        },
        {
          "lineNum": 391,
          "content": "    if (char === \"'\" && !inDoubleQuote && !inTemplateLiteral) {"
        },
        {
          "lineNum": 392,
          "content": "      return { "
        },
        {
          "lineNum": 393,
          "content": "        inSingleQuote: !inSingleQuote, "
        },
        {
          "lineNum": 394,
          "content": "        inDoubleQuote, "
        },
        {
          "lineNum": 395,
          "content": "        inTemplateLiteral,"
        },
        {
          "lineNum": 396,
          "content": "        resetTemplateExpression: false"
        },
        {
          "lineNum": 397,
          "content": "      };"
        },
        {
          "lineNum": 398,
          "content": "    }"
        },
        {
          "lineNum": 399,
          "content": "    if (char === '\"' && !inSingleQuote && !inTemplateLiteral) {"
        },
        {
          "lineNum": 400,
          "content": "      return { "
        },
        {
          "lineNum": 401,
          "content": "        inSingleQuote, "
        },
        {
          "lineNum": 402,
          "content": "        inDoubleQuote: !inDoubleQuote, "
        },
        {
          "lineNum": 403,
          "content": "        inTemplateLiteral,"
        },
        {
          "lineNum": 404,
          "content": "        resetTemplateExpression: false"
        },
        {
          "lineNum": 405,
          "content": "      };"
        },
        {
          "lineNum": 406,
          "content": "    }"
        },
        {
          "lineNum": 407,
          "content": "    if (char === '`' && !inSingleQuote && !inDoubleQuote) {"
        },
        {
          "lineNum": 408,
          "content": "      // IMPORTANT: When inside a template expression ${...}, backticks start nested template literals"
        },
        {
          "lineNum": 409,
          "content": "      // We should NOT toggle the outer template literal state in this case"
        },
        {
          "lineNum": 410,
          "content": "      // Only toggle if we're NOT inside a template expression"
        },
        {
          "lineNum": 411,
          "content": "      if (inTemplateExpression) {"
        },
        {
          "lineNum": 412,
          "content": "        // Inside ${...} - backtick starts a nested template literal, don't toggle outer state"
        },
        {
          "lineNum": 413,
          "content": "        return { "
        },
        {
          "lineNum": 414,
          "content": "          inSingleQuote, "
        },
        {
          "lineNum": 415,
          "content": "          inDoubleQuote, "
        },
        {
          "lineNum": 416,
          "content": "          inTemplateLiteral: inTemplateLiteral, // Keep outer template literal state unchanged"
        },
        {
          "lineNum": 417,
          "content": "          resetTemplateExpression: false"
        },
        {
          "lineNum": 418,
          "content": "        };"
        },
        {
          "lineNum": 419,
          "content": "      } else {"
        },
        {
          "lineNum": 420,
          "content": "        // Not inside ${...} - toggle template literal state normally"
        },
        {
          "lineNum": 421,
          "content": "        const newTemplateLiteral = !inTemplateLiteral;"
        },
        {
          "lineNum": 422,
          "content": "        return { "
        },
        {
          "lineNum": 423,
          "content": "          inSingleQuote, "
        },
        {
          "lineNum": 424,
          "content": "          inDoubleQuote, "
        },
        {
          "lineNum": 425,
          "content": "          inTemplateLiteral: newTemplateLiteral,"
        },
        {
          "lineNum": 426,
          "content": "          resetTemplateExpression: !newTemplateLiteral"
        },
        {
          "lineNum": 427,
          "content": "        };"
        },
        {
          "lineNum": 428,
          "content": "      }"
        },
        {
          "lineNum": 429,
          "content": "    }"
        },
        {
          "lineNum": 430,
          "content": "    return { "
        },
        {
          "lineNum": 431,
          "content": "      inSingleQuote, "
        },
        {
          "lineNum": 432,
          "content": "      inDoubleQuote, "
        },
        {
          "lineNum": 433,
          "content": "      inTemplateLiteral,"
        },
        {
          "lineNum": 434,
          "content": "      resetTemplateExpression: false"
        },
        {
          "lineNum": 435,
          "content": "    };"
        },
        {
          "lineNum": 436,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "trackParameterListBoundaries",
      "file": "scripts/decision-points.js",
      "line": 902,
      "actualComplexity": 10,
      "calculatedTotal": 7,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for",
          "line": 905,
          "name": "for loop"
        },
        {
          "type": "if",
          "line": 908,
          "name": "if statement"
        },
        {
          "type": "else if",
          "line": 910,
          "name": "else if statement"
        },
        {
          "type": "else if",
          "line": 912,
          "name": "else if statement"
        },
        {
          "type": "if",
          "line": 914,
          "name": "if statement"
        },
        {
          "type": "else if",
          "line": 918,
          "name": "else if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 3,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 902,
        "end": 934
      },
      "functionCode": [
        {
          "lineNum": 902,
          "content": "  const trackParameterListBoundaries = (checkLine, checkLineNum, boundaryStart, state) => {"
        },
        {
          "lineNum": 903,
          "content": "    let currentState = { ...state };"
        },
        {
          "lineNum": 904,
          "content": "    "
        },
        {
          "lineNum": 905,
          "content": "    for (let j = 0; j < checkLine.length; j++) {"
        },
        {
          "lineNum": 906,
          "content": "      const char = checkLine[j];"
        },
        {
          "lineNum": 907,
          "content": "      "
        },
        {
          "lineNum": 908,
          "content": "      if (char === '(') {"
        },
        {
          "lineNum": 909,
          "content": "        currentState = handleOpeningParen(currentState);"
        },
        {
          "lineNum": 910,
          "content": "      } else if (char === ')') {"
        },
        {
          "lineNum": 911,
          "content": "        currentState = handleClosingParen(currentState);"
        },
        {
          "lineNum": 912,
          "content": "      } else if (char === '{') {"
        },
        {
          "lineNum": 913,
          "content": "        const braceResult = handleOpeningBrace(checkLine, checkLineNum, boundaryStart, currentState);"
        },
        {
          "lineNum": 914,
          "content": "        if (typeof braceResult === 'number') {"
        },
        {
          "lineNum": 915,
          "content": "          return braceResult;"
        },
        {
          "lineNum": 916,
          "content": "        }"
        },
        {
          "lineNum": 917,
          "content": "        currentState = braceResult;"
        },
        {
          "lineNum": 918,
          "content": "      } else if (char === '}') {"
        },
        {
          "lineNum": 919,
          "content": "        currentState = {"
        },
        {
          "lineNum": 920,
          "content": "          ...currentState,"
        },
        {
          "lineNum": 921,
          "content": "          braceDepth: currentState.braceDepth - 1"
        },
        {
          "lineNum": 922,
          "content": "        };"
        },
        {
          "lineNum": 923,
          "content": "      }"
        },
        {
          "lineNum": 924,
          "content": "      "
        },
        {
          "lineNum": 925,
          "content": "      // Check if we've found the closing paren after processing this character"
        },
        {
          "lineNum": 926,
          "content": "      // For destructured parameters like }: Type), we need parenDepth = 0 and braceDepth = 0"
        },
        {
          "lineNum": 927,
          "content": "      if (currentState.foundClosingParen && currentState.parenDepth === 0 && currentState.braceDepth === 0) {"
        },
        {
          "lineNum": 928,
          "content": "        return checkLineNum;"
        },
        {
          "lineNum": 929,
          "content": "      }"
        },
        {
          "lineNum": 930,
          "content": "    }"
        },
        {
          "lineNum": 931,
          "content": "    "
        },
        {
          "lineNum": 932,
          "content": "    // Return updated state so it can be used in next iteration"
        },
        {
          "lineNum": 933,
          "content": "    return currentState;"
        },
        {
          "lineNum": 934,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "parseDecisionPoints",
      "file": "scripts/decision-points.js",
      "line": 8,
      "actualComplexity": 9,
      "calculatedTotal": 10,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 8,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 509,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 613,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 1198,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 1198,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 1335,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 1335,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 9
      },
      "boundary": {
        "start": 8,
        "end": 1406
      },
      "functionCode": [
        {
          "lineNum": 8,
          "content": "export function parseDecisionPoints(sourceCode, functionBoundaries, functions = []) {"
        },
        {
          "lineNum": 9,
          "content": "  const decisionPoints = [];"
        },
        {
          "lineNum": 10,
          "content": "  const lines = sourceCode.split('\\n');"
        },
        {
          "lineNum": 11,
          "content": "  "
        },
        {
          "lineNum": 12,
          "content": "  // Create a reverse map: line number -> array of function lines that contain it"
        },
        {
          "lineNum": 13,
          "content": "  // We'll assign decision points to the innermost function"
        },
        {
          "lineNum": 14,
          "content": "  const lineToFunctions = new Map();"
        },
        {
          "lineNum": 15,
          "content": "  functionBoundaries.forEach((boundary, functionLine) => {"
        },
        {
          "lineNum": 16,
          "content": "    for (let line = boundary.start; line <= boundary.end; line++) {"
        },
        {
          "lineNum": 17,
          "content": "      if (!lineToFunctions.has(line)) {"
        },
        {
          "lineNum": 18,
          "content": "        lineToFunctions.set(line, []);"
        },
        {
          "lineNum": 19,
          "content": "      }"
        },
        {
          "lineNum": 20,
          "content": "      lineToFunctions.get(line).push({ functionLine, boundary });"
        },
        {
          "lineNum": 21,
          "content": "    }"
        },
        {
          "lineNum": 22,
          "content": "  });"
        },
        {
          "lineNum": 23,
          "content": "  "
        },
        {
          "lineNum": 24,
          "content": "  // Helper functions for finding innermost function"
        },
        {
          "lineNum": 25,
          "content": "  "
        },
        {
          "lineNum": 26,
          "content": "  /**"
        },
        {
          "lineNum": 27,
          "content": "   * Filters functions to only those that actually contain the line"
        },
        {
          "lineNum": 28,
          "content": "   * @param {Array} containingFunctions - Array of functions"
        },
        {
          "lineNum": 29,
          "content": "   * @param {number} lineNum - Line number"
        },
        {
          "lineNum": 30,
          "content": "   * @returns {Array} Valid functions that contain the line"
        },
        {
          "lineNum": 31,
          "content": "   */"
        },
        {
          "lineNum": 32,
          "content": "  const getValidFunctions = (containingFunctions, lineNum) => {"
        },
        {
          "lineNum": 33,
          "content": "    return containingFunctions.filter(f => "
        },
        {
          "lineNum": 34,
          "content": "      f.boundary.start <= lineNum && lineNum <= f.boundary.end"
        },
        {
          "lineNum": 35,
          "content": "    );"
        },
        {
          "lineNum": 36,
          "content": "  };"
        },
        {
          "lineNum": 37,
          "content": "  "
        },
        {
          "lineNum": 38,
          "content": "  /**"
        },
        {
          "lineNum": 39,
          "content": "   * Finds the immediate parent function"
        },
        {
          "lineNum": 40,
          "content": "   * @param {Array} sortedFunctions - Functions sorted by start line"
        },
        {
          "lineNum": 41,
          "content": "   * @param {number} lineNum - Line number"
        },
        {
          "lineNum": 42,
          "content": "   * @returns {Object|null} Immediate parent function or null"
        },
        {
          "lineNum": 43,
          "content": "   */"
        },
        {
          "lineNum": 44,
          "content": "  const findImmediateParent = (sortedFunctions, lineNum) => {"
        },
        {
          "lineNum": 45,
          "content": "    return sortedFunctions"
        },
        {
          "lineNum": 46,
          "content": "      .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
        },
        {
          "lineNum": 47,
          "content": "      .sort((a, b) => {"
        },
        {
          "lineNum": 48,
          "content": "        const aSize = a.boundary.end - a.boundary.start;"
        },
        {
          "lineNum": 49,
          "content": "        const bSize = b.boundary.end - b.boundary.start;"
        },
        {
          "lineNum": 50,
          "content": "        if (aSize !== bSize) {"
        },
        {
          "lineNum": 51,
          "content": "          return aSize - bSize;"
        },
        {
          "lineNum": 52,
          "content": "        }"
        },
        {
          "lineNum": 53,
          "content": "        return b.boundary.start - a.boundary.start;"
        },
        {
          "lineNum": 54,
          "content": "      })[0] || null;"
        },
        {
          "lineNum": 55,
          "content": "  };"
        },
        {
          "lineNum": 56,
          "content": "  "
        },
        {
          "lineNum": 57,
          "content": "  /**"
        }
      ]
    },
    {
      "functionName": "isQuestionMarkInRegularString",
      "file": "scripts/decision-points.js",
      "line": 1615,
      "actualComplexity": 9,
      "calculatedTotal": 7,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for",
          "line": 1623,
          "name": "for loop"
        },
        {
          "type": "&&",
          "line": 1623,
          "name": "logical AND"
        },
        {
          "type": "ternary",
          "line": 1625,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 1630,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1636,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1647,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1615,
        "end": 1665
      },
      "functionCode": [
        {
          "lineNum": 1615,
          "content": "  const isQuestionMarkInRegularString = (line, questionIndex) => {"
        },
        {
          "lineNum": 1616,
          "content": "    let inSingleQuote = false;"
        },
        {
          "lineNum": 1617,
          "content": "    let inDoubleQuote = false;"
        },
        {
          "lineNum": 1618,
          "content": "    let inTemplateLiteral = false;"
        },
        {
          "lineNum": 1619,
          "content": "    let inTemplateExpression = false;"
        },
        {
          "lineNum": 1620,
          "content": "    let templateBraceDepth = 0;"
        },
        {
          "lineNum": 1621,
          "content": "    let escapeNext = false;"
        },
        {
          "lineNum": 1622,
          "content": "    "
        },
        {
          "lineNum": 1623,
          "content": "    for (let k = 0; k < questionIndex && k < line.length; k++) {"
        },
        {
          "lineNum": 1624,
          "content": "      const char = line[k];"
        },
        {
          "lineNum": 1625,
          "content": "      const nextChar = k + 1 < line.length ? line[k + 1] : '';"
        },
        {
          "lineNum": 1626,
          "content": "      "
        },
        {
          "lineNum": 1627,
          "content": "      // Handle escape sequences"
        },
        {
          "lineNum": 1628,
          "content": "      const escapeResult = handleEscapeSequence(char, escapeNext);"
        },
        {
          "lineNum": 1629,
          "content": "      escapeNext = escapeResult.escapeNext;"
        },
        {
          "lineNum": 1630,
          "content": "      if (escapeResult.shouldContinue) {"
        },
        {
          "lineNum": 1631,
          "content": "        continue;"
        },
        {
          "lineNum": 1632,
          "content": "      }"
        },
        {
          "lineNum": 1633,
          "content": "      "
        },
        {
          "lineNum": 1634,
          "content": "      // Handle template literal expression start"
        },
        {
          "lineNum": 1635,
          "content": "      const templateStart = handleTemplateExpressionStart(char, nextChar, inTemplateLiteral, inTemplateExpression);"
        },
        {
          "lineNum": 1636,
          "content": "      if (templateStart.shouldSkipNext) {"
        },
        {
          "lineNum": 1637,
          "content": "        inTemplateExpression = templateStart.inTemplateExpression;"
        },
        {
          "lineNum": 1638,
          "content": "        templateBraceDepth = templateStart.templateBraceDepth;"
        },
        {
          "lineNum": 1639,
          "content": "        k++; // Skip the '{'"
        },
        {
          "lineNum": 1640,
          "content": "        continue;"
        },
        {
          "lineNum": 1641,
          "content": "      }"
        },
        {
          "lineNum": 1642,
          "content": "      "
        },
        {
          "lineNum": 1643,
          "content": "      // Track brace depth in template expressions"
        },
        {
          "lineNum": 1644,
          "content": "      const braceResult = trackTemplateExpressionBraces(char, inTemplateExpression, templateBraceDepth);"
        },
        {
          "lineNum": 1645,
          "content": "      inTemplateExpression = braceResult.inTemplateExpression;"
        },
        {
          "lineNum": 1646,
          "content": "      templateBraceDepth = braceResult.templateBraceDepth;"
        },
        {
          "lineNum": 1647,
          "content": "      if (inTemplateExpression) {"
        },
        {
          "lineNum": 1648,
          "content": "        continue; // Don't process quotes/backticks inside template expressions"
        },
        {
          "lineNum": 1649,
          "content": "      }"
        },
        {
          "lineNum": 1650,
          "content": "      "
        },
        {
          "lineNum": 1651,
          "content": "      // Update quote states"
        },
        {
          "lineNum": 1652,
          "content": "      const quoteResult = updateQuoteStates(char, inSingleQuote, inDoubleQuote, inTemplateLiteral);"
        },
        {
          "lineNum": 1653,
          "content": "      inSingleQuote = quoteResult.inSingleQuote;"
        },
        {
          "lineNum": 1654,
          "content": "      inDoubleQuote = quoteResult.inDoubleQuote;"
        },
        {
          "lineNum": 1655,
          "content": "      inTemplateLiteral = quoteResult.inTemplateLiteral;"
        },
        {
          "lineNum": 1656,
          "content": "      "
        },
        {
          "lineNum": 1657,
          "content": "      // Reset template expression when template literal ends"
        },
        {
          "lineNum": 1658,
          "content": "      if (!inTemplateLiteral) {"
        },
        {
          "lineNum": 1659,
          "content": "        inTemplateExpression = false;"
        },
        {
          "lineNum": 1660,
          "content": "        templateBraceDepth = 0;"
        },
        {
          "lineNum": 1661,
          "content": "      }"
        },
        {
          "lineNum": 1662,
          "content": "    }"
        },
        {
          "lineNum": 1663,
          "content": "    "
        },
        {
          "lineNum": 1664,
          "content": "    return inSingleQuote || inDoubleQuote;"
        }
      ]
    },
    {
      "functionName": "processSubsequentLine",
      "file": "scripts/decision-points.js",
      "line": 2068,
      "actualComplexity": 9,
      "calculatedTotal": 4,
      "difference": -5,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for",
          "line": 2071,
          "name": "for loop"
        },
        {
          "type": "ternary",
          "line": 2073,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 2080,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2068,
        "end": 2103
      },
      "functionCode": [
        {
          "lineNum": 2068,
          "content": "  const processSubsequentLine = (currentScanLine, depths, startDepths, isJSXTernary, isInsideStringLiteral, scanLineIndex, startIndex) => {"
        },
        {
          "lineNum": 2069,
          "content": "    let currentDepths = { ...depths };"
        },
        {
          "lineNum": 2070,
          "content": "    "
        },
        {
          "lineNum": 2071,
          "content": "    for (let i = 0; i < currentScanLine.length; i++) {"
        },
        {
          "lineNum": 2072,
          "content": "      const char = currentScanLine[i];"
        },
        {
          "lineNum": 2073,
          "content": "      const nextChar = i + 1 < currentScanLine.length ? currentScanLine[i + 1] : '';"
        },
        {
          "lineNum": 2074,
          "content": "      "
        },
        {
          "lineNum": 2075,
          "content": "      // Update nesting depths"
        },
        {
          "lineNum": 2076,
          "content": "      const updated = updateNestingDepths(char, nextChar, currentDepths, startDepths, isInsideStringLiteral, currentScanLine, i);"
        },
        {
          "lineNum": 2077,
          "content": "      currentDepths = updated;"
        },
        {
          "lineNum": 2078,
          "content": "      "
        },
        {
          "lineNum": 2079,
          "content": "      // Check if we should break"
        },
        {
          "lineNum": 2080,
          "content": "      if (shouldBreakSubsequentLineSearch(char, updated.shouldBreak, scanLineIndex, startIndex)) {"
        },
        {
          "lineNum": 2081,
          "content": "        return { depths: currentDepths, matchFound: false, shouldBreak: true };"
        },
        {
          "lineNum": 2082,
          "content": "      }"
        },
        {
          "lineNum": 2083,
          "content": "      "
        },
        {
          "lineNum": 2084,
          "content": "      // If we hit a :, check if it's our matching colon"
        },
        {
          "lineNum": 2085,
          "content": "      if (char === ':') {"
        },
        {
          "lineNum": 2086,
          "content": "        const colonResult = handleColonInSubsequentLines(currentDepths, startDepths, isJSXTernary);"
        },
        {
          "lineNum": 2087,
          "content": "        if (colonResult === true) {"
        },
        {
          "lineNum": 2088,
          "content": "          return { depths: currentDepths, matchFound: true, shouldBreak: false };"
        },
        {
          "lineNum": 2089,
          "content": "        }"
        },
        {
          "lineNum": 2090,
          "content": "        if (colonResult === null) {"
        },
        {
          "lineNum": 2091,
          "content": "          currentDepths.ternaryDepth--;"
        },
        {
          "lineNum": 2092,
          "content": "          continue;"
        },
        {
          "lineNum": 2093,
          "content": "        }"
        },
        {
          "lineNum": 2094,
          "content": "      }"
        },
        {
          "lineNum": 2095,
          "content": "      "
        },
        {
          "lineNum": 2096,
          "content": "      // Stop at semicolon if depths match"
        },
        {
          "lineNum": 2097,
          "content": "      if (char === ';' && shouldStopAtSemicolon(currentDepths, startDepths)) {"
        },
        {
          "lineNum": 2098,
          "content": "        return { depths: currentDepths, matchFound: false, shouldBreak: true };"
        },
        {
          "lineNum": 2099,
          "content": "      }"
        },
        {
          "lineNum": 2100,
          "content": "    }"
        },
        {
          "lineNum": 2101,
          "content": "    "
        },
        {
          "lineNum": 2102,
          "content": "    return { depths: currentDepths, matchFound: false, shouldBreak: false };"
        },
        {
          "lineNum": 2103,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "isInDestructuredAssignment",
      "file": "scripts/decision-points.js",
      "line": 3110,
      "actualComplexity": 9,
      "calculatedTotal": 8,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 3112,
          "name": "if statement"
        },
        {
          "type": "for",
          "line": 3117,
          "name": "for loop"
        },
        {
          "type": "&&",
          "line": 3117,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3121,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3126,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 3126,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3131,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 4,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 2,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3110,
        "end": 3143
      },
      "functionCode": [
        {
          "lineNum": 3110,
          "content": "  const isInDestructuredAssignment = (lineWithoutComments, index, lineNum, lines, boundary) => {"
        },
        {
          "lineNum": 3111,
          "content": "    // Check if current line starts destructuring"
        },
        {
          "lineNum": 3112,
          "content": "    if (/^\\s*(const|let|var)\\s+\\{/.test(lineWithoutComments)) {"
        },
        {
          "lineNum": 3113,
          "content": "      return true;"
        },
        {
          "lineNum": 3114,
          "content": "    }"
        },
        {
          "lineNum": 3115,
          "content": "    "
        },
        {
          "lineNum": 3116,
          "content": "    // Look backwards up to 10 lines to find destructuring start"
        },
        {
          "lineNum": 3117,
          "content": "    for (let lookBack = 1; lookBack <= 10 && index - lookBack >= 0; lookBack++) {"
        },
        {
          "lineNum": 3118,
          "content": "      const prevLine = lines[index - lookBack].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
        },
        {
          "lineNum": 3119,
          "content": "      "
        },
        {
          "lineNum": 3120,
          "content": "      // Check if previous line starts destructuring"
        },
        {
          "lineNum": 3121,
          "content": "      if (/^\\s*(const|let|var)\\s+\\{/.test(prevLine)) {"
        },
        {
          "lineNum": 3122,
          "content": "        return true;"
        },
        {
          "lineNum": 3123,
          "content": "      }"
        },
        {
          "lineNum": 3124,
          "content": "      "
        },
        {
          "lineNum": 3125,
          "content": "      // Stop if we hit a closing brace followed by = (end of destructuring: } = obj)"
        },
        {
          "lineNum": 3126,
          "content": "      if (prevLine.includes('}') && prevLine.includes('=')) {"
        },
        {
          "lineNum": 3127,
          "content": "        break;"
        },
        {
          "lineNum": 3128,
          "content": "      }"
        },
        {
          "lineNum": 3129,
          "content": "      "
        },
        {
          "lineNum": 3130,
          "content": "      // Stop if we hit a semicolon (end of statement)"
        },
        {
          "lineNum": 3131,
          "content": "      if (prevLine.endsWith(';')) {"
        },
        {
          "lineNum": 3132,
          "content": "        break;"
        },
        {
          "lineNum": 3133,
          "content": "      }"
        },
        {
          "lineNum": 3134,
          "content": "      "
        },
        {
          "lineNum": 3135,
          "content": "      // Stop if we're past the function start"
        },
        {
          "lineNum": 3136,
          "content": "      const prevLineNum = lineNum - lookBack;"
        },
        {
          "lineNum": 3137,
          "content": "      if (prevLineNum < boundary.start) {"
        },
        {
          "lineNum": 3138,
          "content": "        break;"
        },
        {
          "lineNum": 3139,
          "content": "      }"
        },
        {
          "lineNum": 3140,
          "content": "    }"
        },
        {
          "lineNum": 3141,
          "content": "    "
        },
        {
          "lineNum": 3142,
          "content": "    return false;"
        },
        {
          "lineNum": 3143,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "parseDestructuredAssignments",
      "file": "scripts/decision-points.js",
      "line": 3155,
      "actualComplexity": 9,
      "calculatedTotal": 4,
      "difference": -5,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 3157,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 3157,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 3157,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3155,
        "end": 3186
      },
      "functionCode": [
        {
          "lineNum": 3155,
          "content": "  const parseDestructuredAssignments = (lineWithoutComments, lineNum, index, lines, functionLine, boundary, decisionPoints) => {"
        },
        {
          "lineNum": 3156,
          "content": "    // Only check if this is near the start of the function (first 15 lines)"
        },
        {
          "lineNum": 3157,
          "content": "    if (!boundary || lineNum < boundary.start || lineNum > boundary.start + 15) {"
        },
        {
          "lineNum": 3158,
          "content": "      return;"
        },
        {
          "lineNum": 3159,
          "content": "    }"
        },
        {
          "lineNum": 3160,
          "content": "    "
        },
        {
          "lineNum": 3161,
          "content": "    // Check if this line has a default parameter pattern (prop = value)"
        },
        {
          "lineNum": 3162,
          "content": "    // Include booleans, numbers, strings, etc."
        },
        {
          "lineNum": 3163,
          "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?![=<>])(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,}\\s]+)/g;"
        },
        {
          "lineNum": 3164,
          "content": "    const hasDefaultParam = defaultParamPattern.test(lineWithoutComments);"
        },
        {
          "lineNum": 3165,
          "content": "    "
        },
        {
          "lineNum": 3166,
          "content": "    if (!hasDefaultParam) {"
        },
        {
          "lineNum": 3167,
          "content": "      return;"
        },
        {
          "lineNum": 3168,
          "content": "    }"
        },
        {
          "lineNum": 3169,
          "content": "    "
        },
        {
          "lineNum": 3170,
          "content": "    // Check if we're in a destructured assignment"
        },
        {
          "lineNum": 3171,
          "content": "    const inDestructuredAssignment = isInDestructuredAssignment(lineWithoutComments, index, lineNum, lines, boundary);"
        },
        {
          "lineNum": 3172,
          "content": "    "
        },
        {
          "lineNum": 3173,
          "content": "    // EXCLUDE regular const/let/var assignments that are NOT destructuring"
        },
        {
          "lineNum": 3174,
          "content": "    const isRegularAssignment = /^\\s*(const|let|var)\\s+[a-zA-Z_$][a-zA-Z0-9_$]*\\s*=\\s*(?!\\{)/.test(lineWithoutComments);"
        },
        {
          "lineNum": 3175,
          "content": "    "
        },
        {
          "lineNum": 3176,
          "content": "    if (inDestructuredAssignment && !isRegularAssignment) {"
        },
        {
          "lineNum": 3177,
          "content": "      // Match all default parameters on this line"
        },
        {
          "lineNum": 3178,
          "content": "      const defaultParamMatches = lineWithoutComments.match(defaultParamPattern);"
        },
        {
          "lineNum": 3179,
          "content": "      if (defaultParamMatches && defaultParamMatches.length > 0) {"
        },
        {
          "lineNum": 3180,
          "content": "        // Count each default parameter in the destructured assignment"
        },
        {
          "lineNum": 3181,
          "content": "        defaultParamMatches.forEach(() => {"
        },
        {
          "lineNum": 3182,
          "content": "          decisionPoints.push({ line: lineNum, type: 'default parameter', name: 'default parameter', functionLine });"
        },
        {
          "lineNum": 3183,
          "content": "        });"
        },
        {
          "lineNum": 3184,
          "content": "      }"
        },
        {
          "lineNum": 3185,
          "content": "    }"
        },
        {
          "lineNum": 3186,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processSwitchAndCatch",
      "file": "scripts/decision-points.js",
      "line": 3399,
      "actualComplexity": 9,
      "calculatedTotal": 11,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 3402,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 3404,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3406,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3407,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3412,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 3412,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 3419,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 3421,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3423,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3424,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 7,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 2,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3399,
        "end": 3426
      },
      "functionCode": [
        {
          "lineNum": 3399,
          "content": "  const processSwitchAndCatch = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 3400,
          "content": "    // Switch statement"
        },
        {
          "lineNum": 3401,
          "content": "    const isSwitchStatement = /^\\s*switch\\s*\\(/.test(lineWithoutComments);"
        },
        {
          "lineNum": 3402,
          "content": "    if (isSwitchStatement) {"
        },
        {
          "lineNum": 3403,
          "content": "      decisionPoints.push({ line: lineNum, type: 'switch', name: 'switch statement', functionLine });"
        },
        {
          "lineNum": 3404,
          "content": "      const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 3405,
          "content": "      const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 3406,
          "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3407,
          "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3408,
          "content": "      return;"
        },
        {
          "lineNum": 3409,
          "content": "    }"
        },
        {
          "lineNum": 3410,
          "content": "    "
        },
        {
          "lineNum": 3411,
          "content": "    // Case statements"
        },
        {
          "lineNum": 3412,
          "content": "    if (/^\\s*case\\s+/.test(lineWithoutComments) || /^\\s*default\\s*:/.test(lineWithoutComments)) {"
        },
        {
          "lineNum": 3413,
          "content": "      decisionPoints.push({ line: lineNum, type: 'case', name: 'case/default', functionLine });"
        },
        {
          "lineNum": 3414,
          "content": "      return;"
        },
        {
          "lineNum": 3415,
          "content": "    }"
        },
        {
          "lineNum": 3416,
          "content": "    "
        },
        {
          "lineNum": 3417,
          "content": "    // Catch blocks"
        },
        {
          "lineNum": 3418,
          "content": "    const isCatchBlock = /\\bcatch\\s*[({]/.test(lineWithoutComments);"
        },
        {
          "lineNum": 3419,
          "content": "    if (isCatchBlock) {"
        },
        {
          "lineNum": 3420,
          "content": "      decisionPoints.push({ line: lineNum, type: 'catch', name: 'catch block', functionLine });"
        },
        {
          "lineNum": 3421,
          "content": "      const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 3422,
          "content": "      const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 3423,
          "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3424,
          "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3425,
          "content": "    }"
        },
        {
          "lineNum": 3426,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "checkJSXAttribute",
      "file": "scripts/decision-points.js",
      "line": 1125,
      "actualComplexity": 8,
      "calculatedTotal": 5,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 1126,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 1126,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 1131,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1131,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1125,
        "end": 1134
      },
      "functionCode": [
        {
          "lineNum": 1125,
          "content": "  const checkJSXAttribute = (lineWithoutComments, index, lines) => {"
        },
        {
          "lineNum": 1126,
          "content": "    if (index >= 0 && lines.length > 0) {"
        },
        {
          "lineNum": 1127,
          "content": "      return isJSXAttributeLine(lineWithoutComments, index, lines);"
        },
        {
          "lineNum": 1128,
          "content": "    }"
        },
        {
          "lineNum": 1129,
          "content": "    // Fallback for single-line check (backward compatibility)"
        },
        {
          "lineNum": 1130,
          "content": "    const hasJSXExpression = /\\{[^}]*\\}/.test(lineWithoutComments);"
        },
        {
          "lineNum": 1131,
          "content": "    const hasJSXTag = /<[A-Za-z]/.test(lineWithoutComments) || /<\\/[A-Za-z]/.test(lineWithoutComments) || /\\/>/.test(lineWithoutComments);"
        },
        {
          "lineNum": 1132,
          "content": "    const hasJSXAttributePattern = /^\\s*\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments) || /\\s+\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments);"
        },
        {
          "lineNum": 1133,
          "content": "    return (hasJSXExpression || hasJSXTag) && hasJSXAttributePattern;"
        },
        {
          "lineNum": 1134,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findMatchingColonOnSameLine",
      "file": "scripts/decision-points.js",
      "line": 1842,
      "actualComplexity": 8,
      "calculatedTotal": 4,
      "difference": -4,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for",
          "line": 1851,
          "name": "for loop"
        },
        {
          "type": "ternary",
          "line": 1853,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 1859,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1842,
        "end": 1882
      },
      "functionCode": [
        {
          "lineNum": 1842,
          "content": "  const findMatchingColonOnSameLine = (line, questionIndex, startDepths, isInsideStringLiteral) => {"
        },
        {
          "lineNum": 1843,
          "content": "    let depths = {"
        },
        {
          "lineNum": 1844,
          "content": "      parenDepth: startDepths.parenDepth,"
        },
        {
          "lineNum": 1845,
          "content": "      braceDepth: startDepths.braceDepth,"
        },
        {
          "lineNum": 1846,
          "content": "      bracketDepth: startDepths.bracketDepth,"
        },
        {
          "lineNum": 1847,
          "content": "      ternaryDepth: 0"
        },
        {
          "lineNum": 1848,
          "content": "    };"
        },
        {
          "lineNum": 1849,
          "content": "    const isJSX = isJSXTernary(line, questionIndex);"
        },
        {
          "lineNum": 1850,
          "content": "    "
        },
        {
          "lineNum": 1851,
          "content": "    for (let i = questionIndex + 1; i < line.length; i++) {"
        },
        {
          "lineNum": 1852,
          "content": "      const char = line[i];"
        },
        {
          "lineNum": 1853,
          "content": "      const nextChar = i + 1 < line.length ? line[i + 1] : '';"
        },
        {
          "lineNum": 1854,
          "content": "      "
        },
        {
          "lineNum": 1855,
          "content": "      // Update nesting depths"
        },
        {
          "lineNum": 1856,
          "content": "      const updated = updateSameLineDepths(char, nextChar, depths, isInsideStringLiteral, line, i);"
        },
        {
          "lineNum": 1857,
          "content": "      depths = updated;"
        },
        {
          "lineNum": 1858,
          "content": "      "
        },
        {
          "lineNum": 1859,
          "content": "      if (updated.shouldBreak) {"
        },
        {
          "lineNum": 1860,
          "content": "        break;"
        },
        {
          "lineNum": 1861,
          "content": "      }"
        },
        {
          "lineNum": 1862,
          "content": "      "
        },
        {
          "lineNum": 1863,
          "content": "      // If we hit a :, check if it's our matching colon"
        },
        {
          "lineNum": 1864,
          "content": "      if (char === ':') {"
        },
        {
          "lineNum": 1865,
          "content": "        const colonResult = handleColonInSameLine(depths, startDepths);"
        },
        {
          "lineNum": 1866,
          "content": "        if (colonResult === true) {"
        },
        {
          "lineNum": 1867,
          "content": "          return true;"
        },
        {
          "lineNum": 1868,
          "content": "        }"
        },
        {
          "lineNum": 1869,
          "content": "        if (colonResult === null) {"
        },
        {
          "lineNum": 1870,
          "content": "          depths.ternaryDepth--;"
        },
        {
          "lineNum": 1871,
          "content": "          continue;"
        },
        {
          "lineNum": 1872,
          "content": "        }"
        },
        {
          "lineNum": 1873,
          "content": "      }"
        },
        {
          "lineNum": 1874,
          "content": "      "
        },
        {
          "lineNum": 1875,
          "content": "      // Stop if we hit certain characters"
        },
        {
          "lineNum": 1876,
          "content": "      if (shouldStopSameLineAtChar(char, depths, startDepths, isJSX)) {"
        },
        {
          "lineNum": 1877,
          "content": "        break;"
        },
        {
          "lineNum": 1878,
          "content": "      }"
        },
        {
          "lineNum": 1879,
          "content": "    }"
        },
        {
          "lineNum": 1880,
          "content": "    "
        },
        {
          "lineNum": 1881,
          "content": "    return false;"
        },
        {
          "lineNum": 1882,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "detectMultiLineTernaries",
      "file": "scripts/decision-points.js",
      "line": 2151,
      "actualComplexity": 8,
      "calculatedTotal": 7,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 2155,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 2162,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 2164,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 2164,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 2165,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 2165,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 4,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2151,
        "end": 2174
      },
      "functionCode": [
        {
          "lineNum": 2151,
          "content": "  const detectMultiLineTernaries = (lineWithoutComments, index, lines, hasQuestionMarkOutsideString) => {"
        },
        {
          "lineNum": 2152,
          "content": "    const hasQuestionMark = hasQuestionMarkOutsideString(lineWithoutComments);"
        },
        {
          "lineNum": 2153,
          "content": "    const hasColon = lineWithoutComments.includes(':');"
        },
        {
          "lineNum": 2154,
          "content": "    "
        },
        {
          "lineNum": 2155,
          "content": "    const nextLine = index + 1 < lines.length ? lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
        },
        {
          "lineNum": 2156,
          "content": "    const nextLineHasColon = nextLine.includes(':');"
        },
        {
          "lineNum": 2157,
          "content": "    const nextLineHasQuestionMark = hasQuestionMarkOutsideString(nextLine);"
        },
        {
          "lineNum": 2158,
          "content": "    "
        },
        {
          "lineNum": 2159,
          "content": "    const prevLine = index > 0 ? lines[index - 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
        },
        {
          "lineNum": 2160,
          "content": "    const prevLineHasQuestionMark = hasQuestionMarkOutsideString(prevLine);"
        },
        {
          "lineNum": 2161,
          "content": "    "
        },
        {
          "lineNum": 2162,
          "content": "    const isMultiLineTernaryWithQuestionOnThisLine = hasQuestionMark && nextLineHasColon;"
        },
        {
          "lineNum": 2163,
          "content": "    // Check if this line is a ternary condition line (has &&/|| but ? is on previous OR next line)"
        },
        {
          "lineNum": 2164,
          "content": "    const isMultiLineTernaryConditionLine = !hasQuestionMark && !hasColon && "
        },
        {
          "lineNum": 2165,
          "content": "                                            (prevLineHasQuestionMark || nextLineHasQuestionMark) && "
        },
        {
          "lineNum": 2166,
          "content": "                                            /[&|]{2}/.test(lineWithoutComments);"
        },
        {
          "lineNum": 2167,
          "content": "    "
        },
        {
          "lineNum": 2168,
          "content": "    return {"
        },
        {
          "lineNum": 2169,
          "content": "      isMultiLineTernaryWithQuestionOnThisLine,"
        },
        {
          "lineNum": 2170,
          "content": "      isMultiLineTernaryConditionLine,"
        },
        {
          "lineNum": 2171,
          "content": "      hasQuestionMark,"
        },
        {
          "lineNum": 2172,
          "content": "      prevLine"
        },
        {
          "lineNum": 2173,
          "content": "    };"
        },
        {
          "lineNum": 2174,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "getFunctionLineForControlStructure",
      "file": "scripts/decision-points.js",
      "line": 3535,
      "actualComplexity": 8,
      "calculatedTotal": 6,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 3536,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3546,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3558,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3564,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3570,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 5,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3535,
        "end": 3600
      },
      "functionCode": [
        {
          "lineNum": 3535,
          "content": "  const getFunctionLineForControlStructure = (isControlStructure, lineNum, containingFunctions, functionBoundaries, getInnermostFunction) => {"
        },
        {
          "lineNum": 3536,
          "content": "    if (!isControlStructure) {"
        },
        {
          "lineNum": 3537,
          "content": "      return getInnermostFunction(lineNum);"
        },
        {
          "lineNum": 3538,
          "content": "    }"
        },
        {
          "lineNum": 3539,
          "content": "    "
        },
        {
          "lineNum": 3540,
          "content": "    // For control structures, find the immediate parent function (not nested callbacks, not outermost function)"
        },
        {
          "lineNum": 3541,
          "content": "    // Filter to functions that actually contain this line"
        },
        {
          "lineNum": 3542,
          "content": "    const validFunctions = containingFunctions.filter(f => "
        },
        {
          "lineNum": 3543,
          "content": "      f.boundary.start <= lineNum && lineNum <= f.boundary.end"
        },
        {
          "lineNum": 3544,
          "content": "    );"
        },
        {
          "lineNum": 3545,
          "content": "    "
        },
        {
          "lineNum": 3546,
          "content": "    if (validFunctions.length === 0) {"
        },
        {
          "lineNum": 3547,
          "content": "      return getInnermostFunction(lineNum);"
        },
        {
          "lineNum": 3548,
          "content": "    }"
        },
        {
          "lineNum": 3549,
          "content": "    "
        },
        {
          "lineNum": 3550,
          "content": "    // Sort by start line (earliest first)"
        },
        {
          "lineNum": 3551,
          "content": "    const sortedFunctions = [...validFunctions].sort((a, b) => a.boundary.start - b.boundary.start);"
        },
        {
          "lineNum": 3552,
          "content": "    "
        },
        {
          "lineNum": 3553,
          "content": "    // Find nested functions starting on this line (callbacks)"
        },
        {
          "lineNum": 3554,
          "content": "    const nestedFunctionsOnThisLine = sortedFunctions.filter(f => "
        },
        {
          "lineNum": 3555,
          "content": "      f.boundary.start === lineNum && f.boundary.start > sortedFunctions[0].boundary.start"
        },
        {
          "lineNum": 3556,
          "content": "    );"
        },
        {
          "lineNum": 3557,
          "content": "    "
        },
        {
          "lineNum": 3558,
          "content": "    if (nestedFunctionsOnThisLine.length > 0) {"
        },
        {
          "lineNum": 3559,
          "content": "      // There are nested callbacks on this line - find the immediate parent (not the outermost)"
        },
        {
          "lineNum": 3560,
          "content": "      const nonNestedFunctions = sortedFunctions.filter(f => "
        },
        {
          "lineNum": 3561,
          "content": "        !nestedFunctionsOnThisLine.some(nested => nested.functionLine === f.functionLine)"
        },
        {
          "lineNum": 3562,
          "content": "      );"
        },
        {
          "lineNum": 3563,
          "content": "      "
        },
        {
          "lineNum": 3564,
          "content": "      if (nonNestedFunctions.length > 0) {"
        },
        {
          "lineNum": 3565,
          "content": "        // Find the function that starts most recently before this line (immediate parent)"
        },
        {
          "lineNum": 3566,
          "content": "        const immediateParent = nonNestedFunctions"
        },
        {
          "lineNum": 3567,
          "content": "          .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
        },
        {
          "lineNum": 3568,
          "content": "          .sort((a, b) => b.boundary.start - a.boundary.start)[0]; // Most recent start"
        },
        {
          "lineNum": 3569,
          "content": "        "
        },
        {
          "lineNum": 3570,
          "content": "        if (immediateParent) {"
        },
        {
          "lineNum": 3571,
          "content": "          return immediateParent.functionLine;"
        },
        {
          "lineNum": 3572,
          "content": "        }"
        },
        {
          "lineNum": 3573,
          "content": "        // Fallback: use the first non-nested function"
        },
        {
          "lineNum": 3574,
          "content": "        return nonNestedFunctions[0].functionLine;"
        },
        {
          "lineNum": 3575,
          "content": "      }"
        },
        {
          "lineNum": 3576,
          "content": "      // Fallback: use normal innermost function logic"
        },
        {
          "lineNum": 3577,
          "content": "      return getInnermostFunction(lineNum);"
        },
        {
          "lineNum": 3578,
          "content": "    }"
        },
        {
          "lineNum": 3579,
          "content": "    "
        },
        {
          "lineNum": 3580,
          "content": "    // No nested callbacks on this line - but check if we're after nested callbacks have ended"
        },
        {
          "lineNum": 3581,
          "content": "    const allContainingFunctions = Array.from(functionBoundaries.entries())"
        },
        {
          "lineNum": 3582,
          "content": "      .filter(([fl, b]) => b.start <= lineNum && lineNum <= b.end);"
        },
        {
          "lineNum": 3583,
          "content": "    "
        },
        {
          "lineNum": 3584,
          "content": "    if (allContainingFunctions.length > 1) {"
        }
      ]
    },
    {
      "functionName": "hasFunctionSignature",
      "file": "scripts/decision-points.js",
      "line": 1008,
      "actualComplexity": 7,
      "calculatedTotal": 9,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1009,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1009,
          "name": "ternary operator"
        },
        {
          "type": "||",
          "line": 1009,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1010,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1011,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1012,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1013,
          "name": "logical OR"
        },
        {
          "type": "&&",
          "line": 1014,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 2,
        "&&": 1,
        "||": 5,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1008,
        "end": 1015
      },
      "functionCode": [
        {
          "lineNum": 1008,
          "content": "  const hasFunctionSignature = (lineWithoutComments, isArrowFunctionParam) => {"
        },
        {
          "lineNum": 1009,
          "content": "    return /^\\s*(?:export\\s+)?(?:function|const|let|var)\\s+\\w+\\s*[=(]/.test(lineWithoutComments) ||"
        },
        {
          "lineNum": 1010,
          "content": "           /^\\s*\\([^)]*/.test(lineWithoutComments) ||"
        },
        {
          "lineNum": 1011,
          "content": "           /=>\\s*\\([^)]*/.test(lineWithoutComments) ||"
        },
        {
          "lineNum": 1012,
          "content": "           /\\.\\w+\\s*\\([^)]*/.test(lineWithoutComments) ||"
        },
        {
          "lineNum": 1013,
          "content": "           /\\([^)]*\\{[^}]*\\}/.test(lineWithoutComments) ||"
        },
        {
          "lineNum": 1014,
          "content": "           (isArrowFunctionParam && /\\(/.test(lineWithoutComments));"
        },
        {
          "lineNum": 1015,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "parseMultiLineConditions",
      "file": "scripts/decision-points.js",
      "line": 3069,
      "actualComplexity": 7,
      "calculatedTotal": 6,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 3096,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 3096,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3096,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3096,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3096,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 4,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3069,
        "end": 3099
      },
      "functionCode": [
        {
          "lineNum": 3069,
          "content": "  const parseMultiLineConditions = (lineWithoutComments, lineNum, index, lines, functionLine, isIfStatement, isElseIfStatement, isForLoop, isWhileLoop, isJSXExpression, isContinuationOfJSXExpression, isBooleanAssignment, isBooleanExpression, decisionPoints) => {"
        },
        {
          "lineNum": 3070,
          "content": "    // EXCLUDE JSX expressions and boolean expressions - they're already handled above"
        },
        {
          "lineNum": 3071,
          "content": "    if (shouldExcludeFromMultiLineConditions(index, isIfStatement, isElseIfStatement, isJSXExpression, isContinuationOfJSXExpression, isBooleanAssignment, isBooleanExpression)) {"
        },
        {
          "lineNum": 3072,
          "content": "      return;"
        },
        {
          "lineNum": 3073,
          "content": "    }"
        },
        {
          "lineNum": 3074,
          "content": "    "
        },
        {
          "lineNum": 3075,
          "content": "    const prevLine = lines[index - 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim();"
        },
        {
          "lineNum": 3076,
          "content": "    const prevLineHasLogicalOp = /[&|]{2}/.test(prevLine);"
        },
        {
          "lineNum": 3077,
          "content": "    const currentLineHasLogicalOp = /[&|]{2}/.test(lineWithoutComments);"
        },
        {
          "lineNum": 3078,
          "content": "    const prevLineIsCondition = isConditionStart(prevLine);"
        },
        {
          "lineNum": 3079,
          "content": "    const prevLineIsBooleanAssignment = isBooleanAssignmentLine(prevLine);"
        },
        {
          "lineNum": 3080,
          "content": "    const prevLineIsBooleanExpression = isBooleanExpressionLine(prevLine);"
        },
        {
          "lineNum": 3081,
          "content": "    "
        },
        {
          "lineNum": 3082,
          "content": "    // Check if we're continuing a multi-line condition"
        },
        {
          "lineNum": 3083,
          "content": "    const isContinuingCondition = isContinuingMultiLineCondition(index, lines, currentLineHasLogicalOp);"
        },
        {
          "lineNum": 3084,
          "content": "    "
        },
        {
          "lineNum": 3085,
          "content": "    // Determine if we should process"
        },
        {
          "lineNum": 3086,
          "content": "    const shouldProcess = shouldProcessMultiLineCondition("
        },
        {
          "lineNum": 3087,
          "content": "      isBooleanAssignment,"
        },
        {
          "lineNum": 3088,
          "content": "      isBooleanExpression,"
        },
        {
          "lineNum": 3089,
          "content": "      prevLineIsCondition,"
        },
        {
          "lineNum": 3090,
          "content": "      currentLineHasLogicalOp,"
        },
        {
          "lineNum": 3091,
          "content": "      prevLineIsBooleanAssignment,"
        },
        {
          "lineNum": 3092,
          "content": "      prevLineIsBooleanExpression,"
        },
        {
          "lineNum": 3093,
          "content": "      isContinuingCondition"
        },
        {
          "lineNum": 3094,
          "content": "    );"
        },
        {
          "lineNum": 3095,
          "content": "    "
        },
        {
          "lineNum": 3096,
          "content": "    if (shouldProcess && !isIfStatement && !isElseIfStatement && !isForLoop && !isWhileLoop) {"
        },
        {
          "lineNum": 3097,
          "content": "      processMultiLineConditionOperators(lineWithoutComments, lineNum, functionLine, decisionPoints);"
        },
        {
          "lineNum": 3098,
          "content": "    }"
        },
        {
          "lineNum": 3099,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "handleArrowFunctionDetection",
      "file": "scripts/decision-points.js",
      "line": 824,
      "actualComplexity": 6,
      "calculatedTotal": 3,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 825,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 830,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 824,
        "end": 843
      },
      "functionCode": [
        {
          "lineNum": 824,
          "content": "  const handleArrowFunctionDetection = (checkLine, lineNum, checkLineNum, lineWithoutComments) => {"
        },
        {
          "lineNum": 825,
          "content": "    if (!checkLine.includes('=>')) {"
        },
        {
          "lineNum": 826,
          "content": "      return null;"
        },
        {
          "lineNum": 827,
          "content": "    }"
        },
        {
          "lineNum": 828,
          "content": "    "
        },
        {
          "lineNum": 829,
          "content": "    const arrowIndex = checkLine.indexOf('=>');"
        },
        {
          "lineNum": 830,
          "content": "    if (lineNum === checkLineNum) {"
        },
        {
          "lineNum": 831,
          "content": "      // Current line is the line with =>, check if we're before it"
        },
        {
          "lineNum": 832,
          "content": "      if (lineWithoutComments.indexOf('=>') === -1 || lineWithoutComments.indexOf('=') < lineWithoutComments.indexOf('=>')) {"
        },
        {
          "lineNum": 833,
          "content": "        return checkLineNum + 1; // Parameter list includes this line"
        },
        {
          "lineNum": 834,
          "content": "      } else {"
        },
        {
          "lineNum": 835,
          "content": "        return checkLineNum; // Parameter list ends before =>"
        },
        {
          "lineNum": 836,
          "content": "      }"
        },
        {
          "lineNum": 837,
          "content": "    } else if (lineNum < checkLineNum) {"
        },
        {
          "lineNum": 838,
          "content": "      // Current line is before the line with =>, so it's in parameter list"
        },
        {
          "lineNum": 839,
          "content": "      return checkLineNum + 1; // Include the line with =>"
        },
        {
          "lineNum": 840,
          "content": "    }"
        },
        {
          "lineNum": 841,
          "content": "    "
        },
        {
          "lineNum": 842,
          "content": "    return null;"
        },
        {
          "lineNum": 843,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "hasJSXInPreviousLines",
      "file": "scripts/decision-points.js",
      "line": 1034,
      "actualComplexity": 6,
      "calculatedTotal": 3,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for",
          "line": 1035,
          "name": "for loop"
        },
        {
          "type": "if",
          "line": 1044,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1034,
        "end": 1054
      },
      "functionCode": [
        {
          "lineNum": 1034,
          "content": "  const hasJSXInPreviousLines = (index, lines) => {"
        },
        {
          "lineNum": 1035,
          "content": "    for (let i = index - 1; i >= Math.max(0, index - 10); i--) {"
        },
        {
          "lineNum": 1036,
          "content": "      const prevLine = lines[i].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '');"
        },
        {
          "lineNum": 1037,
          "content": "      "
        },
        {
          "lineNum": 1038,
          "content": "      // If we find a closing tag, we're not in JSX context"
        },
        {
          "lineNum": 1039,
          "content": "      if (/\\/>/.test(prevLine) || /<\\/[A-Za-z]/.test(prevLine)) {"
        },
        {
          "lineNum": 1040,
          "content": "        return false;"
        },
        {
          "lineNum": 1041,
          "content": "      }"
        },
        {
          "lineNum": 1042,
          "content": "      "
        },
        {
          "lineNum": 1043,
          "content": "      // If we find an opening tag, we're in JSX context"
        },
        {
          "lineNum": 1044,
          "content": "      if (/<[A-Za-z]/.test(prevLine)) {"
        },
        {
          "lineNum": 1045,
          "content": "        return true;"
        },
        {
          "lineNum": 1046,
          "content": "      }"
        },
        {
          "lineNum": 1047,
          "content": "      "
        },
        {
          "lineNum": 1048,
          "content": "      // If we hit a line that's clearly not JSX (like a function declaration or return statement), stop"
        },
        {
          "lineNum": 1049,
          "content": "      if (/^\\s*(function|const|let|var|return|if|for|while)\\s/.test(prevLine)) {"
        },
        {
          "lineNum": 1050,
          "content": "        return false;"
        },
        {
          "lineNum": 1051,
          "content": "      }"
        },
        {
          "lineNum": 1052,
          "content": "    }"
        },
        {
          "lineNum": 1053,
          "content": "    return false;"
        },
        {
          "lineNum": 1054,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "parseDefaultParameters",
      "file": "scripts/decision-points.js",
      "line": 1472,
      "actualComplexity": 6,
      "calculatedTotal": 3,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1474,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 1475,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1472,
        "end": 1519
      },
      "functionCode": [
        {
          "lineNum": 1472,
          "content": "  const parseDefaultParameters = (lineWithoutComments, lineNum, index, lines, functionLine, functionBoundaries, getInnermostFunction, decisionPoints) => {"
        },
        {
          "lineNum": 1473,
          "content": "    const hasArrowFunction = lineWithoutComments.includes('=>');"
        },
        {
          "lineNum": 1474,
          "content": "    const arrowIndex = hasArrowFunction ? lineWithoutComments.indexOf('=>') : -1;"
        },
        {
          "lineNum": 1475,
          "content": "    const isArrowFunctionParam = hasArrowFunction && arrowIndex > 0;"
        },
        {
          "lineNum": 1476,
          "content": "    "
        },
        {
          "lineNum": 1477,
          "content": "    // Determine which function's boundary to use"
        },
        {
          "lineNum": 1478,
          "content": "    let actualFunctionLine = functionLine;"
        },
        {
          "lineNum": 1479,
          "content": "    let boundary = functionBoundaries.get(functionLine);"
        },
        {
          "lineNum": 1480,
          "content": "    "
        },
        {
          "lineNum": 1481,
          "content": "    if (isArrowFunctionParam) {"
        },
        {
          "lineNum": 1482,
          "content": "      const callbackInfo = findCallbackFunctionLine(lineNum, functionLine, functionBoundaries, getInnermostFunction);"
        },
        {
          "lineNum": 1483,
          "content": "      actualFunctionLine = callbackInfo.actualFunctionLine;"
        },
        {
          "lineNum": 1484,
          "content": "      boundary = callbackInfo.boundary;"
        },
        {
          "lineNum": 1485,
          "content": "      "
        },
        {
          "lineNum": 1486,
          "content": "      // Handle arrow function default parameters directly"
        },
        {
          "lineNum": 1487,
          "content": "      handleArrowFunctionDefaultParams(lineWithoutComments, arrowIndex, lineNum, actualFunctionLine, decisionPoints, index, lines);"
        },
        {
          "lineNum": 1488,
          "content": "    }"
        },
        {
          "lineNum": 1489,
          "content": "    "
        },
        {
          "lineNum": 1490,
          "content": "    if (!boundary) return;"
        },
        {
          "lineNum": 1491,
          "content": "    "
        },
        {
          "lineNum": 1492,
          "content": "    const hasFunctionSig = hasFunctionSignature(lineWithoutComments, isArrowFunctionParam);"
        },
        {
          "lineNum": 1493,
          "content": "    let paramListEnd = findParameterListEnd(lineNum, boundary.start, lines, lineWithoutComments);"
        },
        {
          "lineNum": 1494,
          "content": "    paramListEnd = applyParameterListEndFallbacks("
        },
        {
          "lineNum": 1495,
          "content": "      paramListEnd,"
        },
        {
          "lineNum": 1496,
          "content": "      boundary.start,"
        },
        {
          "lineNum": 1497,
          "content": "      lineNum,"
        },
        {
          "lineNum": 1498,
          "content": "      index,"
        },
        {
          "lineNum": 1499,
          "content": "      lines,"
        },
        {
          "lineNum": 1500,
          "content": "      lineWithoutComments,"
        },
        {
          "lineNum": 1501,
          "content": "      hasFunctionSig"
        },
        {
          "lineNum": 1502,
          "content": "    );"
        },
        {
          "lineNum": 1503,
          "content": "    "
        },
        {
          "lineNum": 1504,
          "content": "    if (shouldProcessDefaultParameters(lineWithoutComments, lineNum, index, lines, boundary, isArrowFunctionParam, hasFunctionSig, paramListEnd)) {"
        },
        {
          "lineNum": 1505,
          "content": "      processNonArrowDefaultParameters("
        },
        {
          "lineNum": 1506,
          "content": "        lineWithoutComments,"
        },
        {
          "lineNum": 1507,
          "content": "        lineNum,"
        },
        {
          "lineNum": 1508,
          "content": "        index,"
        },
        {
          "lineNum": 1509,
          "content": "        lines,"
        },
        {
          "lineNum": 1510,
          "content": "        arrowIndex,"
        },
        {
          "lineNum": 1511,
          "content": "        isArrowFunctionParam,"
        },
        {
          "lineNum": 1512,
          "content": "        boundary,"
        },
        {
          "lineNum": 1513,
          "content": "        hasFunctionSig,"
        },
        {
          "lineNum": 1514,
          "content": "        paramListEnd,"
        },
        {
          "lineNum": 1515,
          "content": "        functionLine,"
        },
        {
          "lineNum": 1516,
          "content": "        decisionPoints"
        },
        {
          "lineNum": 1517,
          "content": "      );"
        },
        {
          "lineNum": 1518,
          "content": "    }"
        },
        {
          "lineNum": 1519,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "shouldSkipQuestionMark",
      "file": "scripts/decision-points.js",
      "line": 2262,
      "actualComplexity": 6,
      "calculatedTotal": 1,
      "difference": -5,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2262,
        "end": 2284
      },
      "functionCode": [
        {
          "lineNum": 2262,
          "content": "  const shouldSkipQuestionMark = (lineWithoutComments, questionIndex) => {"
        },
        {
          "lineNum": 2263,
          "content": "    // Skip if it's optional chaining (?.)"
        },
        {
          "lineNum": 2264,
          "content": "    if (questionIndex + 1 < lineWithoutComments.length && lineWithoutComments[questionIndex + 1] === '.') {"
        },
        {
          "lineNum": 2265,
          "content": "      return 2;"
        },
        {
          "lineNum": 2266,
          "content": "    }"
        },
        {
          "lineNum": 2267,
          "content": "    "
        },
        {
          "lineNum": 2268,
          "content": "    // Skip if inside a regex pattern (e.g., /(?:export\\s+)?function/)"
        },
        {
          "lineNum": 2269,
          "content": "    if (isInsideRegexPattern(lineWithoutComments, questionIndex)) {"
        },
        {
          "lineNum": 2270,
          "content": "      return 1;"
        },
        {
          "lineNum": 2271,
          "content": "    }"
        },
        {
          "lineNum": 2272,
          "content": "    "
        },
        {
          "lineNum": 2273,
          "content": "    // Skip if inside a regular string literal"
        },
        {
          "lineNum": 2274,
          "content": "    if (isQuestionMarkInRegularString(lineWithoutComments, questionIndex)) {"
        },
        {
          "lineNum": 2275,
          "content": "      return 1;"
        },
        {
          "lineNum": 2276,
          "content": "    }"
        },
        {
          "lineNum": 2277,
          "content": "    "
        },
        {
          "lineNum": 2278,
          "content": "    // Skip if TypeScript optional parameter"
        },
        {
          "lineNum": 2279,
          "content": "    if (isTypeScriptOptionalParameter(lineWithoutComments, questionIndex)) {"
        },
        {
          "lineNum": 2280,
          "content": "      return 1;"
        },
        {
          "lineNum": 2281,
          "content": "    }"
        },
        {
          "lineNum": 2282,
          "content": "    "
        },
        {
          "lineNum": 2283,
          "content": "    return 0;"
        },
        {
          "lineNum": 2284,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findBooleanExpressionFunctionLine",
      "file": "scripts/decision-points.js",
      "line": 2580,
      "actualComplexity": 6,
      "calculatedTotal": 5,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 2584,
          "name": "if statement"
        },
        {
          "type": "ternary",
          "line": 2592,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 2591,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 2596,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2580,
        "end": 2616
      },
      "functionCode": [
        {
          "lineNum": 2580,
          "content": "  const findBooleanExpressionFunctionLine = (lineWithoutComments, lineNum, operatorIndex, functionLine, functionBoundaries) => {"
        },
        {
          "lineNum": 2581,
          "content": "    const callbacksOnThisLine = Array.from(functionBoundaries.entries())"
        },
        {
          "lineNum": 2582,
          "content": "      .filter(([fl, b]) => b.start === lineNum);"
        },
        {
          "lineNum": 2583,
          "content": "    "
        },
        {
          "lineNum": 2584,
          "content": "    if (callbacksOnThisLine.length === 0) {"
        },
        {
          "lineNum": 2585,
          "content": "      return functionLine;"
        },
        {
          "lineNum": 2586,
          "content": "    }"
        },
        {
          "lineNum": 2587,
          "content": "    "
        },
        {
          "lineNum": 2588,
          "content": "    // Find where callbacks start (look for => or function keyword)"
        },
        {
          "lineNum": 2589,
          "content": "    const callbackStartPattern = /(?:=>|function\\s*\\()/;"
        },
        {
          "lineNum": 2590,
          "content": "    const callbackStartMatch = lineWithoutComments.match(callbackStartPattern);"
        },
        {
          "lineNum": 2591,
          "content": "    const callbackStartIndex = callbackStartMatch && callbackStartMatch.index !== undefined "
        },
        {
          "lineNum": 2592,
          "content": "      ? callbackStartMatch.index "
        },
        {
          "lineNum": 2593,
          "content": "      : -1;"
        },
        {
          "lineNum": 2594,
          "content": "    "
        },
        {
          "lineNum": 2595,
          "content": "    // If operator appears before any callback starts, it belongs to the parent function"
        },
        {
          "lineNum": 2596,
          "content": "    if (callbackStartIndex > operatorIndex) {"
        },
        {
          "lineNum": 2597,
          "content": "      // Find parent function (function that contains this line but isn't a callback on this line)"
        },
        {
          "lineNum": 2598,
          "content": "      const parentFunctions = Array.from(functionBoundaries.entries())"
        },
        {
          "lineNum": 2599,
          "content": "        .filter(([fl, b]) => "
        },
        {
          "lineNum": 2600,
          "content": "          b.start <= lineNum && lineNum <= b.end && "
        },
        {
          "lineNum": 2601,
          "content": "          !callbacksOnThisLine.some(([cfl]) => cfl === fl)"
        },
        {
          "lineNum": 2602,
          "content": "        );"
        },
        {
          "lineNum": 2603,
          "content": "      "
        },
        {
          "lineNum": 2604,
          "content": "      if (parentFunctions.length > 0) {"
        },
        {
          "lineNum": 2605,
          "content": "        // Use the most recent parent (smallest boundary that's larger than callbacks)"
        },
        {
          "lineNum": 2606,
          "content": "        const sortedParents = parentFunctions.sort((a, b) => {"
        },
        {
          "lineNum": 2607,
          "content": "          const aSize = a[1].end - a[1].start;"
        },
        {
          "lineNum": 2608,
          "content": "          const bSize = b[1].end - b[1].start;"
        },
        {
          "lineNum": 2609,
          "content": "          return aSize - bSize; // Prefer smaller boundary (more nested parent)"
        },
        {
          "lineNum": 2610,
          "content": "        });"
        },
        {
          "lineNum": 2611,
          "content": "        return sortedParents[0][0];"
        },
        {
          "lineNum": 2612,
          "content": "      }"
        },
        {
          "lineNum": 2613,
          "content": "    }"
        },
        {
          "lineNum": 2614,
          "content": "    "
        },
        {
          "lineNum": 2615,
          "content": "    return functionLine;"
        },
        {
          "lineNum": 2616,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "shouldStopConditionLookback",
      "file": "scripts/decision-points.js",
      "line": 2949,
      "actualComplexity": 6,
      "calculatedTotal": 3,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 2951,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 2952,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2949,
        "end": 2967
      },
      "functionCode": [
        {
          "lineNum": 2949,
          "content": "  const shouldStopConditionLookback = (checkLine, checkLineHasLogicalOp, checkLineIsBooleanAssignment) => {"
        },
        {
          "lineNum": 2950,
          "content": "    // Skip if this is a JSX expression line"
        },
        {
          "lineNum": 2951,
          "content": "    const checkLineIsJSX = checkLine.includes('{') && /[&|]{2}/.test(checkLine);"
        },
        {
          "lineNum": 2952,
          "content": "    if (checkLineIsJSX) {"
        },
        {
          "lineNum": 2953,
          "content": "      return true;"
        },
        {
          "lineNum": 2954,
          "content": "    }"
        },
        {
          "lineNum": 2955,
          "content": "    "
        },
        {
          "lineNum": 2956,
          "content": "    // Skip boolean assignments - they're handled separately"
        },
        {
          "lineNum": 2957,
          "content": "    if (checkLineIsBooleanAssignment) {"
        },
        {
          "lineNum": 2958,
          "content": "      return true;"
        },
        {
          "lineNum": 2959,
          "content": "    }"
        },
        {
          "lineNum": 2960,
          "content": "    "
        },
        {
          "lineNum": 2961,
          "content": "    // Stop if we hit a closing brace or semicolon (end of condition)"
        },
        {
          "lineNum": 2962,
          "content": "    if (/[;}]/.test(checkLine) && !checkLineHasLogicalOp) {"
        },
        {
          "lineNum": 2963,
          "content": "      return true;"
        },
        {
          "lineNum": 2964,
          "content": "    }"
        },
        {
          "lineNum": 2965,
          "content": "    "
        },
        {
          "lineNum": 2966,
          "content": "    return false;"
        },
        {
          "lineNum": 2967,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "detectMultiLineArrowParameter",
      "file": "scripts/decision-points.js",
      "line": 735,
      "actualComplexity": 5,
      "calculatedTotal": 4,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 741,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 741,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 741,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 3,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 735,
        "end": 742
      },
      "functionCode": [
        {
          "lineNum": 735,
          "content": "  const detectMultiLineArrowParameter = (lineWithoutComments, index, lines) => {"
        },
        {
          "lineNum": 736,
          "content": "    // Check for default parameters including booleans, numbers, strings, etc."
        },
        {
          "lineNum": 737,
          "content": "    const hasDefaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/.test(lineWithoutComments);"
        },
        {
          "lineNum": 738,
          "content": "    const hasOpeningParen = lineWithoutComments.includes('(');"
        },
        {
          "lineNum": 739,
          "content": "    const hasArrowOnLaterLine = index + 1 < lines.length && "
        },
        {
          "lineNum": 740,
          "content": "                                lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').includes('=>');"
        },
        {
          "lineNum": 741,
          "content": "    return hasDefaultParamPattern && hasOpeningParen && hasArrowOnLaterLine && !lineWithoutComments.includes('=>');"
        },
        {
          "lineNum": 742,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findMatchingColonForTernary",
      "file": "scripts/decision-points.js",
      "line": 2297,
      "actualComplexity": 5,
      "calculatedTotal": 1,
      "difference": -4,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2297,
        "end": 2320
      },
      "functionCode": [
        {
          "lineNum": 2297,
          "content": "  const findMatchingColonForTernary = (lineWithoutComments, questionIndex, index, lines, startDepths, jsxTernary, isInsideStringLiteral) => {"
        },
        {
          "lineNum": 2298,
          "content": "    // Try to find matching colon on the same line"
        },
        {
          "lineNum": 2299,
          "content": "    let foundColon = findMatchingColonOnSameLine("
        },
        {
          "lineNum": 2300,
          "content": "      lineWithoutComments,"
        },
        {
          "lineNum": 2301,
          "content": "      questionIndex,"
        },
        {
          "lineNum": 2302,
          "content": "      startDepths,"
        },
        {
          "lineNum": 2303,
          "content": "      isInsideStringLiteral"
        },
        {
          "lineNum": 2304,
          "content": "    );"
        },
        {
          "lineNum": 2305,
          "content": "    "
        },
        {
          "lineNum": 2306,
          "content": "    // If not found and it's a JSX ternary, scan subsequent lines"
        },
        {
          "lineNum": 2307,
          "content": "    if (!foundColon && jsxTernary && index < lines.length - 1) {"
        },
        {
          "lineNum": 2308,
          "content": "      const maxScanLines = jsxTernary ? 20 : 10;"
        },
        {
          "lineNum": 2309,
          "content": "      foundColon = findMatchingColonOnSubsequentLines("
        },
        {
          "lineNum": 2310,
          "content": "        lines,"
        },
        {
          "lineNum": 2311,
          "content": "        index,"
        },
        {
          "lineNum": 2312,
          "content": "        maxScanLines,"
        },
        {
          "lineNum": 2313,
          "content": "        startDepths,"
        },
        {
          "lineNum": 2314,
          "content": "        jsxTernary,"
        },
        {
          "lineNum": 2315,
          "content": "        isInsideStringLiteral"
        },
        {
          "lineNum": 2316,
          "content": "      );"
        },
        {
          "lineNum": 2317,
          "content": "    }"
        },
        {
          "lineNum": 2318,
          "content": "    "
        },
        {
          "lineNum": 2319,
          "content": "    return foundColon;"
        },
        {
          "lineNum": 2320,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findAllTernaryOperators",
      "file": "scripts/decision-points.js",
      "line": 2330,
      "actualComplexity": 5,
      "calculatedTotal": 3,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "while",
          "line": 2334,
          "name": "while loop"
        },
        {
          "type": "if",
          "line": 2337,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 1,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2330,
        "end": 2372
      },
      "functionCode": [
        {
          "lineNum": 2330,
          "content": "  const findAllTernaryOperators = (lineWithoutComments, index, lines, isInsideStringLiteral) => {"
        },
        {
          "lineNum": 2331,
          "content": "    const ternaryMatches = [];"
        },
        {
          "lineNum": 2332,
          "content": "    let ternarySearchIndex = 0;"
        },
        {
          "lineNum": 2333,
          "content": "    "
        },
        {
          "lineNum": 2334,
          "content": "    while ((ternarySearchIndex = lineWithoutComments.indexOf('?', ternarySearchIndex)) !== -1) {"
        },
        {
          "lineNum": 2335,
          "content": "      // Check if we should skip this question mark (optional chaining, regex, etc.)"
        },
        {
          "lineNum": 2336,
          "content": "      const skipCount = shouldSkipQuestionMark(lineWithoutComments, ternarySearchIndex);"
        },
        {
          "lineNum": 2337,
          "content": "      if (skipCount > 0) {"
        },
        {
          "lineNum": 2338,
          "content": "        ternarySearchIndex += skipCount;"
        },
        {
          "lineNum": 2339,
          "content": "        continue;"
        },
        {
          "lineNum": 2340,
          "content": "      }"
        },
        {
          "lineNum": 2341,
          "content": "      "
        },
        {
          "lineNum": 2342,
          "content": "      // IMPORTANT: Check if this question mark is inside a string literal"
        },
        {
          "lineNum": 2343,
          "content": "      // If it is, skip it entirely (don't count it as a ternary operator)"
        },
        {
          "lineNum": 2344,
          "content": "      if (isInsideStringLiteral(lineWithoutComments, ternarySearchIndex)) {"
        },
        {
          "lineNum": 2345,
          "content": "        ternarySearchIndex++;"
        },
        {
          "lineNum": 2346,
          "content": "        continue;"
        },
        {
          "lineNum": 2347,
          "content": "      }"
        },
        {
          "lineNum": 2348,
          "content": "      "
        },
        {
          "lineNum": 2349,
          "content": "      // Calculate nesting depths up to this question mark"
        },
        {
          "lineNum": 2350,
          "content": "      const startDepths = calculateNestingDepths(lineWithoutComments, ternarySearchIndex);"
        },
        {
          "lineNum": 2351,
          "content": "      const jsxTernary = isJSXTernary(lineWithoutComments, ternarySearchIndex);"
        },
        {
          "lineNum": 2352,
          "content": "      "
        },
        {
          "lineNum": 2353,
          "content": "      // Find matching colon"
        },
        {
          "lineNum": 2354,
          "content": "      const foundColon = findMatchingColonForTernary("
        },
        {
          "lineNum": 2355,
          "content": "        lineWithoutComments,"
        },
        {
          "lineNum": 2356,
          "content": "        ternarySearchIndex,"
        },
        {
          "lineNum": 2357,
          "content": "        index,"
        },
        {
          "lineNum": 2358,
          "content": "        lines,"
        },
        {
          "lineNum": 2359,
          "content": "        startDepths,"
        },
        {
          "lineNum": 2360,
          "content": "        jsxTernary,"
        },
        {
          "lineNum": 2361,
          "content": "        isInsideStringLiteral"
        },
        {
          "lineNum": 2362,
          "content": "      );"
        },
        {
          "lineNum": 2363,
          "content": "      "
        },
        {
          "lineNum": 2364,
          "content": "      if (foundColon) {"
        },
        {
          "lineNum": 2365,
          "content": "        ternaryMatches.push({ index: ternarySearchIndex });"
        },
        {
          "lineNum": 2366,
          "content": "      }"
        },
        {
          "lineNum": 2367,
          "content": "      "
        },
        {
          "lineNum": 2368,
          "content": "      ternarySearchIndex++;"
        },
        {
          "lineNum": 2369,
          "content": "    }"
        },
        {
          "lineNum": 2370,
          "content": "    "
        },
        {
          "lineNum": 2371,
          "content": "    return ternaryMatches;"
        },
        {
          "lineNum": 2372,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processPreviousLineLogicalOperators",
      "file": "scripts/decision-points.js",
      "line": 2395,
      "actualComplexity": 5,
      "calculatedTotal": 6,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 2396,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 2396,
          "name": "logical OR"
        },
        {
          "type": "&&",
          "line": 2400,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 2402,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 2403,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2395,
        "end": 2404
      },
      "functionCode": [
        {
          "lineNum": 2395,
          "content": "  const processPreviousLineLogicalOperators = (prevLine, prevLineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 2396,
          "content": "    if (!prevLine || !/[&|]{2}/.test(prevLine)) {"
        },
        {
          "lineNum": 2397,
          "content": "      return;"
        },
        {
          "lineNum": 2398,
          "content": "    }"
        },
        {
          "lineNum": 2399,
          "content": "    "
        },
        {
          "lineNum": 2400,
          "content": "    const prevAndMatches = prevLine.match(/&&/g);"
        },
        {
          "lineNum": 2401,
          "content": "    const prevOrMatches = prevLine.match(/\\|\\|/g);"
        },
        {
          "lineNum": 2402,
          "content": "    if (prevAndMatches) prevAndMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 2403,
          "content": "    if (prevOrMatches) prevOrMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 2404,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "applyParameterListEndFallbacks",
      "file": "scripts/decision-points.js",
      "line": 703,
      "actualComplexity": 4,
      "calculatedTotal": 1,
      "difference": -3,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 703,
        "end": 726
      },
      "functionCode": [
        {
          "lineNum": 703,
          "content": "  const applyParameterListEndFallbacks = (paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, hasFunctionSig) => {"
        },
        {
          "lineNum": 704,
          "content": "    // Match default parameters: identifier = value (including booleans, numbers, strings, etc.)"
        },
        {
          "lineNum": 705,
          "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
        },
        {
          "lineNum": 706,
          "content": "    "
        },
        {
          "lineNum": 707,
          "content": "    // Try fallback 1"
        },
        {
          "lineNum": 708,
          "content": "    const fallback1Result = applyFallback1FunctionDeclaration(paramListEnd, boundaryStart, lineNum, hasFunctionSig, lineWithoutComments, defaultParamPattern);"
        },
        {
          "lineNum": 709,
          "content": "    if (fallback1Result !== null) {"
        },
        {
          "lineNum": 710,
          "content": "      return fallback1Result;"
        },
        {
          "lineNum": 711,
          "content": "    }"
        },
        {
          "lineNum": 712,
          "content": "    "
        },
        {
          "lineNum": 713,
          "content": "    // Try fallback 2"
        },
        {
          "lineNum": 714,
          "content": "    const fallback2Result = applyFallback2ArrowOnLaterLine(paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, defaultParamPattern);"
        },
        {
          "lineNum": 715,
          "content": "    if (fallback2Result !== null) {"
        },
        {
          "lineNum": 716,
          "content": "      return fallback2Result;"
        },
        {
          "lineNum": 717,
          "content": "    }"
        },
        {
          "lineNum": 718,
          "content": "    "
        },
        {
          "lineNum": 719,
          "content": "    // Try fallback 3"
        },
        {
          "lineNum": 720,
          "content": "    const fallback3Result = applyFallback3OpeningParen(paramListEnd, boundaryStart, lineNum, index, lines, lineWithoutComments, defaultParamPattern);"
        },
        {
          "lineNum": 721,
          "content": "    if (fallback3Result !== null) {"
        },
        {
          "lineNum": 722,
          "content": "      return fallback3Result;"
        },
        {
          "lineNum": 723,
          "content": "    }"
        },
        {
          "lineNum": 724,
          "content": "    "
        },
        {
          "lineNum": 725,
          "content": "    return paramListEnd;"
        },
        {
          "lineNum": 726,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "isJSXAttributeLine",
      "file": "scripts/decision-points.js",
      "line": 1063,
      "actualComplexity": 4,
      "calculatedTotal": 1,
      "difference": -3,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1063,
        "end": 1073
      },
      "functionCode": [
        {
          "lineNum": 1063,
          "content": "  const isJSXAttributeLine = (lineWithoutComments, index, lines) => {"
        },
        {
          "lineNum": 1064,
          "content": "    // Check for JSX attribute pattern: identifier = \"value\" or identifier = {expression}"
        },
        {
          "lineNum": 1065,
          "content": "    const hasJSXAttributePattern = /^\\s*\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments) || /\\s+\\w+\\s*=\\s*[\"'{]/.test(lineWithoutComments);"
        },
        {
          "lineNum": 1066,
          "content": "    if (!hasJSXAttributePattern) return false;"
        },
        {
          "lineNum": 1067,
          "content": "    "
        },
        {
          "lineNum": 1068,
          "content": "    // Check current line for JSX tag or expression"
        },
        {
          "lineNum": 1069,
          "content": "    if (hasJSXOnCurrentLine(lineWithoutComments)) return true;"
        },
        {
          "lineNum": 1070,
          "content": "    "
        },
        {
          "lineNum": 1071,
          "content": "    // Check previous lines (up to 10 lines back) for JSX tags"
        },
        {
          "lineNum": 1072,
          "content": "    return hasJSXInPreviousLines(index, lines);"
        },
        {
          "lineNum": 1073,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processArrowFunctionDefaultParams",
      "file": "scripts/decision-points.js",
      "line": 1316,
      "actualComplexity": 4,
      "calculatedTotal": 1,
      "difference": -3,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1316,
        "end": 1325
      },
      "functionCode": [
        {
          "lineNum": 1316,
          "content": "  const processArrowFunctionDefaultParams = (lineWithoutComments, paramList, lineNum, actualFunctionLine, index, lines, decisionPoints) => {"
        },
        {
          "lineNum": 1317,
          "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
        },
        {
          "lineNum": 1318,
          "content": "    const defaultParamMatches = paramList.match(defaultParamPattern);"
        },
        {
          "lineNum": 1319,
          "content": "    "
        },
        {
          "lineNum": 1320,
          "content": "    if (defaultParamMatches && defaultParamMatches.length > 0) {"
        },
        {
          "lineNum": 1321,
          "content": "      if (isValidArrowFunctionDefaultParameterContext(lineWithoutComments, index, lines)) {"
        },
        {
          "lineNum": 1322,
          "content": "        processDefaultParameterMatches(defaultParamMatches, lineNum, actualFunctionLine, decisionPoints);"
        },
        {
          "lineNum": 1323,
          "content": "      }"
        },
        {
          "lineNum": 1324,
          "content": "    }"
        },
        {
          "lineNum": 1325,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "parseDecisionPoints (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 15,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 16,
          "name": "default parameter"
        },
        {
          "type": "for",
          "line": 16,
          "name": "for loop"
        },
        {
          "type": "if",
          "line": 17,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 1,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 15,
        "end": 22
      },
      "functionCode": [
        {
          "lineNum": 15,
          "content": "  functionBoundaries.forEach((boundary, functionLine) => {"
        },
        {
          "lineNum": 16,
          "content": "    for (let line = boundary.start; line <= boundary.end; line++) {"
        },
        {
          "lineNum": 17,
          "content": "      if (!lineToFunctions.has(line)) {"
        },
        {
          "lineNum": 18,
          "content": "        lineToFunctions.set(line, []);"
        },
        {
          "lineNum": 19,
          "content": "      }"
        },
        {
          "lineNum": 20,
          "content": "      lineToFunctions.get(line).push({ functionLine, boundary });"
        },
        {
          "lineNum": 21,
          "content": "    }"
        },
        {
          "lineNum": 22,
          "content": "  });"
        }
      ]
    },
    {
      "functionName": "matchDefaultParameters",
      "file": "scripts/decision-points.js",
      "line": 802,
      "actualComplexity": 3,
      "calculatedTotal": 1,
      "difference": -2,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 802,
        "end": 814
      },
      "functionCode": [
        {
          "lineNum": 802,
          "content": "  const matchDefaultParameters = (lineWithoutComments, isArrowFunctionParam, arrowIndex) => {"
        },
        {
          "lineNum": 803,
          "content": "    // Match default parameters: identifier = value"
        },
        {
          "lineNum": 804,
          "content": "    // Values can be: strings (\"...\", '...', `...`), booleans (true, false), numbers, or other expressions"
        },
        {
          "lineNum": 805,
          "content": "    const defaultParamPattern = /\\b([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|`[^`]*`|\\b(?:true|false|null|undefined)\\b|\\d+(?:\\.\\d+)?|[^=,)\\s}]+)/g;"
        },
        {
          "lineNum": 806,
          "content": "    "
        },
        {
          "lineNum": 807,
          "content": "    if (isArrowFunctionParam) {"
        },
        {
          "lineNum": 808,
          "content": "      const beforeArrow = lineWithoutComments.substring(0, arrowIndex);"
        },
        {
          "lineNum": 809,
          "content": "      return matchArrowFunctionDefaultParams(lineWithoutComments, beforeArrow, defaultParamPattern);"
        },
        {
          "lineNum": 810,
          "content": "    }"
        },
        {
          "lineNum": 811,
          "content": "    "
        },
        {
          "lineNum": 812,
          "content": "    const matches = lineWithoutComments.match(defaultParamPattern);"
        },
        {
          "lineNum": 813,
          "content": "    return matches || [];"
        },
        {
          "lineNum": 814,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processTernaryLogicalOperators",
      "file": "scripts/decision-points.js",
      "line": 2381,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 2382,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 2384,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 2385,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2381,
        "end": 2386
      },
      "functionCode": [
        {
          "lineNum": 2381,
          "content": "  const processTernaryLogicalOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 2382,
          "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 2383,
          "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 2384,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 2385,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 2386,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processMultiLineTernaryConditionOperators",
      "file": "scripts/decision-points.js",
      "line": 2445,
      "actualComplexity": 3,
      "calculatedTotal": 1,
      "difference": -2,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2445,
        "end": 2453
      },
      "functionCode": [
        {
          "lineNum": 2445,
          "content": "  const processMultiLineTernaryConditionOperators = (lineWithoutComments, lineNum, index, lines, functionLine, hasQuestionMarkOutsideString, decisionPoints) => {"
        },
        {
          "lineNum": 2446,
          "content": "    const nextLine = index + 1 < lines.length ? lines[index + 1].replace(/\\/\\/.*$|\\/\\*[\\s\\S]*?\\*\\//g, '').trim() : '';"
        },
        {
          "lineNum": 2447,
          "content": "    const nextLineHasQuestionMark = hasQuestionMarkOutsideString(nextLine);"
        },
        {
          "lineNum": 2448,
          "content": "    "
        },
        {
          "lineNum": 2449,
          "content": "    // Only process operators if next line doesn't have ? (meaning ? is on previous line, not next line)"
        },
        {
          "lineNum": 2450,
          "content": "    if (!nextLineHasQuestionMark) {"
        },
        {
          "lineNum": 2451,
          "content": "      processTernaryLogicalOperators(lineWithoutComments, lineNum, functionLine, decisionPoints);"
        },
        {
          "lineNum": 2452,
          "content": "    }"
        },
        {
          "lineNum": 2453,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processMultiLineConditionOperators",
      "file": "scripts/decision-points.js",
      "line": 3062,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3063,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3065,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3066,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3062,
        "end": 3067
      },
      "functionCode": [
        {
          "lineNum": 3062,
          "content": "  const processMultiLineConditionOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 3063,
          "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 3064,
          "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 3065,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3066,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3067,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processElseIfStatement",
      "file": "scripts/decision-points.js",
      "line": 3311,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3313,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3315,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3320,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3311,
        "end": 3325
      },
      "functionCode": [
        {
          "lineNum": 3311,
          "content": "  const processElseIfStatement = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 3312,
          "content": "    decisionPoints.push({ line: lineNum, type: 'else if', name: 'else if statement', functionLine });"
        },
        {
          "lineNum": 3313,
          "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 3314,
          "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 3315,
          "content": "    if (andMatches) {"
        },
        {
          "lineNum": 3316,
          "content": "      andMatches.forEach(() => {"
        },
        {
          "lineNum": 3317,
          "content": "        decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine });"
        },
        {
          "lineNum": 3318,
          "content": "      });"
        },
        {
          "lineNum": 3319,
          "content": "    }"
        },
        {
          "lineNum": 3320,
          "content": "    if (orMatches) {"
        },
        {
          "lineNum": 3321,
          "content": "      orMatches.forEach(() => {"
        },
        {
          "lineNum": 3322,
          "content": "        decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine });"
        },
        {
          "lineNum": 3323,
          "content": "      });"
        },
        {
          "lineNum": 3324,
          "content": "    }"
        },
        {
          "lineNum": 3325,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processLoopLogicalOperators",
      "file": "scripts/decision-points.js",
      "line": 3345,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3346,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 3348,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 3349,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3345,
        "end": 3350
      },
      "functionCode": [
        {
          "lineNum": 3345,
          "content": "  const processLoopLogicalOperators = (lineWithoutComments, lineNum, functionLine, decisionPoints) => {"
        },
        {
          "lineNum": 3346,
          "content": "    const andMatches = lineWithoutComments.match(/&&/g);"
        },
        {
          "lineNum": 3347,
          "content": "    const orMatches = lineWithoutComments.match(/\\|\\|/g);"
        },
        {
          "lineNum": 3348,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3349,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3350,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findImmediateParent",
      "file": "scripts/decision-points.js",
      "line": 44,
      "actualComplexity": 2,
      "calculatedTotal": 1,
      "difference": -1,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 44,
        "end": 55
      },
      "functionCode": [
        {
          "lineNum": 44,
          "content": "  const findImmediateParent = (sortedFunctions, lineNum) => {"
        },
        {
          "lineNum": 45,
          "content": "    return sortedFunctions"
        },
        {
          "lineNum": 46,
          "content": "      .filter(f => f.boundary.start < lineNum && f.boundary.end >= lineNum)"
        },
        {
          "lineNum": 47,
          "content": "      .sort((a, b) => {"
        },
        {
          "lineNum": 48,
          "content": "        const aSize = a.boundary.end - a.boundary.start;"
        },
        {
          "lineNum": 49,
          "content": "        const bSize = b.boundary.end - b.boundary.start;"
        },
        {
          "lineNum": 50,
          "content": "        if (aSize !== bSize) {"
        },
        {
          "lineNum": 51,
          "content": "          return aSize - bSize;"
        },
        {
          "lineNum": 52,
          "content": "        }"
        },
        {
          "lineNum": 53,
          "content": "        return b.boundary.start - a.boundary.start;"
        },
        {
          "lineNum": 54,
          "content": "      })[0] || null;"
        },
        {
          "lineNum": 55,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "findImmediateParent (sort callback)",
      "file": "scripts/decision-points.js",
      "line": 47,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 50,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 54,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 47,
        "end": 54
      },
      "functionCode": [
        {
          "lineNum": 47,
          "content": "      .sort((a, b) => {"
        },
        {
          "lineNum": 48,
          "content": "        const aSize = a.boundary.end - a.boundary.start;"
        },
        {
          "lineNum": 49,
          "content": "        const bSize = b.boundary.end - b.boundary.start;"
        },
        {
          "lineNum": 50,
          "content": "        if (aSize !== bSize) {"
        },
        {
          "lineNum": 51,
          "content": "          return aSize - bSize;"
        },
        {
          "lineNum": 52,
          "content": "        }"
        },
        {
          "lineNum": 53,
          "content": "        return b.boundary.start - a.boundary.start;"
        },
        {
          "lineNum": 54,
          "content": "      })[0] || null;"
        }
      ]
    },
    {
      "functionName": "processIfStatementLogicalOperators",
      "file": "scripts/decision-points.js",
      "line": 3288,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3292,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 3295,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 2,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3288,
        "end": 3302
      },
      "functionCode": [
        {
          "lineNum": 3288,
          "content": "  const processIfStatementLogicalOperators = (lineWithoutComments, lineNum, functionLine, functionBoundaries, getInnermostFunction, decisionPoints) => {"
        },
        {
          "lineNum": 3289,
          "content": "    const callbacksOnThisLine = Array.from(functionBoundaries.entries())"
        },
        {
          "lineNum": 3290,
          "content": "      .filter(([fl, boundary]) => boundary.start === lineNum && fl !== functionLine);"
        },
        {
          "lineNum": 3291,
          "content": "    "
        },
        {
          "lineNum": 3292,
          "content": "    const andMatches = Array.from(lineWithoutComments.matchAll(/&&/g));"
        },
        {
          "lineNum": 3293,
          "content": "    const orMatches = Array.from(lineWithoutComments.matchAll(/\\|\\|/g));"
        },
        {
          "lineNum": 3294,
          "content": "    const arrowIndex = lineWithoutComments.indexOf('=>');"
        },
        {
          "lineNum": 3295,
          "content": "    const hasArrowFunction = arrowIndex !== -1 && callbacksOnThisLine.length > 0;"
        },
        {
          "lineNum": 3296,
          "content": "    "
        },
        {
          "lineNum": 3297,
          "content": "    // Process && operators"
        },
        {
          "lineNum": 3298,
          "content": "    processIfStatementOperatorType(andMatches, '&&', 'logical AND', lineWithoutComments, lineNum, functionLine, arrowIndex, hasArrowFunction, callbacksOnThisLine, getInnermostFunction, decisionPoints);"
        },
        {
          "lineNum": 3299,
          "content": "    "
        },
        {
          "lineNum": 3300,
          "content": "    // Process || operators"
        },
        {
          "lineNum": 3301,
          "content": "    processIfStatementOperatorType(orMatches, '||', 'logical OR', lineWithoutComments, lineNum, functionLine, arrowIndex, hasArrowFunction, callbacksOnThisLine, getInnermostFunction, decisionPoints);"
        },
        {
          "lineNum": 3302,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "isTypeScriptOptionalParameter",
      "file": "scripts/decision-points.js",
      "line": 1673,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1677,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1673,
        "end": 1678
      },
      "functionCode": [
        {
          "lineNum": 1673,
          "content": "  const isTypeScriptOptionalParameter = (line, questionIndex) => {"
        },
        {
          "lineNum": 1674,
          "content": "    const contextStart = Math.max(0, questionIndex - 30);"
        },
        {
          "lineNum": 1675,
          "content": "    const contextEnd = Math.min(line.length, questionIndex + 50);"
        },
        {
          "lineNum": 1676,
          "content": "    const context = line.substring(contextStart, contextEnd);"
        },
        {
          "lineNum": 1677,
          "content": "    return /\\b[a-zA-Z_$][a-zA-Z0-9_$]*\\s*\\?\\s*:\\s*[A-Z][a-zA-Z0-9_$<>[\\]]*/.test(context);"
        },
        {
          "lineNum": 1678,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processTernaryLogicalOperators (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 2384,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 2384,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 2385,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2384,
        "end": 2386
      },
      "functionCode": [
        {
          "lineNum": 2384,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 2385,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 2386,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processPreviousLineLogicalOperators (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 2402,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 2402,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 2403,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 2402,
        "end": 2404
      },
      "functionCode": [
        {
          "lineNum": 2402,
          "content": "    if (prevAndMatches) prevAndMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 2403,
          "content": "    if (prevOrMatches) prevOrMatches.forEach(() => decisionPoints.push({ line: prevLineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 2404,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processMultiLineConditionOperators (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 3065,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3065,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 3066,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3065,
        "end": 3067
      },
      "functionCode": [
        {
          "lineNum": 3065,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3066,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3067,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processLoopLogicalOperators (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 3348,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3348,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 3349,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3348,
        "end": 3350
      },
      "functionCode": [
        {
          "lineNum": 3348,
          "content": "    if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3349,
          "content": "    if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3350,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "processSwitchAndCatch (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 3406,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3406,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 3407,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3406,
        "end": 3409
      },
      "functionCode": [
        {
          "lineNum": 3406,
          "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3407,
          "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3408,
          "content": "      return;"
        },
        {
          "lineNum": 3409,
          "content": "    }"
        }
      ]
    },
    {
      "functionName": "processSwitchAndCatch (forEach callback)",
      "file": "scripts/decision-points.js",
      "line": 3423,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 3423,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 3424,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 3423,
        "end": 3425
      },
      "functionCode": [
        {
          "lineNum": 3423,
          "content": "      if (andMatches) andMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '&&', name: 'logical AND', functionLine }));"
        },
        {
          "lineNum": 3424,
          "content": "      if (orMatches) orMatches.forEach(() => decisionPoints.push({ line: lineNum, type: '||', name: 'logical OR', functionLine }));"
        },
        {
          "lineNum": 3425,
          "content": "    }"
        }
      ]
    },
    {
      "functionName": "analyzeMismatches (forEach callback)",
      "file": "scripts/analyze-mismatches.js",
      "line": 68,
      "actualComplexity": 11,
      "calculatedTotal": 10,
      "difference": -1,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "if",
          "line": 81,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 83,
          "name": "logical OR"
        },
        {
          "type": "ternary",
          "line": 88,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 96,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 96,
          "name": "logical AND"
        },
        {
          "type": "else if",
          "line": 98,
          "name": "else if statement"
        },
        {
          "type": "else if",
          "line": 100,
          "name": "else if statement"
        },
        {
          "type": "ternary",
          "line": 115,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 122,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 2,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 3,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 68,
        "end": 129
      },
      "functionCode": [
        {
          "lineNum": 68,
          "content": "      functions.forEach(func => {"
        },
        {
          "lineNum": 69,
          "content": "        const boundary = findBoundaryForFunction(func.line, fileBoundaries);"
        },
        {
          "lineNum": 70,
          "content": "        const breakdown = calculateComplexityBreakdown("
        },
        {
          "lineNum": 71,
          "content": "          func.line,"
        },
        {
          "lineNum": 72,
          "content": "          fileDecisionPoints,"
        },
        {
          "lineNum": 73,
          "content": "          1 // base complexity"
        },
        {
          "lineNum": 74,
          "content": "        );"
        },
        {
          "lineNum": 75,
          "content": ""
        },
        {
          "lineNum": 76,
          "content": "        const actualComplexity = parseInt(func.complexity);"
        },
        {
          "lineNum": 77,
          "content": "        const calculatedTotal = breakdown.calculatedTotal;"
        },
        {
          "lineNum": 78,
          "content": "        const difference = calculatedTotal - actualComplexity;"
        },
        {
          "lineNum": 79,
          "content": ""
        },
        {
          "lineNum": 80,
          "content": "        // Record ALL mismatches (not just those > 1)"
        },
        {
          "lineNum": 81,
          "content": "        if (calculatedTotal !== actualComplexity) {"
        },
        {
          "lineNum": 82,
          "content": "          // Get decision points for this function"
        },
        {
          "lineNum": 83,
          "content": "          const functionDecisionPoints = breakdown.decisionPoints || [];"
        },
        {
          "lineNum": 84,
          "content": "          "
        },
        {
          "lineNum": 85,
          "content": "          // Get source code lines for context"
        },
        {
          "lineNum": 86,
          "content": "          const lines = sourceCode.split('\\n');"
        },
        {
          "lineNum": 87,
          "content": "          const functionCode = boundary "
        },
        {
          "lineNum": 88,
          "content": "            ? lines.slice(boundary.start - 1, boundary.end).map((line, idx) => ({"
        },
        {
          "lineNum": 89,
          "content": "                lineNum: boundary.start + idx,"
        },
        {
          "lineNum": 90,
          "content": "                content: line"
        },
        {
          "lineNum": 91,
          "content": "              }))"
        },
        {
          "lineNum": 92,
          "content": "            : [];"
        },
        {
          "lineNum": 93,
          "content": ""
        },
        {
          "lineNum": 94,
          "content": "          // Categorize the mismatch"
        },
        {
          "lineNum": 95,
          "content": "          let category = 'unknown';"
        },
        {
          "lineNum": 96,
          "content": "          if (functionDecisionPoints.length === 0 && actualComplexity > 1) {"
        },
        {
          "lineNum": 97,
          "content": "            category = '(none)';"
        },
        {
          "lineNum": 98,
          "content": "          } else if (difference < 0) {"
        },
        {
          "lineNum": 99,
          "content": "            category = 'under-counting';"
        },
        {
          "lineNum": 100,
          "content": "          } else if (difference > 0) {"
        },
        {
          "lineNum": 101,
          "content": "            category = 'over-counting';"
        },
        {
          "lineNum": 102,
          "content": "          }"
        },
        {
          "lineNum": 103,
          "content": ""
        },
        {
          "lineNum": 104,
          "content": "          // Check if it's a forEach callback"
        },
        {
          "lineNum": 105,
          "content": "          const isForEachCallback = func.functionName.includes('forEach callback') || "
        },
        {
          "lineNum": 106,
          "content": "                                   func.functionName.includes('forEach');"
        },
        {
          "lineNum": 107,
          "content": ""
        },
        {
          "lineNum": 108,
          "content": "          mismatches.push({"
        },
        {
          "lineNum": 109,
          "content": "            functionName: func.functionName,"
        },
        {
          "lineNum": 110,
          "content": "            file: func.file,"
        },
        {
          "lineNum": 111,
          "content": "            line: func.line,"
        },
        {
          "lineNum": 112,
          "content": "            actualComplexity,"
        },
        {
          "lineNum": 113,
          "content": "            calculatedTotal,"
        },
        {
          "lineNum": 114,
          "content": "            difference,"
        },
        {
          "lineNum": 115,
          "content": "            category: isForEachCallback ? 'forEach callback' : category,"
        },
        {
          "lineNum": 116,
          "content": "            decisionPoints: functionDecisionPoints.map(dp => ({"
        },
        {
          "lineNum": 117,
          "content": "              type: dp.type,"
        }
      ]
    },
    {
      "functionName": "analyzeMismatches",
      "file": "scripts/analyze-mismatches.js",
      "line": 29,
      "actualComplexity": 3,
      "calculatedTotal": 2,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "for...of",
          "line": 52,
          "name": "for...of loop"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 1,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 29,
        "end": 285
      },
      "functionCode": [
        {
          "lineNum": 29,
          "content": "async function analyzeMismatches() {"
        },
        {
          "lineNum": 30,
          "content": "  console.log(' Analyzing complexity mismatches...\\n');"
        },
        {
          "lineNum": 31,
          "content": ""
        },
        {
          "lineNum": 32,
          "content": "  // Run ESLint to collect complexity data"
        },
        {
          "lineNum": 33,
          "content": "  const eslintResults = runESLintComplexityCheck(projectRoot);"
        },
        {
          "lineNum": 34,
          "content": ""
        },
        {
          "lineNum": 35,
          "content": "  // Extract complexity for ALL functions"
        },
        {
          "lineNum": 36,
          "content": "  const allFunctions = extractFunctionsFromESLintResults(eslintResults, projectRoot, extractFunctionName);"
        },
        {
          "lineNum": 37,
          "content": ""
        },
        {
          "lineNum": 38,
          "content": "  // Group functions by file to process source code"
        },
        {
          "lineNum": 39,
          "content": "  const fileMap = new Map();"
        },
        {
          "lineNum": 40,
          "content": "  allFunctions.forEach(func => {"
        },
        {
          "lineNum": 41,
          "content": "    if (!fileMap.has(func.file)) {"
        },
        {
          "lineNum": 42,
          "content": "      fileMap.set(func.file, []);"
        },
        {
          "lineNum": 43,
          "content": "    }"
        },
        {
          "lineNum": 44,
          "content": "    fileMap.get(func.file).push(func);"
        },
        {
          "lineNum": 45,
          "content": "  });"
        },
        {
          "lineNum": 46,
          "content": ""
        },
        {
          "lineNum": 47,
          "content": "  // Process each file"
        },
        {
          "lineNum": 48,
          "content": "  const mismatches = [];"
        },
        {
          "lineNum": 49,
          "content": "  const allDecisionPoints = [];"
        },
        {
          "lineNum": 50,
          "content": "  const allFunctionBoundaries = new Map();"
        },
        {
          "lineNum": 51,
          "content": ""
        },
        {
          "lineNum": 52,
          "content": "  for (const [filePath, functions] of fileMap.entries()) {"
        },
        {
          "lineNum": 53,
          "content": "    try {"
        },
        {
          "lineNum": 54,
          "content": "      const fullPath = resolve(projectRoot, filePath);"
        },
        {
          "lineNum": 55,
          "content": "      const sourceCode = readFileSync(fullPath, 'utf-8');"
        },
        {
          "lineNum": 56,
          "content": ""
        },
        {
          "lineNum": 57,
          "content": "      // Find function boundaries for this file"
        },
        {
          "lineNum": 58,
          "content": "      const fileBoundaries = findFunctionBoundaries(sourceCode, functions);"
        },
        {
          "lineNum": 59,
          "content": "      fileBoundaries.forEach((boundary, functionLine) => {"
        },
        {
          "lineNum": 60,
          "content": "        allFunctionBoundaries.set(functionLine, boundary);"
        },
        {
          "lineNum": 61,
          "content": "      });"
        },
        {
          "lineNum": 62,
          "content": ""
        },
        {
          "lineNum": 63,
          "content": "      // Parse decision points for this file"
        },
        {
          "lineNum": 64,
          "content": "      const fileDecisionPoints = parseDecisionPoints(sourceCode, fileBoundaries, functions);"
        },
        {
          "lineNum": 65,
          "content": "      allDecisionPoints.push(...fileDecisionPoints);"
        },
        {
          "lineNum": 66,
          "content": ""
        },
        {
          "lineNum": 67,
          "content": "      // Calculate breakdowns for each function"
        },
        {
          "lineNum": 68,
          "content": "      functions.forEach(func => {"
        },
        {
          "lineNum": 69,
          "content": "        const boundary = findBoundaryForFunction(func.line, fileBoundaries);"
        },
        {
          "lineNum": 70,
          "content": "        const breakdown = calculateComplexityBreakdown("
        },
        {
          "lineNum": 71,
          "content": "          func.line,"
        },
        {
          "lineNum": 72,
          "content": "          fileDecisionPoints,"
        },
        {
          "lineNum": 73,
          "content": "          1 // base complexity"
        },
        {
          "lineNum": 74,
          "content": "        );"
        },
        {
          "lineNum": 75,
          "content": ""
        },
        {
          "lineNum": 76,
          "content": "        const actualComplexity = parseInt(func.complexity);"
        },
        {
          "lineNum": 77,
          "content": "        const calculatedTotal = breakdown.calculatedTotal;"
        },
        {
          "lineNum": 78,
          "content": "        const difference = calculatedTotal - actualComplexity;"
        }
      ]
    },
    {
      "functionName": "catch callback",
      "file": "scripts/analyze-mismatches.js",
      "line": 288,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "catch",
          "line": 288,
          "name": "catch block"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 1,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 288,
        "end": 291
      },
      "functionCode": [
        {
          "lineNum": 288,
          "content": "analyzeMismatches().catch(error => {"
        },
        {
          "lineNum": 289,
          "content": "  console.error('Error analyzing mismatches:', error);"
        },
        {
          "lineNum": 290,
          "content": "  process.exit(1);"
        },
        {
          "lineNum": 291,
          "content": "});"
        }
      ]
    },
    {
      "functionName": "handleFunctionDeclaration",
      "file": "scripts/function-extraction.js",
      "line": 236,
      "actualComplexity": 5,
      "calculatedTotal": 7,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 241,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 242,
          "name": "ternary operator"
        },
        {
          "type": "for...of",
          "line": 251,
          "name": "for...of loop"
        },
        {
          "type": "if",
          "line": 253,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 256,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 263,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 1,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 2,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 236,
        "end": 264
      },
      "functionCode": [
        {
          "lineNum": 236,
          "content": "function handleFunctionDeclaration(lines, lineNumber) {"
        },
        {
          "lineNum": 237,
          "content": "  const startLine = Math.max(0, lineNumber - 50);"
        },
        {
          "lineNum": 238,
          "content": "  const context = lines.slice(startLine, lineNumber).join('\\n');"
        },
        {
          "lineNum": 239,
          "content": "  "
        },
        {
          "lineNum": 240,
          "content": "  const patterns = ["
        },
        {
          "lineNum": 241,
          "content": "    /(?:export\\s+)?function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
        },
        {
          "lineNum": 242,
          "content": "    /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
        },
        {
          "lineNum": 243,
          "content": "    /export\\s+const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?(?:=>|function)/,"
        },
        {
          "lineNum": 244,
          "content": "    /export\\s+default\\s+function\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*[<(]/,"
        },
        {
          "lineNum": 245,
          "content": "    /(?:export\\s+default\\s+|const\\s+)([A-Z][a-zA-Z0-9_$]*)\\s*[:=]\\s*(?:\\([^)]*\\)\\s*)?=>/,"
        },
        {
          "lineNum": 246,
          "content": "  ];"
        },
        {
          "lineNum": 247,
          "content": "  "
        },
        {
          "lineNum": 248,
          "content": "  let lastMatch = null;"
        },
        {
          "lineNum": 249,
          "content": "  let lastIndex = -1;"
        },
        {
          "lineNum": 250,
          "content": "  "
        },
        {
          "lineNum": 251,
          "content": "  for (const pattern of patterns) {"
        },
        {
          "lineNum": 252,
          "content": "    const matches = [...context.matchAll(new RegExp(pattern.source, 'g'))];"
        },
        {
          "lineNum": 253,
          "content": "    if (matches.length > 0) {"
        },
        {
          "lineNum": 254,
          "content": "      const match = matches[matches.length - 1];"
        },
        {
          "lineNum": 255,
          "content": "      const matchIndex = context.lastIndexOf(match[0]);"
        },
        {
          "lineNum": 256,
          "content": "      if (matchIndex > lastIndex) {"
        },
        {
          "lineNum": 257,
          "content": "        lastMatch = match[1];"
        },
        {
          "lineNum": 258,
          "content": "        lastIndex = matchIndex;"
        },
        {
          "lineNum": 259,
          "content": "      }"
        },
        {
          "lineNum": 260,
          "content": "    }"
        },
        {
          "lineNum": 261,
          "content": "  }"
        },
        {
          "lineNum": 262,
          "content": "  "
        },
        {
          "lineNum": 263,
          "content": "  return lastMatch || 'anonymous';"
        },
        {
          "lineNum": 264,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "checkNamedArrowFunction",
      "file": "scripts/function-extraction.js",
      "line": 78,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 79,
          "name": "default parameter"
        },
        {
          "type": "ternary",
          "line": 82,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 82,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 78,
        "end": 83
      },
      "functionCode": [
        {
          "lineNum": 78,
          "content": "function checkNamedArrowFunction(prevLine, currentLine) {"
        },
        {
          "lineNum": 79,
          "content": "  const combinedContext = (prevLine + ' ' + currentLine).trim();"
        },
        {
          "lineNum": 80,
          "content": "  const namedArrowPattern = /const\\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\\s*=\\s*(?:\\([^)]*\\)\\s*)?=>/;"
        },
        {
          "lineNum": 81,
          "content": "  const namedMatch = combinedContext.match(namedArrowPattern);"
        },
        {
          "lineNum": 82,
          "content": "  return namedMatch && namedMatch[1] ? namedMatch[1] : null;"
        },
        {
          "lineNum": 83,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "findFunctionCallCallback",
      "file": "scripts/function-extraction.js",
      "line": 114,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 116,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 116,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 116,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 114,
        "end": 123
      },
      "functionCode": [
        {
          "lineNum": 114,
          "content": "function findFunctionCallCallback(beforeArrow, filePath, lineNumber, projectRoot, lines) {"
        },
        {
          "lineNum": 115,
          "content": "  const functionCallMatch = beforeArrow.match(/(?!if|for|while|switch)\\b(\\w+)\\s*\\(/);"
        },
        {
          "lineNum": 116,
          "content": "  if (!functionCallMatch || !functionCallMatch[1]) {"
        },
        {
          "lineNum": 117,
          "content": "    return null;"
        },
        {
          "lineNum": 118,
          "content": "  }"
        },
        {
          "lineNum": 119,
          "content": "  "
        },
        {
          "lineNum": 120,
          "content": "  const callbackType = functionCallMatch[1];"
        },
        {
          "lineNum": 121,
          "content": "  const parentFunction = findParentFunctionWithFallback(filePath, lineNumber, projectRoot, lines);"
        },
        {
          "lineNum": 122,
          "content": "  return formatCallbackName(callbackType, parentFunction);"
        },
        {
          "lineNum": 123,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "fixFunctionNameForCallback",
      "file": "scripts/function-hierarchy.js",
      "line": 573,
      "actualComplexity": 9,
      "calculatedTotal": 8,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 577,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 577,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 584,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 586,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 586,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 587,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 588,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 3,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 573,
        "end": 595
      },
      "functionCode": [
        {
          "lineNum": 573,
          "content": "function fixFunctionNameForCallback(func, functionBoundaries, sortedFunctions) {"
        },
        {
          "lineNum": 574,
          "content": "  let displayName = func.functionName || 'unknown';"
        },
        {
          "lineNum": 575,
          "content": "  const callbackMatch = displayName.match(/^(.+?)\\s+\\((.+?)\\s+callback\\)$/);"
        },
        {
          "lineNum": 576,
          "content": "  "
        },
        {
          "lineNum": 577,
          "content": "  if (!callbackMatch || !functionBoundaries) {"
        },
        {
          "lineNum": 578,
          "content": "    return displayName;"
        },
        {
          "lineNum": 579,
          "content": "  }"
        },
        {
          "lineNum": 580,
          "content": "  "
        },
        {
          "lineNum": 581,
          "content": "  const [, parentName, callbackType] = callbackMatch;"
        },
        {
          "lineNum": 582,
          "content": "  const immediateParentFunc = findImmediateParentFunction(func, functionBoundaries, sortedFunctions);"
        },
        {
          "lineNum": 583,
          "content": "  "
        },
        {
          "lineNum": 584,
          "content": "  if (immediateParentFunc) {"
        },
        {
          "lineNum": 585,
          "content": "    const correctParentName = getBaseFunctionName(immediateParentFunc.functionName);"
        },
        {
          "lineNum": 586,
          "content": "    if (correctParentName && "
        },
        {
          "lineNum": 587,
          "content": "        correctParentName !== parentName && "
        },
        {
          "lineNum": 588,
          "content": "        correctParentName !== 'unknown' && "
        },
        {
          "lineNum": 589,
          "content": "        correctParentName !== 'anonymous') {"
        },
        {
          "lineNum": 590,
          "content": "      displayName = `${correctParentName} (${callbackType} callback)`;"
        },
        {
          "lineNum": 591,
          "content": "    }"
        },
        {
          "lineNum": 592,
          "content": "  }"
        },
        {
          "lineNum": 593,
          "content": "  "
        },
        {
          "lineNum": 594,
          "content": "  return displayName;"
        },
        {
          "lineNum": 595,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "getDefaultCallbackLabel",
      "file": "scripts/function-hierarchy.js",
      "line": 416,
      "actualComplexity": 7,
      "calculatedTotal": 9,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 417,
          "name": "if statement"
        },
        {
          "type": "ternary",
          "line": 421,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 422,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 422,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 422,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 422,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 422,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 423,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 3,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 4,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 416,
        "end": 429
      },
      "functionCode": [
        {
          "lineNum": 416,
          "content": "function getDefaultCallbackLabel(functionName, parentNode) {"
        },
        {
          "lineNum": 417,
          "content": "  if (!functionName.includes('(arrow function)')) {"
        },
        {
          "lineNum": 418,
          "content": "    return 'callback';"
        },
        {
          "lineNum": 419,
          "content": "  }"
        },
        {
          "lineNum": 420,
          "content": "  "
        },
        {
          "lineNum": 421,
          "content": "  const parentName = parentNode ? parentNode.functionName : '';"
        },
        {
          "lineNum": 422,
          "content": "  if (parentName && parentName !== 'unknown' && parentName !== 'anonymous') {"
        },
        {
          "lineNum": 423,
          "content": "    if (!functionName.includes(parentName)) {"
        },
        {
          "lineNum": 424,
          "content": "      return `${parentName} callback`;"
        },
        {
          "lineNum": 425,
          "content": "    }"
        },
        {
          "lineNum": 426,
          "content": "  }"
        },
        {
          "lineNum": 427,
          "content": "  "
        },
        {
          "lineNum": 428,
          "content": "  return 'callback';"
        },
        {
          "lineNum": 429,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "findImmediateParentFunction",
      "file": "scripts/function-hierarchy.js",
      "line": 544,
      "actualComplexity": 4,
      "calculatedTotal": 3,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 546,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 558,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 544,
        "end": 564
      },
      "functionCode": [
        {
          "lineNum": 544,
          "content": "function findImmediateParentFunction(func, functionBoundaries, sortedFunctions) {"
        },
        {
          "lineNum": 545,
          "content": "  const funcBoundary = functionBoundaries.get(func.line);"
        },
        {
          "lineNum": 546,
          "content": "  if (!funcBoundary) {"
        },
        {
          "lineNum": 547,
          "content": "    return null;"
        },
        {
          "lineNum": 548,
          "content": "  }"
        },
        {
          "lineNum": 549,
          "content": "  "
        },
        {
          "lineNum": 550,
          "content": "  const containingFunctions = Array.from(functionBoundaries.entries())"
        },
        {
          "lineNum": 551,
          "content": "    .filter(([fl, boundary]) => "
        },
        {
          "lineNum": 552,
          "content": "      fl !== func.line && "
        },
        {
          "lineNum": 553,
          "content": "      boundary.start < funcBoundary.start && "
        },
        {
          "lineNum": 554,
          "content": "      boundary.end >= funcBoundary.end"
        },
        {
          "lineNum": 555,
          "content": "    )"
        },
        {
          "lineNum": 556,
          "content": "    .sort((a, b) => b[1].start - a[1].start);"
        },
        {
          "lineNum": 557,
          "content": "  "
        },
        {
          "lineNum": 558,
          "content": "  if (containingFunctions.length === 0) {"
        },
        {
          "lineNum": 559,
          "content": "    return null;"
        },
        {
          "lineNum": 560,
          "content": "  }"
        },
        {
          "lineNum": 561,
          "content": "  "
        },
        {
          "lineNum": 562,
          "content": "  const immediateParentLine = containingFunctions[0][0];"
        },
        {
          "lineNum": 563,
          "content": "  return sortedFunctions.find(f => f.line === immediateParentLine) || null;"
        },
        {
          "lineNum": 564,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "findMaxComplexityInSubtree (forEach callback)",
      "file": "scripts/function-hierarchy.js",
      "line": 90,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 92,
          "name": "default parameter"
        },
        {
          "type": "if",
          "line": 92,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 90,
        "end": 93
      },
      "functionCode": [
        {
          "lineNum": 90,
          "content": "  node.children.forEach(child => {"
        },
        {
          "lineNum": 91,
          "content": "    const childMax = findMaxComplexityInSubtree(child);"
        },
        {
          "lineNum": 92,
          "content": "    if (childMax > max) max = childMax;"
        },
        {
          "lineNum": 93,
          "content": "  });"
        }
      ]
    },
    {
      "functionName": "funcBoundary (find callback)",
      "file": "scripts/function-hierarchy.js",
      "line": 563,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 563,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 563,
        "end": 563
      },
      "functionCode": [
        {
          "lineNum": 563,
          "content": "  return sortedFunctions.find(f => f.line === immediateParentLine) || null;"
        }
      ]
    },
    {
      "functionName": "logComplexityMismatch",
      "file": "scripts/html-generators.js",
      "line": 1035,
      "actualComplexity": 10,
      "calculatedTotal": 4,
      "difference": -6,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 1039,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1041,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 1041,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1035,
        "end": 1061
      },
      "functionCode": [
        {
          "lineNum": 1035,
          "content": "function logComplexityMismatch(func, breakdown, functionBoundaries) {"
        },
        {
          "lineNum": 1036,
          "content": "  const actualComplexity = parseInt(func.complexity);"
        },
        {
          "lineNum": 1037,
          "content": "  const calculatedTotal = breakdown.calculatedTotal;"
        },
        {
          "lineNum": 1038,
          "content": "  "
        },
        {
          "lineNum": 1039,
          "content": "  if (Math.abs(calculatedTotal - actualComplexity) > 1) {"
        },
        {
          "lineNum": 1040,
          "content": "    console.warn(`Complexity mismatch for ${func.functionName} at line ${func.line}: ESLint reports ${actualComplexity}, calculated ${calculatedTotal}`);"
        },
        {
          "lineNum": 1041,
          "content": "    if (breakdown.decisionPoints && breakdown.decisionPoints.length > 0) {"
        },
        {
          "lineNum": 1042,
          "content": "      console.warn(`  Decision points found:`, breakdown.decisionPoints.map(dp => `${dp.type} at line ${dp.line}`).join(', '));"
        },
        {
          "lineNum": 1043,
          "content": "    } else {"
        },
        {
          "lineNum": 1044,
          "content": "      console.warn(`  Decision points found: (none)`);"
        },
        {
          "lineNum": 1045,
          "content": "      // For TopBanner specifically, check what's happening"
        },
        {
          "lineNum": 1046,
          "content": "      if (func.functionName === 'TopBanner' && func.line === 5) {"
        },
        {
          "lineNum": 1047,
          "content": "        const boundary = functionBoundaries.get(func.line);"
        },
        {
          "lineNum": 1048,
          "content": "        console.warn(`  TopBanner boundary: start=${boundary?.start}, end=${boundary?.end}`);"
        },
        {
          "lineNum": 1049,
          "content": "        // Check if lines 49 and 54 are in any function boundary"
        },
        {
          "lineNum": 1050,
          "content": "        const line49Funcs = Array.from(functionBoundaries.entries()).filter(([fl, b]) => fl !== func.line && 49 >= b.start && 49 <= b.end);"
        },
        {
          "lineNum": 1051,
          "content": "        const line54Funcs = Array.from(functionBoundaries.entries()).filter(([fl, b]) => fl !== func.line && 54 >= b.start && 54 <= b.end);"
        },
        {
          "lineNum": 1052,
          "content": "        if (line49Funcs.length > 0) {"
        },
        {
          "lineNum": 1053,
          "content": "          console.warn(`  Line 49 is in other function boundaries:`, line49Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
        },
        {
          "lineNum": 1054,
          "content": "        }"
        },
        {
          "lineNum": 1055,
          "content": "        if (line54Funcs.length > 0) {"
        },
        {
          "lineNum": 1056,
          "content": "          console.warn(`  Line 54 is in other function boundaries:`, line54Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
        },
        {
          "lineNum": 1057,
          "content": "        }"
        },
        {
          "lineNum": 1058,
          "content": "      }"
        },
        {
          "lineNum": 1059,
          "content": "    }"
        },
        {
          "lineNum": 1060,
          "content": "  }"
        },
        {
          "lineNum": 1061,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "buildCodeLineHTML",
      "file": "scripts/html-generators.js",
      "line": 1195,
      "actualComplexity": 10,
      "calculatedTotal": 11,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1196,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1197,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1198,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1199,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 1201,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 1201,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 1201,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 1203,
          "name": "if statement"
        },
        {
          "type": "else if",
          "line": 1205,
          "name": "else if statement"
        },
        {
          "type": "||",
          "line": 1205,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 1,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 4,
        "&&": 0,
        "||": 3,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1195,
        "end": 1213
      },
      "functionCode": [
        {
          "lineNum": 1195,
          "content": "function buildCodeLineHTML(line, escapeHtml, isDecisionPoint, isFunctionStart, isFunctionClosing) {"
        },
        {
          "lineNum": 1196,
          "content": "  const lineMatch = line.match(/^(\\s*)(.*?)(\\s*)$/);"
        },
        {
          "lineNum": 1197,
          "content": "  const leadingWhitespace = lineMatch ? escapeHtml(lineMatch[1]) : '';"
        },
        {
          "lineNum": 1198,
          "content": "  const content = lineMatch ? escapeHtml(lineMatch[2]) : escapeHtml(line);"
        },
        {
          "lineNum": 1199,
          "content": "  const trailingWhitespace = lineMatch ? escapeHtml(lineMatch[3]) : '';"
        },
        {
          "lineNum": 1200,
          "content": "  "
        },
        {
          "lineNum": 1201,
          "content": "  if (isDecisionPoint || isFunctionStart || isFunctionClosing) {"
        },
        {
          "lineNum": 1202,
          "content": "    const codeLineParts = ['code-line'];"
        },
        {
          "lineNum": 1203,
          "content": "    if (isDecisionPoint) {"
        },
        {
          "lineNum": 1204,
          "content": "      codeLineParts.push('decision-point-line');"
        },
        {
          "lineNum": 1205,
          "content": "    } else if (isFunctionStart || isFunctionClosing) {"
        },
        {
          "lineNum": 1206,
          "content": "      codeLineParts.push('function-boundary-highlight');"
        },
        {
          "lineNum": 1207,
          "content": "    }"
        },
        {
          "lineNum": 1208,
          "content": "    const codeLineClass = codeLineParts.join(' ');"
        },
        {
          "lineNum": 1209,
          "content": "    return `${leadingWhitespace}<span class=\"${codeLineClass}\">${content}</span>${trailingWhitespace}`;"
        },
        {
          "lineNum": 1210,
          "content": "  }"
        },
        {
          "lineNum": 1211,
          "content": "  "
        },
        {
          "lineNum": 1212,
          "content": "  return `<span class=\"code-line\">${leadingWhitespace}${content}${trailingWhitespace}</span>`;"
        },
        {
          "lineNum": 1213,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "determineLineClasses",
      "file": "scripts/html-generators.js",
      "line": 1159,
      "actualComplexity": 9,
      "calculatedTotal": 8,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1164,
          "name": "ternary operator"
        },
        {
          "type": "if",
          "line": 1171,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 1171,
          "name": "logical AND"
        },
        {
          "type": "if",
          "line": 1174,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1175,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 1176,
          "name": "if statement"
        },
        {
          "type": "ternary",
          "line": 1181,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 4,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 2,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1159,
        "end": 1184
      },
      "functionCode": [
        {
          "lineNum": 1159,
          "content": "function determineLineClasses(decisionPointsOnLine, lineNum, functionStartLines, functionEndLines, functionClosingLines) {"
        },
        {
          "lineNum": 1160,
          "content": "  const isDecisionPoint = decisionPointsOnLine.length > 0;"
        },
        {
          "lineNum": 1161,
          "content": "  const decisionPointTitle = isDecisionPoint "
        },
        {
          "lineNum": 1162,
          "content": "    ? ` title=\"${decisionPointsOnLine.map(dp => dp.name).join(', ')}\"`"
        },
        {
          "lineNum": 1163,
          "content": "    : '';"
        },
        {
          "lineNum": 1164,
          "content": "  const decisionPointClass = isDecisionPoint ? 'decision-point' : '';"
        },
        {
          "lineNum": 1165,
          "content": "  "
        },
        {
          "lineNum": 1166,
          "content": "  const isFunctionStart = functionStartLines.has(lineNum);"
        },
        {
          "lineNum": 1167,
          "content": "  const isFunctionEnd = functionEndLines.has(lineNum);"
        },
        {
          "lineNum": 1168,
          "content": "  const isFunctionClosing = functionClosingLines.has(lineNum);"
        },
        {
          "lineNum": 1169,
          "content": "  "
        },
        {
          "lineNum": 1170,
          "content": "  const boundaryParts = [];"
        },
        {
          "lineNum": 1171,
          "content": "  if (isFunctionStart && isFunctionEnd) {"
        },
        {
          "lineNum": 1172,
          "content": "    boundaryParts.push('function-boundary-single');"
        },
        {
          "lineNum": 1173,
          "content": "  } else {"
        },
        {
          "lineNum": 1174,
          "content": "    if (isFunctionStart) boundaryParts.push('function-boundary-start');"
        },
        {
          "lineNum": 1175,
          "content": "    if (isFunctionEnd) boundaryParts.push('function-boundary-end');"
        },
        {
          "lineNum": 1176,
          "content": "    if (isFunctionClosing) boundaryParts.push('function-boundary-closing');"
        },
        {
          "lineNum": 1177,
          "content": "  }"
        },
        {
          "lineNum": 1178,
          "content": "  "
        },
        {
          "lineNum": 1179,
          "content": "  const boundaryClass = boundaryParts.join(' ');"
        },
        {
          "lineNum": 1180,
          "content": "  const allClasses = [decisionPointClass, boundaryClass].filter(Boolean).join(' ');"
        },
        {
          "lineNum": 1181,
          "content": "  const classAttr = allClasses ? ` class=\"${allClasses}\"` : '';"
        },
        {
          "lineNum": 1182,
          "content": "  "
        },
        {
          "lineNum": 1183,
          "content": "  return { classAttr, decisionPointTitle, isDecisionPoint, isFunctionStart, isFunctionClosing };"
        },
        {
          "lineNum": 1184,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "generateFileHTML",
      "file": "scripts/html-generators.js",
      "line": 1255,
      "actualComplexity": 8,
      "calculatedTotal": 7,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 1272,
          "name": "if statement"
        },
        {
          "type": "catch",
          "line": 1276,
          "name": "catch block"
        },
        {
          "type": "ternary",
          "line": 1315,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1357,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1597,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1611,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 1,
        "ternary": 4,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1255,
        "end": 1637
      },
      "functionCode": [
        {
          "lineNum": 1255,
          "content": "export function generateFileHTML("
        },
        {
          "lineNum": 1256,
          "content": "  filePath,"
        },
        {
          "lineNum": 1257,
          "content": "  functions,"
        },
        {
          "lineNum": 1258,
          "content": "  projectRoot,"
        },
        {
          "lineNum": 1259,
          "content": "  findFunctionBoundaries,"
        },
        {
          "lineNum": 1260,
          "content": "  parseDecisionPoints,"
        },
        {
          "lineNum": 1261,
          "content": "  calculateComplexityBreakdown,"
        },
        {
          "lineNum": 1262,
          "content": "  formatFunctionHierarchy,"
        },
        {
          "lineNum": 1263,
          "content": "  getComplexityLevel,"
        },
        {
          "lineNum": 1264,
          "content": "  getDirectory,"
        },
        {
          "lineNum": 1265,
          "content": "  escapeHtml"
        },
        {
          "lineNum": 1266,
          "content": ") {"
        },
        {
          "lineNum": 1267,
          "content": "  const fullPath = resolve(projectRoot, filePath);"
        },
        {
          "lineNum": 1268,
          "content": "  let sourceCode = '';"
        },
        {
          "lineNum": 1269,
          "content": "  let sourceLines = [];"
        },
        {
          "lineNum": 1270,
          "content": "  "
        },
        {
          "lineNum": 1271,
          "content": "  try {"
        },
        {
          "lineNum": 1272,
          "content": "    if (existsSync(fullPath)) {"
        },
        {
          "lineNum": 1273,
          "content": "      sourceCode = readFileSync(fullPath, 'utf-8');"
        },
        {
          "lineNum": 1274,
          "content": "      sourceLines = sourceCode.split('\\n');"
        },
        {
          "lineNum": 1275,
          "content": "    }"
        },
        {
          "lineNum": 1276,
          "content": "  } catch (error) {"
        },
        {
          "lineNum": 1277,
          "content": "    console.warn(`Warning: Could not read source file ${filePath}:`, error.message);"
        },
        {
          "lineNum": 1278,
          "content": "  }"
        },
        {
          "lineNum": 1279,
          "content": "  "
        },
        {
          "lineNum": 1280,
          "content": "  // Create a map of line numbers to functions for quick lookup"
        },
        {
          "lineNum": 1281,
          "content": "  const lineToFunction = new Map();"
        },
        {
          "lineNum": 1282,
          "content": "  functions.forEach(func => {"
        },
        {
          "lineNum": 1283,
          "content": "    lineToFunction.set(func.line, func);"
        },
        {
          "lineNum": 1284,
          "content": "  });"
        },
        {
          "lineNum": 1285,
          "content": "  "
        },
        {
          "lineNum": 1286,
          "content": "  // Parse decision points"
        },
        {
          "lineNum": 1287,
          "content": "  const functionBoundaries = findFunctionBoundaries(sourceCode, functions);"
        },
        {
          "lineNum": 1288,
          "content": "  const decisionPoints = parseDecisionPoints(sourceCode, functionBoundaries, functions);"
        },
        {
          "lineNum": 1289,
          "content": "  "
        },
        {
          "lineNum": 1290,
          "content": "  // Calculate complexity breakdowns for each function"
        },
        {
          "lineNum": 1291,
          "content": "  const functionBreakdowns = calculateFunctionBreakdowns("
        },
        {
          "lineNum": 1292,
          "content": "    functions,"
        },
        {
          "lineNum": 1293,
          "content": "    functionBoundaries,"
        },
        {
          "lineNum": 1294,
          "content": "    decisionPoints,"
        },
        {
          "lineNum": 1295,
          "content": "    calculateComplexityBreakdown"
        },
        {
          "lineNum": 1296,
          "content": "  );"
        },
        {
          "lineNum": 1297,
          "content": "  "
        },
        {
          "lineNum": 1298,
          "content": "  // Create decision point line map for highlighting"
        },
        {
          "lineNum": 1299,
          "content": "  const lineToDecisionPoint = new Map();"
        },
        {
          "lineNum": 1300,
          "content": "  decisionPoints.forEach(dp => {"
        },
        {
          "lineNum": 1301,
          "content": "    if (!lineToDecisionPoint.has(dp.line)) {"
        },
        {
          "lineNum": 1302,
          "content": "      lineToDecisionPoint.set(dp.line, []);"
        },
        {
          "lineNum": 1303,
          "content": "    }"
        },
        {
          "lineNum": 1304,
          "content": "    lineToDecisionPoint.get(dp.line).push(dp);"
        }
      ]
    },
    {
      "functionName": "findBoundaryForFunction",
      "file": "scripts/html-generators.js",
      "line": 996,
      "actualComplexity": 7,
      "calculatedTotal": 2,
      "difference": -5,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 999,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 996,
        "end": 1012
      },
      "functionCode": [
        {
          "lineNum": 996,
          "content": "function findBoundaryForFunction(functionLine, functionBoundaries) {"
        },
        {
          "lineNum": 997,
          "content": "  let boundary = functionBoundaries.get(functionLine);"
        },
        {
          "lineNum": 998,
          "content": "  "
        },
        {
          "lineNum": 999,
          "content": "  if (!boundary) {"
        },
        {
          "lineNum": 1000,
          "content": "    // Find boundary that contains this function's line OR starts right after it"
        },
        {
          "lineNum": 1001,
          "content": "    // (e.g., function at line 39, boundary starts at 40)"
        },
        {
          "lineNum": 1002,
          "content": "    for (const [boundaryLine, b] of functionBoundaries.entries()) {"
        },
        {
          "lineNum": 1003,
          "content": "      if ((functionLine >= b.start && functionLine <= b.end) || "
        },
        {
          "lineNum": 1004,
          "content": "          (functionLine < b.start && b.start === functionLine + 1)) {"
        },
        {
          "lineNum": 1005,
          "content": "        boundary = b;"
        },
        {
          "lineNum": 1006,
          "content": "        break;"
        },
        {
          "lineNum": 1007,
          "content": "      }"
        },
        {
          "lineNum": 1008,
          "content": "    }"
        },
        {
          "lineNum": 1009,
          "content": "  }"
        },
        {
          "lineNum": 1010,
          "content": "  "
        },
        {
          "lineNum": 1011,
          "content": "  return boundary;"
        },
        {
          "lineNum": 1012,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "calculateFileStatistics",
      "file": "scripts/html-generators.js",
      "line": 1096,
      "actualComplexity": 7,
      "calculatedTotal": 5,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1101,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1102,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1102,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 1102,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 4,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1096,
        "end": 1105
      },
      "functionCode": [
        {
          "lineNum": 1096,
          "content": "function calculateFileStatistics(functions) {"
        },
        {
          "lineNum": 1097,
          "content": "  const totalFunctions = functions.length;"
        },
        {
          "lineNum": 1098,
          "content": "  const withinThreshold = functions.filter(f => parseInt(f.complexity) <= 10).length;"
        },
        {
          "lineNum": 1099,
          "content": "  const maxComplexity = functions.length > 0 ? Math.max(...functions.map(f => parseInt(f.complexity))) : 0;"
        },
        {
          "lineNum": 1100,
          "content": "  const avgComplexity = functions.length > 0 ? Math.round(functions.reduce((sum, f) => sum + parseInt(f.complexity), 0) / functions.length) : 0;"
        },
        {
          "lineNum": 1101,
          "content": "  const percentage = totalFunctions > 0 ? Math.round((withinThreshold / totalFunctions) * 100) : 100;"
        },
        {
          "lineNum": 1102,
          "content": "  const level = percentage >= 80 ? 'high' : percentage >= 60 ? 'high' : percentage >= 40 ? 'medium' : 'low';"
        },
        {
          "lineNum": 1103,
          "content": "  "
        },
        {
          "lineNum": 1104,
          "content": "  return { totalFunctions, withinThreshold, maxComplexity, avgComplexity, percentage, level };"
        },
        {
          "lineNum": 1105,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "existing (map callback)",
      "file": "scripts/html-generators.js",
      "line": 835,
      "actualComplexity": 5,
      "calculatedTotal": 4,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 845,
          "name": "logical OR"
        },
        {
          "type": "ternary",
          "line": 847,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 847,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 1,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 835,
        "end": 861
      },
      "functionCode": [
        {
          "lineNum": 835,
          "content": "            .map(issue => {"
        },
        {
          "lineNum": 836,
          "content": "              const level = getComplexityLevel(issue.complexity);"
        },
        {
          "lineNum": 837,
          "content": "              const complexityNum = parseInt(issue.complexity);"
        },
        {
          "lineNum": 838,
          "content": "              const isOverThreshold = complexityNum > 10;"
        },
        {
          "lineNum": 839,
          "content": "              const maxComplexityForBar = Math.max(30, complexityNum);"
        },
        {
          "lineNum": 840,
          "content": "              const percentage = Math.min(100, (complexityNum / maxComplexityForBar) * 100);"
        },
        {
          "lineNum": 841,
          "content": "              // Extract filename from full path for link (relative to current folder)"
        },
        {
          "lineNum": 842,
          "content": "              const fileName = issue.file.split('/').pop();"
        },
        {
          "lineNum": 843,
          "content": "              // File link is relative to the folder index.html, so just use filename"
        },
        {
          "lineNum": 844,
          "content": "              const fileLinkPath = `${fileName}.html`;"
        },
        {
          "lineNum": 845,
          "content": "              const baseFunctionName = getBaseFunctionName(issue.functionName || 'unknown');"
        },
        {
          "lineNum": 846,
          "content": "              return `"
        },
        {
          "lineNum": 847,
          "content": "                <tr data-over-threshold=\"${isOverThreshold}\" data-file=\"${issue.file}\" data-function=\"${baseFunctionName}\" data-complexity=\"${complexityNum}\" data-line=\"${issue.line}\" ${!showAllInitially && !isOverThreshold ? 'style=\"display: none;\"' : ''}>"
        },
        {
          "lineNum": 848,
          "content": "                  <td class=\"file\"><a href=\"${fileLinkPath}\">${issue.file}</a></td>"
        },
        {
          "lineNum": 849,
          "content": "                  <td class=\"bar ${level}\">"
        },
        {
          "lineNum": 850,
          "content": "                    <div class=\"chart\"><div class=\"cover-fill ${level} ${percentage === 100 ? 'cover-full' : ''}\" style=\"width: ${percentage}%\"></div><div class=\"cover-empty\" style=\"width: ${100 - percentage}%\"></div></div>"
        },
        {
          "lineNum": 851,
          "content": "                  </td>"
        },
        {
          "lineNum": 852,
          "content": "                  <td class=\"file\">"
        },
        {
          "lineNum": 853,
          "content": "                    <span style=\"font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 13px;\">${baseFunctionName}</span>"
        },
        {
          "lineNum": 854,
          "content": "                  </td>"
        },
        {
          "lineNum": 855,
          "content": "                  <td class=\"pct\">"
        },
        {
          "lineNum": 856,
          "content": "                    <span class=\"complexity-value ${level}\">${complexityNum}</span>"
        },
        {
          "lineNum": 857,
          "content": "                  </td>"
        },
        {
          "lineNum": 858,
          "content": "                  <td class=\"abs\">${issue.line}</td>"
        },
        {
          "lineNum": 859,
          "content": "                </tr>"
        },
        {
          "lineNum": 860,
          "content": "              `;"
        },
        {
          "lineNum": 861,
          "content": "            }).join('');"
        }
      ]
    },
    {
      "functionName": "boundary (warn callback)",
      "file": "scripts/html-generators.js",
      "line": 1053,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 1055,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1053,
        "end": 1059
      },
      "functionCode": [
        {
          "lineNum": 1053,
          "content": "          console.warn(`  Line 49 is in other function boundaries:`, line49Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
        },
        {
          "lineNum": 1054,
          "content": "        }"
        },
        {
          "lineNum": 1055,
          "content": "        if (line54Funcs.length > 0) {"
        },
        {
          "lineNum": 1056,
          "content": "          console.warn(`  Line 54 is in other function boundaries:`, line54Funcs.map(([fl, b]) => `line ${fl} (${b.start}-${b.end})`).join(', '));"
        },
        {
          "lineNum": 1057,
          "content": "        }"
        },
        {
          "lineNum": 1058,
          "content": "      }"
        },
        {
          "lineNum": 1059,
          "content": "    }"
        }
      ]
    },
    {
      "functionName": "withinThreshold (max callback)",
      "file": "scripts/html-generators.js",
      "line": 1099,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1099,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1099,
        "end": 1099
      },
      "functionCode": [
        {
          "lineNum": 1099,
          "content": "  const maxComplexity = functions.length > 0 ? Math.max(...functions.map(f => parseInt(f.complexity))) : 0;"
        }
      ]
    },
    {
      "functionName": "maxComplexity (round callback)",
      "file": "scripts/html-generators.js",
      "line": 1100,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 1100,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 1100,
        "end": 1100
      },
      "functionCode": [
        {
          "lineNum": 1100,
          "content": "  const avgComplexity = functions.length > 0 ? Math.round(functions.reduce((sum, f) => sum + parseInt(f.complexity), 0) / functions.length) : 0;"
        }
      ]
    },
    {
      "functionName": "determineLineClasses (map callback)",
      "file": "scripts/html-generators.js",
      "line": 1162,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 1162,
          "name": "default parameter"
        },
        {
          "type": "ternary",
          "line": 1162,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 1162,
        "end": 1162
      },
      "functionCode": [
        {
          "lineNum": 1162,
          "content": "    ? ` title=\"${decisionPointsOnLine.map(dp => dp.name).join(', ')}\"`"
        }
      ]
    },
    {
      "functionName": "addEventListener callback",
      "file": "src/main.tsx",
      "line": 12,
      "actualComplexity": 9,
      "calculatedTotal": 7,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 13,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 13,
          "name": "logical OR"
        },
        {
          "type": "&&",
          "line": 15,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 16,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 17,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 21,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 4,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 12,
        "end": 31
      },
      "functionCode": [
        {
          "lineNum": 12,
          "content": "  window.addEventListener('error', (event) => {"
        },
        {
          "lineNum": 13,
          "content": "    const error = event.error || event.message || '';"
        },
        {
          "lineNum": 14,
          "content": "    const isChunkLoadError = "
        },
        {
          "lineNum": 15,
          "content": "      typeof error === 'string' && ("
        },
        {
          "lineNum": 16,
          "content": "        error.includes('Failed to fetch dynamically imported module') ||"
        },
        {
          "lineNum": 17,
          "content": "        error.includes('Loading chunk') ||"
        },
        {
          "lineNum": 18,
          "content": "        error.includes('Loading CSS chunk')"
        },
        {
          "lineNum": 19,
          "content": "      );"
        },
        {
          "lineNum": 20,
          "content": "    "
        },
        {
          "lineNum": 21,
          "content": "    if (isChunkLoadError) {"
        },
        {
          "lineNum": 22,
          "content": "      // Only reload if we haven't already tried recently (prevent infinite loops)"
        },
        {
          "lineNum": 23,
          "content": "      const lastReload = sessionStorage.getItem('chunkReloadAttempt');"
        },
        {
          "lineNum": 24,
          "content": "      const now = Date.now();"
        },
        {
          "lineNum": 25,
          "content": "      "
        },
        {
          "lineNum": 26,
          "content": "      if (!lastReload || (now - parseInt(lastReload)) > 10000) { // 10 second cooldown"
        },
        {
          "lineNum": 27,
          "content": "        sessionStorage.setItem('chunkReloadAttempt', now.toString());"
        },
        {
          "lineNum": 28,
          "content": "        window.location.reload();"
        },
        {
          "lineNum": 29,
          "content": "      }"
        },
        {
          "lineNum": 30,
          "content": "    }"
        },
        {
          "lineNum": 31,
          "content": "  });"
        }
      ]
    },
    {
      "functionName": "applyThemeToDom",
      "file": "src/main.tsx",
      "line": 63,
      "actualComplexity": 3,
      "calculatedTotal": 2,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 65,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 63,
        "end": 77
      },
      "functionCode": [
        {
          "lineNum": 63,
          "content": "const applyThemeToDom = (theme: typeof defaultTheme) => {"
        },
        {
          "lineNum": 64,
          "content": "  const root = document.getElementById('root');"
        },
        {
          "lineNum": 65,
          "content": "  if (!root) return;"
        },
        {
          "lineNum": 66,
          "content": ""
        },
        {
          "lineNum": 67,
          "content": "  Object.entries(theme).forEach(([key, value]) => {"
        },
        {
          "lineNum": 68,
          "content": "    const cssVar = themeKeyToCssVar(key);"
        },
        {
          "lineNum": 69,
          "content": "    root.style.setProperty(cssVar, value as string);"
        },
        {
          "lineNum": 70,
          "content": "  });"
        },
        {
          "lineNum": 71,
          "content": ""
        },
        {
          "lineNum": 72,
          "content": "  // Also apply --color-bg to html so body element can use it"
        },
        {
          "lineNum": 73,
          "content": "  // (body is a parent of #root, so it can't access variables defined on #root)"
        },
        {
          "lineNum": 74,
          "content": "  if (theme.bg) {"
        },
        {
          "lineNum": 75,
          "content": "    document.documentElement.style.setProperty('--color-bg', theme.bg);"
        },
        {
          "lineNum": 76,
          "content": "  }"
        },
        {
          "lineNum": 77,
          "content": "};"
        }
      ]
    },
    {
      "functionName": "handleHashClick",
      "file": "src/sections/Header/index.tsx",
      "line": 19,
      "actualComplexity": 6,
      "calculatedTotal": 1,
      "difference": -5,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 19,
        "end": 38
      },
      "functionCode": [
        {
          "lineNum": 19,
          "content": "  const handleHashClick = (e: React.MouseEvent<HTMLAnchorElement>) => {"
        },
        {
          "lineNum": 20,
          "content": "    // Close mobile menu if open"
        },
        {
          "lineNum": 21,
          "content": "    setIsMenuOpen(false);"
        },
        {
          "lineNum": 22,
          "content": "    "
        },
        {
          "lineNum": 23,
          "content": "    // If we're already on the home page with the same hash, manually scroll"
        },
        {
          "lineNum": 24,
          "content": "    const hash = (e.currentTarget.getAttribute('href') || '').split('#')[1];"
        },
        {
          "lineNum": 25,
          "content": "    if (hash && location.pathname === \"/\" && location.hash === `#${hash}`) {"
        },
        {
          "lineNum": 26,
          "content": "      e.preventDefault();"
        },
        {
          "lineNum": 27,
          "content": "      const element = document.querySelector(`#${hash}`);"
        },
        {
          "lineNum": 28,
          "content": "      if (element) {"
        },
        {
          "lineNum": 29,
          "content": "        const headerOffset = 110;"
        },
        {
          "lineNum": 30,
          "content": "        const elementPosition = element.getBoundingClientRect().top;"
        },
        {
          "lineNum": 31,
          "content": "        const offsetPosition = elementPosition + window.scrollY - headerOffset;"
        },
        {
          "lineNum": 32,
          "content": "        window.scrollTo({"
        },
        {
          "lineNum": 33,
          "content": "          top: offsetPosition,"
        },
        {
          "lineNum": 34,
          "content": "          behavior: \"smooth\","
        },
        {
          "lineNum": 35,
          "content": "        });"
        },
        {
          "lineNum": 36,
          "content": "      }"
        },
        {
          "lineNum": 37,
          "content": "    }"
        },
        {
          "lineNum": 38,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/Header/index.tsx",
      "line": 246,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 246,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 246,
        "end": 246
      },
      "functionCode": [
        {
          "lineNum": 246,
          "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#experience\")}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/Header/index.tsx",
      "line": 256,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 256,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 256,
        "end": 256
      },
      "functionCode": [
        {
          "lineNum": 256,
          "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#projects\")}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/Header/index.tsx",
      "line": 266,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 266,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 266,
        "end": 266
      },
      "functionCode": [
        {
          "lineNum": 266,
          "content": "                onClick={(e) => handleMenuLinkClick(e, \"/resources/blog\")}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/Header/index.tsx",
      "line": 276,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 276,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 276,
        "end": 276
      },
      "functionCode": [
        {
          "lineNum": 276,
          "content": "                onClick={(e) => handleMenuLinkClick(e, \"/#contact\")}"
        }
      ]
    },
    {
      "functionName": "formatComplexityBreakdownInline (forEach callback)",
      "file": "scripts/complexity-breakdown.js",
      "line": 91,
      "actualComplexity": 9,
      "calculatedTotal": 13,
      "difference": 4,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "||",
          "line": 92,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 93,
          "name": "if statement"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 96,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 96,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 96,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 96,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 96,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 6,
        "&&": 2,
        "||": 3,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 91,
        "end": 99
      },
      "functionCode": [
        {
          "lineNum": 91,
          "content": "  typeOrder.forEach(type => {"
        },
        {
          "lineNum": 92,
          "content": "    const count = breakdown[type] || 0;"
        },
        {
          "lineNum": 93,
          "content": "    if (count > 0) {"
        },
        {
          "lineNum": 94,
          "content": "      // Use ESLint symbols: ?: for ternary, && for AND, || for OR, ?? for nullish coalescing, ?. for optional chaining"
        },
        {
          "lineNum": 95,
          "content": "      // For default parameters, use \"default param\" as the display symbol"
        },
        {
          "lineNum": 96,
          "content": "      const symbol = type === 'ternary' ? '?:' : type === '&&' ? '&&' : type === '||' ? '||' : type === '??' ? '??' : type === '?.' ? '?.' : type === 'default parameter' ? 'default param' : type;"
        },
        {
          "lineNum": 97,
          "content": "      parts.push(`+${count} ${symbol}`);"
        },
        {
          "lineNum": 98,
          "content": "    }"
        },
        {
          "lineNum": 99,
          "content": "  });"
        }
      ]
    },
    {
      "functionName": "formatComplexityBreakdownStyled (forEach callback)",
      "file": "scripts/complexity-breakdown.js",
      "line": 123,
      "actualComplexity": 9,
      "calculatedTotal": 13,
      "difference": 4,
      "category": "forEach callback",
      "decisionPoints": [
        {
          "type": "||",
          "line": 124,
          "name": "logical OR"
        },
        {
          "type": "if",
          "line": 125,
          "name": "if statement"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "ternary",
          "line": 128,
          "name": "ternary operator"
        },
        {
          "type": "&&",
          "line": 128,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 128,
          "name": "logical AND"
        },
        {
          "type": "||",
          "line": 128,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 128,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 6,
        "&&": 2,
        "||": 3,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 123,
        "end": 131
      },
      "functionCode": [
        {
          "lineNum": 123,
          "content": "  typeOrder.forEach(type => {"
        },
        {
          "lineNum": 124,
          "content": "    const count = breakdown[type] || 0;"
        },
        {
          "lineNum": 125,
          "content": "    if (count > 0) {"
        },
        {
          "lineNum": 126,
          "content": "      // Use ESLint symbols: ?: for ternary, && for AND, || for OR, ?? for nullish coalescing, ?. for optional chaining"
        },
        {
          "lineNum": 127,
          "content": "      // For default parameters, use \"default param\" as the display symbol"
        },
        {
          "lineNum": 128,
          "content": "      const symbol = type === 'ternary' ? '?:' : type === '&&' ? '&&' : type === '||' ? '||' : type === '??' ? '??' : type === '?.' ? '?.' : type === 'default parameter' ? 'default param' : type;"
        },
        {
          "lineNum": 129,
          "content": "      parts.push(`${symbol} <span class=\"complexity-number\">${count}</span>`);"
        },
        {
          "lineNum": 130,
          "content": "    }"
        },
        {
          "lineNum": 131,
          "content": "  });"
        }
      ]
    },
    {
      "functionName": "AudioControl",
      "file": "src/components/AudioControl/AudioControl.tsx",
      "line": 6,
      "actualComplexity": 9,
      "calculatedTotal": 6,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 20,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 20,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 20,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 20,
          "name": "logical OR"
        },
        {
          "type": "ternary",
          "line": 122,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 4,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 6,
        "end": 128
      },
      "functionCode": [
        {
          "lineNum": 6,
          "content": "export function AudioControl() {"
        },
        {
          "lineNum": 7,
          "content": "  const { currentPresetId } = useTheme();"
        },
        {
          "lineNum": 8,
          "content": "  const [isPlaying, setIsPlaying] = useState(false);"
        },
        {
          "lineNum": 9,
          "content": "  const audioRef = useRef<HTMLAudioElement | null>(null);"
        },
        {
          "lineNum": 10,
          "content": "  // Store the audio file path (lazy-loaded - only create Audio on user interaction)"
        },
        {
          "lineNum": 11,
          "content": "  const audioFileRef = useRef<string | null>(null);"
        },
        {
          "lineNum": 12,
          "content": "  // Store handlers so we can remove them properly"
        },
        {
          "lineNum": 13,
          "content": "  const handlersRef = useRef<{"
        },
        {
          "lineNum": 14,
          "content": "    handlePlay: () => void;"
        },
        {
          "lineNum": 15,
          "content": "    handlePause: () => void;"
        },
        {
          "lineNum": 16,
          "content": "    handleEnded: () => void;"
        },
        {
          "lineNum": 17,
          "content": "  } | null>(null);"
        },
        {
          "lineNum": 18,
          "content": ""
        },
        {
          "lineNum": 19,
          "content": "  // Show when noname, samson, vapor-wave, king, or planet theme is active"
        },
        {
          "lineNum": 20,
          "content": "  const isThemeWithAudio = currentPresetId === 'noname' || currentPresetId === 'samson' || currentPresetId === 'vapor-wave' || currentPresetId === 'king' || currentPresetId === 'planet';"
        },
        {
          "lineNum": 21,
          "content": ""
        },
        {
          "lineNum": 22,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 23,
          "content": "    // Determine audio file based on theme (but don't create Audio yet - lazy load on interaction)"
        },
        {
          "lineNum": 24,
          "content": "    let audioFile: string | null = null;"
        },
        {
          "lineNum": 25,
          "content": "    if (currentPresetId === 'samson') {"
        },
        {
          "lineNum": 26,
          "content": "      audioFile = '/samson.mp3';"
        },
        {
          "lineNum": 27,
          "content": "    } else if (currentPresetId === 'noname') {"
        },
        {
          "lineNum": 28,
          "content": "      audioFile = '/noname.mp3';"
        },
        {
          "lineNum": 29,
          "content": "    } else if (currentPresetId === 'vapor-wave') {"
        },
        {
          "lineNum": 30,
          "content": "      audioFile = 'http://radio.plaza.one/mp3';"
        },
        {
          "lineNum": 31,
          "content": "    } else if (currentPresetId === 'king') {"
        },
        {
          "lineNum": 32,
          "content": "      audioFile = '/i_have_a_dream_speech.mp3';"
        },
        {
          "lineNum": 33,
          "content": "    } else if (currentPresetId === 'planet') {"
        },
        {
          "lineNum": 34,
          "content": "      audioFile = '/earth_song.mp3';"
        },
        {
          "lineNum": 35,
          "content": "    }"
        },
        {
          "lineNum": 36,
          "content": ""
        },
        {
          "lineNum": 37,
          "content": "    // Store audio file path, but don't create Audio instance yet (prevents eager download)"
        },
        {
          "lineNum": 38,
          "content": "    if (isThemeWithAudio && audioFile) {"
        },
        {
          "lineNum": 39,
          "content": "      audioFileRef.current = audioFile;"
        },
        {
          "lineNum": 40,
          "content": "    } else {"
        },
        {
          "lineNum": 41,
          "content": "      audioFileRef.current = null;"
        },
        {
          "lineNum": 42,
          "content": "    }"
        },
        {
          "lineNum": 43,
          "content": ""
        },
        {
          "lineNum": 44,
          "content": "    // Cleanup: if audio was created, clean it up when theme changes"
        },
        {
          "lineNum": 45,
          "content": "    return () => {"
        },
        {
          "lineNum": 46,
          "content": "      if (audioRef.current) {"
        },
        {
          "lineNum": 47,
          "content": "        audioRef.current.pause();"
        },
        {
          "lineNum": 48,
          "content": "        if (handlersRef.current) {"
        },
        {
          "lineNum": 49,
          "content": "          audioRef.current.removeEventListener('play', handlersRef.current.handlePlay);"
        },
        {
          "lineNum": 50,
          "content": "          audioRef.current.removeEventListener('pause', handlersRef.current.handlePause);"
        },
        {
          "lineNum": 51,
          "content": "          audioRef.current.removeEventListener('ended', handlersRef.current.handleEnded);"
        },
        {
          "lineNum": 52,
          "content": "        }"
        },
        {
          "lineNum": 53,
          "content": "        audioRef.current = null;"
        },
        {
          "lineNum": 54,
          "content": "      }"
        },
        {
          "lineNum": 55,
          "content": "      handlersRef.current = null;"
        }
      ]
    },
    {
      "functionName": "AudioControl (useEffect callback)",
      "file": "src/components/AudioControl/AudioControl.tsx",
      "line": 22,
      "actualComplexity": 8,
      "calculatedTotal": 3,
      "difference": -5,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 38,
          "name": "if statement"
        },
        {
          "type": "&&",
          "line": 38,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 22,
        "end": 58
      },
      "functionCode": [
        {
          "lineNum": 22,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 23,
          "content": "    // Determine audio file based on theme (but don't create Audio yet - lazy load on interaction)"
        },
        {
          "lineNum": 24,
          "content": "    let audioFile: string | null = null;"
        },
        {
          "lineNum": 25,
          "content": "    if (currentPresetId === 'samson') {"
        },
        {
          "lineNum": 26,
          "content": "      audioFile = '/samson.mp3';"
        },
        {
          "lineNum": 27,
          "content": "    } else if (currentPresetId === 'noname') {"
        },
        {
          "lineNum": 28,
          "content": "      audioFile = '/noname.mp3';"
        },
        {
          "lineNum": 29,
          "content": "    } else if (currentPresetId === 'vapor-wave') {"
        },
        {
          "lineNum": 30,
          "content": "      audioFile = 'http://radio.plaza.one/mp3';"
        },
        {
          "lineNum": 31,
          "content": "    } else if (currentPresetId === 'king') {"
        },
        {
          "lineNum": 32,
          "content": "      audioFile = '/i_have_a_dream_speech.mp3';"
        },
        {
          "lineNum": 33,
          "content": "    } else if (currentPresetId === 'planet') {"
        },
        {
          "lineNum": 34,
          "content": "      audioFile = '/earth_song.mp3';"
        },
        {
          "lineNum": 35,
          "content": "    }"
        },
        {
          "lineNum": 36,
          "content": ""
        },
        {
          "lineNum": 37,
          "content": "    // Store audio file path, but don't create Audio instance yet (prevents eager download)"
        },
        {
          "lineNum": 38,
          "content": "    if (isThemeWithAudio && audioFile) {"
        },
        {
          "lineNum": 39,
          "content": "      audioFileRef.current = audioFile;"
        },
        {
          "lineNum": 40,
          "content": "    } else {"
        },
        {
          "lineNum": 41,
          "content": "      audioFileRef.current = null;"
        },
        {
          "lineNum": 42,
          "content": "    }"
        },
        {
          "lineNum": 43,
          "content": ""
        },
        {
          "lineNum": 44,
          "content": "    // Cleanup: if audio was created, clean it up when theme changes"
        },
        {
          "lineNum": 45,
          "content": "    return () => {"
        },
        {
          "lineNum": 46,
          "content": "      if (audioRef.current) {"
        },
        {
          "lineNum": 47,
          "content": "        audioRef.current.pause();"
        },
        {
          "lineNum": 48,
          "content": "        if (handlersRef.current) {"
        },
        {
          "lineNum": 49,
          "content": "          audioRef.current.removeEventListener('play', handlersRef.current.handlePlay);"
        },
        {
          "lineNum": 50,
          "content": "          audioRef.current.removeEventListener('pause', handlersRef.current.handlePause);"
        },
        {
          "lineNum": 51,
          "content": "          audioRef.current.removeEventListener('ended', handlersRef.current.handleEnded);"
        },
        {
          "lineNum": 52,
          "content": "        }"
        },
        {
          "lineNum": 53,
          "content": "        audioRef.current = null;"
        },
        {
          "lineNum": 54,
          "content": "      }"
        },
        {
          "lineNum": 55,
          "content": "      handlersRef.current = null;"
        },
        {
          "lineNum": 56,
          "content": "      setIsPlaying(false);"
        },
        {
          "lineNum": 57,
          "content": "    };"
        },
        {
          "lineNum": 58,
          "content": "  }, [isThemeWithAudio, currentPresetId]);"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/components/AudioControl/AudioControl.tsx",
      "line": 61,
      "actualComplexity": 3,
      "calculatedTotal": 2,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 63,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 61,
        "end": 91
      },
      "functionCode": [
        {
          "lineNum": 61,
          "content": "  const initializeAudio = (): HTMLAudioElement | null => {"
        },
        {
          "lineNum": 62,
          "content": "    // If audio already exists, return it"
        },
        {
          "lineNum": 63,
          "content": "    if (audioRef.current) {"
        },
        {
          "lineNum": 64,
          "content": "      return audioRef.current;"
        },
        {
          "lineNum": 65,
          "content": "    }"
        },
        {
          "lineNum": 66,
          "content": ""
        },
        {
          "lineNum": 67,
          "content": "    // If no audio file configured, can't create audio"
        },
        {
          "lineNum": 68,
          "content": "    if (!audioFileRef.current) {"
        },
        {
          "lineNum": 69,
          "content": "      return null;"
        },
        {
          "lineNum": 70,
          "content": "    }"
        },
        {
          "lineNum": 71,
          "content": ""
        },
        {
          "lineNum": 72,
          "content": "    // Create audio element only on user interaction (lazy load)"
        },
        {
          "lineNum": 73,
          "content": "    const audio = new Audio(audioFileRef.current);"
        },
        {
          "lineNum": 74,
          "content": "    audio.loop = true; // Loop the audio"
        },
        {
          "lineNum": 75,
          "content": "    audioRef.current = audio;"
        },
        {
          "lineNum": 76,
          "content": ""
        },
        {
          "lineNum": 77,
          "content": "    // Create event handlers"
        },
        {
          "lineNum": 78,
          "content": "    const handlePlay = () => setIsPlaying(true);"
        },
        {
          "lineNum": 79,
          "content": "    const handlePause = () => setIsPlaying(false);"
        },
        {
          "lineNum": 80,
          "content": "    const handleEnded = () => setIsPlaying(false);"
        },
        {
          "lineNum": 81,
          "content": ""
        },
        {
          "lineNum": 82,
          "content": "    // Store handlers in ref so we can remove them properly"
        },
        {
          "lineNum": 83,
          "content": "    handlersRef.current = { handlePlay, handlePause, handleEnded };"
        },
        {
          "lineNum": 84,
          "content": ""
        },
        {
          "lineNum": 85,
          "content": "    // Listen for play/pause events to update state"
        },
        {
          "lineNum": 86,
          "content": "    audio.addEventListener('play', handlePlay);"
        },
        {
          "lineNum": 87,
          "content": "    audio.addEventListener('pause', handlePause);"
        },
        {
          "lineNum": 88,
          "content": "    audio.addEventListener('ended', handleEnded);"
        },
        {
          "lineNum": 89,
          "content": ""
        },
        {
          "lineNum": 90,
          "content": "    return audio;"
        },
        {
          "lineNum": 91,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "PresetSection",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 282,
      "actualComplexity": 8,
      "calculatedTotal": 1,
      "difference": -7,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 282,
        "end": 301
      },
      "functionCode": [
        {
          "lineNum": 282,
          "content": "function PresetSection({"
        },
        {
          "lineNum": 283,
          "content": "  presets,"
        },
        {
          "lineNum": 284,
          "content": "  currentPresetId,"
        },
        {
          "lineNum": 285,
          "content": "  isPresetsExpanded,"
        },
        {
          "lineNum": 286,
          "content": "  isPresetsHeaderCollapsed,"
        },
        {
          "lineNum": 287,
          "content": "  showSavePreset,"
        },
        {
          "lineNum": 288,
          "content": "  presetName,"
        },
        {
          "lineNum": 289,
          "content": "  onLoadPreset,"
        },
        {
          "lineNum": 290,
          "content": "  onDeletePreset,"
        },
        {
          "lineNum": 291,
          "content": "  onToggleExpanded,"
        },
        {
          "lineNum": 292,
          "content": "  onPresetsHeaderKeyDown,"
        },
        {
          "lineNum": 293,
          "content": "  onShowSavePreset,"
        },
        {
          "lineNum": 294,
          "content": "  onSavePreset,"
        },
        {
          "lineNum": 295,
          "content": "  onSavePresetKeyDown,"
        },
        {
          "lineNum": 296,
          "content": "  onPresetNameChange,"
        },
        {
          "lineNum": 297,
          "content": "  onCancelSavePreset,"
        },
        {
          "lineNum": 298,
          "content": "  styles,"
        },
        {
          "lineNum": 299,
          "content": "}: PresetSectionProps) {"
        },
        {
          "lineNum": 300,
          "content": "  return ("
        },
        {
          "lineNum": 301,
          "content": "    <div className={styles.presetsSection}>"
        }
      ]
    },
    {
      "functionName": "handleBackdropClick (useCallback callback)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 704,
      "actualComplexity": 6,
      "calculatedTotal": 2,
      "difference": -4,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 721,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 704,
        "end": 727
      },
      "functionCode": [
        {
          "lineNum": 704,
          "content": "  const colorToHex = useCallback((color: string): string => {"
        },
        {
          "lineNum": 705,
          "content": "    try {"
        },
        {
          "lineNum": 706,
          "content": "      // Handle rgba - extract rgb values (color input doesn't support alpha)"
        },
        {
          "lineNum": 707,
          "content": "      if (color.startsWith('rgba')) {"
        },
        {
          "lineNum": 708,
          "content": "        const matches = color.match(/\\d+/g);"
        },
        {
          "lineNum": 709,
          "content": "        if (matches && matches.length >= 3) {"
        },
        {
          "lineNum": 710,
          "content": "          const r = parseInt(matches[0]);"
        },
        {
          "lineNum": 711,
          "content": "          const g = parseInt(matches[1]);"
        },
        {
          "lineNum": 712,
          "content": "          const b = parseInt(matches[2]);"
        },
        {
          "lineNum": 713,
          "content": "          return `#${[r, g, b].map(x => x.toString(16).padStart(2, '0')).join('')}`;"
        },
        {
          "lineNum": 714,
          "content": "        }"
        },
        {
          "lineNum": 715,
          "content": "      }"
        },
        {
          "lineNum": 716,
          "content": "      // Use color library to handle other formats (rgb, hex, etc.)"
        },
        {
          "lineNum": 717,
          "content": "      const parsed = Color(color);"
        },
        {
          "lineNum": 718,
          "content": "      return parsed.hex();"
        },
        {
          "lineNum": 719,
          "content": "    } catch {"
        },
        {
          "lineNum": 720,
          "content": "      // Fallback: if it's already hex, return as-is"
        },
        {
          "lineNum": 721,
          "content": "      if (color.startsWith('#')) {"
        },
        {
          "lineNum": 722,
          "content": "        return color;"
        },
        {
          "lineNum": 723,
          "content": "      }"
        },
        {
          "lineNum": 724,
          "content": "      // Default fallback"
        },
        {
          "lineNum": 725,
          "content": "      return '#000000';"
        },
        {
          "lineNum": 726,
          "content": "    }"
        },
        {
          "lineNum": 727,
          "content": "  }, []);"
        }
      ]
    },
    {
      "functionName": "PresetSection (map callback)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 325,
      "actualComplexity": 4,
      "calculatedTotal": 5,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "&&",
          "line": 337,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 338,
          "name": "logical AND"
        },
        {
          "type": "&&",
          "line": 339,
          "name": "logical AND"
        },
        {
          "type": "default parameter",
          "line": 342,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 3,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 325,
        "end": 356
      },
      "functionCode": [
        {
          "lineNum": 325,
          "content": "        {presets.map((preset) => {"
        },
        {
          "lineNum": 326,
          "content": "          const isBuiltIn = isBuiltInPreset(preset.id);"
        },
        {
          "lineNum": 327,
          "content": "          const showEasterEgg = hasAudioEasterEgg(preset.id);"
        },
        {
          "lineNum": 328,
          "content": "          const isSelected = preset.id === currentPresetId;"
        },
        {
          "lineNum": 329,
          "content": "          return ("
        },
        {
          "lineNum": 330,
          "content": "            <div key={preset.id} className={styles.presetButtonWrapper}>"
        },
        {
          "lineNum": 331,
          "content": "              <button"
        },
        {
          "lineNum": 332,
          "content": "                className={styles.presetButton}"
        },
        {
          "lineNum": 333,
          "content": "                onClick={() => onLoadPreset(preset.id)}"
        },
        {
          "lineNum": 334,
          "content": "              >"
        },
        {
          "lineNum": 335,
          "content": "                <span className={styles.presetName}>{preset.name}</span>"
        },
        {
          "lineNum": 336,
          "content": "                <div className={styles.presetIconContainer}>"
        },
        {
          "lineNum": 337,
          "content": "                  {showEasterEgg && <Music size={16} className={styles.presetIcon} />}"
        },
        {
          "lineNum": 338,
          "content": "                  {isSelected && <Pin size={16} className={styles.presetIcon} fill=\"currentColor\" />}"
        },
        {
          "lineNum": 339,
          "content": "                  {!isBuiltIn && ("
        },
        {
          "lineNum": 340,
          "content": "                    <button"
        },
        {
          "lineNum": 341,
          "content": "                      className={styles.deletePresetBtn}"
        },
        {
          "lineNum": 342,
          "content": "                      onClick={(e) => {"
        },
        {
          "lineNum": 343,
          "content": "                        e.stopPropagation();"
        },
        {
          "lineNum": 344,
          "content": "                        onDeletePreset(preset.id, e);"
        },
        {
          "lineNum": 345,
          "content": "                      }}"
        },
        {
          "lineNum": 346,
          "content": "                      aria-label={`Delete ${preset.name} preset`}"
        },
        {
          "lineNum": 347,
          "content": "                      title=\"Delete preset\""
        },
        {
          "lineNum": 348,
          "content": "                    >"
        },
        {
          "lineNum": 349,
          "content": "                      <Trash2 size={14} />"
        },
        {
          "lineNum": 350,
          "content": "                    </button>"
        },
        {
          "lineNum": 351,
          "content": "                  )}"
        },
        {
          "lineNum": 352,
          "content": "                </div>"
        },
        {
          "lineNum": 353,
          "content": "              </button>"
        },
        {
          "lineNum": 354,
          "content": "            </div>"
        },
        {
          "lineNum": 355,
          "content": "          );"
        },
        {
          "lineNum": 356,
          "content": "        })}"
        }
      ]
    },
    {
      "functionName": "ThemePicker",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 517,
      "actualComplexity": 4,
      "calculatedTotal": 1,
      "difference": -3,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 517,
        "end": 864
      },
      "functionCode": [
        {
          "lineNum": 517,
          "content": "export function ThemePicker() {"
        },
        {
          "lineNum": 518,
          "content": "  const { theme, updateTheme, resetTheme, presets, savePreset, loadPreset, deletePreset, currentPresetId } = useTheme();"
        },
        {
          "lineNum": 519,
          "content": "  const [localChanges, setLocalChanges] = useState<Partial<typeof theme>>({});"
        },
        {
          "lineNum": 520,
          "content": "  const [isOpen, setIsOpen] = useState(false);"
        },
        {
          "lineNum": 521,
          "content": "  const [presetName, setPresetName] = useState('');"
        },
        {
          "lineNum": 522,
          "content": "  const [showSavePreset, setShowSavePreset] = useState(false);"
        },
        {
          "lineNum": 523,
          "content": "  const [isPresetsExpanded, setIsPresetsExpanded] = useState(false);"
        },
        {
          "lineNum": 524,
          "content": "  const [isPresetsHeaderCollapsed, setIsPresetsHeaderCollapsed] = useState(false);"
        },
        {
          "lineNum": 525,
          "content": "  const [isTriggerHidden, setIsTriggerHidden] = useState(false);"
        },
        {
          "lineNum": 526,
          "content": "  const drawerRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 527,
          "content": "  const backdropRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 528,
          "content": "  const triggerRef = useRef<HTMLButtonElement>(null);"
        },
        {
          "lineNum": 529,
          "content": ""
        },
        {
          "lineNum": 530,
          "content": "  // PERFORMANCE OPTIMIZATION: Only check contrast when drawer is open"
        },
        {
          "lineNum": 531,
          "content": "  // This prevents expensive contrast calculations when the picker is closed"
        },
        {
          "lineNum": 532,
          "content": "  // checkContrastIssues() creates many Color objects and performs ~20+ contrast checks"
        },
        {
          "lineNum": 533,
          "content": "  const contrastIssues = useMemo(() => {"
        },
        {
          "lineNum": 534,
          "content": "    if (!isOpen) return [];"
        },
        {
          "lineNum": 535,
          "content": "    "
        },
        {
          "lineNum": 536,
          "content": "    const currentTheme = { ...theme, ...localChanges };"
        },
        {
          "lineNum": 537,
          "content": "    return checkContrastIssues({"
        },
        {
          "lineNum": 538,
          "content": "      bg: currentTheme.bg,"
        },
        {
          "lineNum": 539,
          "content": "      text: currentTheme.text,"
        },
        {
          "lineNum": 540,
          "content": "      primary: currentTheme.primary,"
        },
        {
          "lineNum": 541,
          "content": "      primaryContrast: currentTheme.primaryContrast,"
        },
        {
          "lineNum": 542,
          "content": "      surface: currentTheme.surface,"
        },
        {
          "lineNum": 543,
          "content": "      surfaceDark: currentTheme.surfaceDark,"
        },
        {
          "lineNum": 544,
          "content": "      textDark: currentTheme.textDark,"
        },
        {
          "lineNum": 545,
          "content": "      link: currentTheme.link,"
        },
        {
          "lineNum": 546,
          "content": "      footerBg: currentTheme.footerBg,"
        },
        {
          "lineNum": 547,
          "content": "      footerTextMuted: currentTheme.footerTextMuted,"
        },
        {
          "lineNum": 548,
          "content": "      footerTextSubtle: currentTheme.footerTextSubtle,"
        },
        {
          "lineNum": 549,
          "content": "      footerSocialBg: currentTheme.footerSocialBg,"
        },
        {
          "lineNum": 550,
          "content": "      accentAlt: currentTheme.accentAlt,"
        },
        {
          "lineNum": 551,
          "content": "      codeBg: currentTheme.codeBg,"
        },
        {
          "lineNum": 552,
          "content": "      codeText: currentTheme.codeText,"
        },
        {
          "lineNum": 553,
          "content": "      blogLink: currentTheme.blogLink,"
        },
        {
          "lineNum": 554,
          "content": "      authorBoxStart: currentTheme.authorBoxStart,"
        },
        {
          "lineNum": 555,
          "content": "      authorBoxEnd: currentTheme.authorBoxEnd,"
        },
        {
          "lineNum": 556,
          "content": "      relatedSectionStart: currentTheme.relatedSectionStart,"
        },
        {
          "lineNum": 557,
          "content": "      relatedSectionEnd: currentTheme.relatedSectionEnd,"
        },
        {
          "lineNum": 558,
          "content": "    });"
        },
        {
          "lineNum": 559,
          "content": "  }, [theme, localChanges, isOpen]);"
        },
        {
          "lineNum": 560,
          "content": ""
        },
        {
          "lineNum": 561,
          "content": "  // Memoize event handlers to prevent unnecessary re-renders"
        },
        {
          "lineNum": 562,
          "content": "  const handleColorChange = useCallback((key: keyof typeof theme, value: string) => {"
        },
        {
          "lineNum": 563,
          "content": "    setLocalChanges((prev) => ({ ...prev, [key]: value }));"
        },
        {
          "lineNum": 564,
          "content": "    // Apply temporarily for preview"
        },
        {
          "lineNum": 565,
          "content": "    const root = document.getElementById('root');"
        },
        {
          "lineNum": 566,
          "content": "    if (root) {"
        }
      ]
    },
    {
      "functionName": "ColorItem (arrow function)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 105,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 105,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 105,
        "end": 105
      },
      "functionCode": [
        {
          "lineNum": 105,
          "content": "        onChange={(e) => onColorChange(token.key, e.target.value)}"
        }
      ]
    },
    {
      "functionName": "ColorItem (arrow function)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 110,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 110,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 110,
        "end": 110
      },
      "functionCode": [
        {
          "lineNum": 110,
          "content": "          onClick={() => onCancel(token.key)}"
        }
      ]
    },
    {
      "functionName": "PresetSection (arrow function)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 314,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 314,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 314,
        "end": 317
      },
      "functionCode": [
        {
          "lineNum": 314,
          "content": "          onClick={(e) => {"
        },
        {
          "lineNum": 315,
          "content": "            e.stopPropagation();"
        },
        {
          "lineNum": 316,
          "content": "            onToggleExpanded();"
        },
        {
          "lineNum": 317,
          "content": "          }}"
        }
      ]
    },
    {
      "functionName": "PresetSection (arrow function)",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 333,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 333,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 333,
        "end": 333
      },
      "functionCode": [
        {
          "lineNum": 333,
          "content": "                onClick={() => onLoadPreset(preset.id)}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/components/ThemePicker/ThemePicker.tsx",
      "line": 372,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 372,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 372,
        "end": 372
      },
      "functionCode": [
        {
          "lineNum": 372,
          "content": "                onChange={(e) => onPresetNameChange(e.target.value)}"
        }
      ]
    },
    {
      "functionName": "useCallback callback",
      "file": "src/context/ThemeContext.tsx",
      "line": 140,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 141,
          "name": "logical OR"
        },
        {
          "type": "default parameter",
          "line": 142,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 140,
        "end": 151
      },
      "functionCode": [
        {
          "lineNum": 140,
          "content": "  const savePreset = useCallback((name: string, themeToSave?: Theme) => {"
        },
        {
          "lineNum": 141,
          "content": "    const themeForPreset = themeToSave || theme;"
        },
        {
          "lineNum": 142,
          "content": "    const newPreset: Preset = {"
        },
        {
          "lineNum": 143,
          "content": "      id: `custom-${Date.now()}`,"
        },
        {
          "lineNum": 144,
          "content": "      name,"
        },
        {
          "lineNum": 145,
          "content": "      theme: { ...themeForPreset },"
        },
        {
          "lineNum": 146,
          "content": "    };"
        },
        {
          "lineNum": 147,
          "content": "    const customPresets = presets.filter((p) => !builtInPresets.find((bp) => bp.id === p.id));"
        },
        {
          "lineNum": 148,
          "content": "    const updated = [...builtInPresets, ...customPresets, newPreset];"
        },
        {
          "lineNum": 149,
          "content": "    setPresets(updated);"
        },
        {
          "lineNum": 150,
          "content": "    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(customPresets.concat(newPreset)));"
        },
        {
          "lineNum": 151,
          "content": "  }, [theme, presets]);"
        }
      ]
    },
    {
      "functionName": "useCallback callback",
      "file": "src/context/ThemeContext.tsx",
      "line": 163,
      "actualComplexity": 2,
      "calculatedTotal": 1,
      "difference": -1,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 163,
        "end": 172
      },
      "functionCode": [
        {
          "lineNum": 163,
          "content": "  const deletePreset = useCallback((presetId: string) => {"
        },
        {
          "lineNum": 164,
          "content": "    // Don't allow deleting built-in presets"
        },
        {
          "lineNum": 165,
          "content": "    if (builtInPresets.find((p) => p.id === presetId)) {"
        },
        {
          "lineNum": 166,
          "content": "      return;"
        },
        {
          "lineNum": 167,
          "content": "    }"
        },
        {
          "lineNum": 168,
          "content": "    const customPresets = presets.filter((p) => p.id !== presetId && !builtInPresets.find((bp) => bp.id === p.id));"
        },
        {
          "lineNum": 169,
          "content": "    const updated = [...builtInPresets, ...customPresets];"
        },
        {
          "lineNum": 170,
          "content": "    setPresets(updated);"
        },
        {
          "lineNum": 171,
          "content": "    localStorage.setItem(PRESETS_STORAGE_KEY, JSON.stringify(customPresets));"
        },
        {
          "lineNum": 172,
          "content": "  }, [presets]);"
        }
      ]
    },
    {
      "functionName": "getRelatedPosts",
      "file": "src/data/blog/index.ts",
      "line": 141,
      "actualComplexity": 4,
      "calculatedTotal": 3,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 141,
          "name": "default parameter"
        },
        {
          "type": "if",
          "line": 152,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 141,
        "end": 206
      },
      "functionCode": [
        {
          "lineNum": 141,
          "content": "export function getRelatedPosts(currentPost: BlogPost, limit: number = 3): BlogPosts {"
        },
        {
          "lineNum": 142,
          "content": "  const allPosts = getAllBlogPosts();"
        },
        {
          "lineNum": 143,
          "content": "  "
        },
        {
          "lineNum": 144,
          "content": "  // Exclude current post using slug comparison (not ID) because IDs can be"
        },
        {
          "lineNum": 145,
          "content": "  // duplicated across different topics, but slugs are unique"
        },
        {
          "lineNum": 146,
          "content": "  const otherPosts = allPosts.filter((p) => {"
        },
        {
          "lineNum": 147,
          "content": "    const currentSlug = getBlogPostSlug(currentPost);"
        },
        {
          "lineNum": 148,
          "content": "    const postSlug = getBlogPostSlug(p);"
        },
        {
          "lineNum": 149,
          "content": "    return currentSlug !== postSlug;"
        },
        {
          "lineNum": 150,
          "content": "  });"
        },
        {
          "lineNum": 151,
          "content": "  "
        },
        {
          "lineNum": 152,
          "content": "  if (otherPosts.length === 0) {"
        },
        {
          "lineNum": 153,
          "content": "    return [];"
        },
        {
          "lineNum": 154,
          "content": "  }"
        },
        {
          "lineNum": 155,
          "content": "  "
        },
        {
          "lineNum": 156,
          "content": "  // Score each post based on tag/category matches"
        },
        {
          "lineNum": 157,
          "content": "  const scoredPosts = otherPosts.map((post) => {"
        },
        {
          "lineNum": 158,
          "content": "    let score = 0;"
        },
        {
          "lineNum": 159,
          "content": "    "
        },
        {
          "lineNum": 160,
          "content": "    // Category match: +10 points"
        },
        {
          "lineNum": 161,
          "content": "    // Category is weighted higher because it represents broader topic alignment"
        },
        {
          "lineNum": 162,
          "content": "    if (currentPost.category && post.category && currentPost.category === post.category) {"
        },
        {
          "lineNum": 163,
          "content": "      score += 10;"
        },
        {
          "lineNum": 164,
          "content": "    }"
        },
        {
          "lineNum": 165,
          "content": "    "
        },
        {
          "lineNum": 166,
          "content": "    // Tag matches: +5 points per matching tag"
        },
        {
          "lineNum": 167,
          "content": "    // Tags are case-insensitive to handle variations like \"React\" vs \"react\""
        },
        {
          "lineNum": 168,
          "content": "    if (currentPost.tags && post.tags) {"
        },
        {
          "lineNum": 169,
          "content": "      const currentTags = new Set(currentPost.tags.map(t => t.toLowerCase()));"
        },
        {
          "lineNum": 170,
          "content": "      const postTags = new Set(post.tags.map(t => t.toLowerCase()));"
        },
        {
          "lineNum": 171,
          "content": "      "
        },
        {
          "lineNum": 172,
          "content": "      currentTags.forEach(tag => {"
        },
        {
          "lineNum": 173,
          "content": "        if (postTags.has(tag)) {"
        },
        {
          "lineNum": 174,
          "content": "          score += 5;"
        },
        {
          "lineNum": 175,
          "content": "        }"
        },
        {
          "lineNum": 176,
          "content": "      });"
        },
        {
          "lineNum": 177,
          "content": "    }"
        },
        {
          "lineNum": 178,
          "content": "    "
        },
        {
          "lineNum": 179,
          "content": "    return { post, score };"
        },
        {
          "lineNum": 180,
          "content": "  });"
        },
        {
          "lineNum": 181,
          "content": "  "
        },
        {
          "lineNum": 182,
          "content": "  // Filter to posts with at least one match, sort by score (descending), take top N"
        },
        {
          "lineNum": 183,
          "content": "  const related = scoredPosts"
        },
        {
          "lineNum": 184,
          "content": "    .filter(item => item.score > 0) // Only include posts with at least one match"
        },
        {
          "lineNum": 185,
          "content": "    .sort((a, b) => b.score - a.score)"
        },
        {
          "lineNum": 186,
          "content": "    .slice(0, limit)"
        },
        {
          "lineNum": 187,
          "content": "    .map(item => item.post);"
        },
        {
          "lineNum": 188,
          "content": "  "
        },
        {
          "lineNum": 189,
          "content": "  // Fallback: If we don't have enough matching posts, fill remaining slots"
        },
        {
          "lineNum": 190,
          "content": "  // with random posts to ensure the \"Related Content\" section always displays"
        }
      ]
    },
    {
      "functionName": "useMetaTags",
      "file": "src/hooks/useMetaTags.ts",
      "line": 132,
      "actualComplexity": 6,
      "calculatedTotal": 9,
      "difference": 3,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 138,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 139,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 140,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 140,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 141,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 141,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 142,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 142,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 8
      },
      "boundary": {
        "start": 132,
        "end": 160
      },
      "functionCode": [
        {
          "lineNum": 132,
          "content": "export function useMetaTags(config: MetaTagsConfig) {"
        },
        {
          "lineNum": 133,
          "content": "  const {"
        },
        {
          "lineNum": 134,
          "content": "    title,"
        },
        {
          "lineNum": 135,
          "content": "    description,"
        },
        {
          "lineNum": 136,
          "content": "    image,"
        },
        {
          "lineNum": 137,
          "content": "    url,"
        },
        {
          "lineNum": 138,
          "content": "    type = 'website',"
        },
        {
          "lineNum": 139,
          "content": "    siteName = 'Johnny H.',"
        },
        {
          "lineNum": 140,
          "content": "    twitterCard = 'summary_large_image',"
        },
        {
          "lineNum": 141,
          "content": "    noindex = false,"
        },
        {
          "lineNum": 142,
          "content": "    nofollow = false,"
        },
        {
          "lineNum": 143,
          "content": "  } = config;"
        },
        {
          "lineNum": 144,
          "content": ""
        },
        {
          "lineNum": 145,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 146,
          "content": "    const baseUrl = getBaseUrl();"
        },
        {
          "lineNum": 147,
          "content": "    const fullUrl = resolveUrl(url, baseUrl);"
        },
        {
          "lineNum": 148,
          "content": "    const fullImage = resolveImageUrl(image, baseUrl);"
        },
        {
          "lineNum": 149,
          "content": ""
        },
        {
          "lineNum": 150,
          "content": "    if (title) {"
        },
        {
          "lineNum": 151,
          "content": "      document.title = title;"
        },
        {
          "lineNum": 152,
          "content": "    }"
        },
        {
          "lineNum": 153,
          "content": ""
        },
        {
          "lineNum": 154,
          "content": "    setConditionalMetaTags([{ property: 'description', content: description }]);"
        },
        {
          "lineNum": 155,
          "content": "    setOpenGraphTags(title, description, fullImage, fullUrl, type, siteName);"
        },
        {
          "lineNum": 156,
          "content": "    setTwitterCardTags(twitterCard, title, description, fullImage);"
        },
        {
          "lineNum": 157,
          "content": "    setCanonicalLink(fullUrl);"
        },
        {
          "lineNum": 158,
          "content": "    setMetaTag('robots', generateRobotsContent(noindex, nofollow));"
        },
        {
          "lineNum": 159,
          "content": "  }, [title, description, image, url, type, siteName, twitterCard, noindex, nofollow]);"
        },
        {
          "lineNum": 160,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "setConditionalMetaTags",
      "file": "src/hooks/useMetaTags.ts",
      "line": 80,
      "actualComplexity": 1,
      "calculatedTotal": 3,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 81,
          "name": "ternary operator"
        },
        {
          "type": "default parameter",
          "line": 83,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 80,
        "end": 88
      },
      "functionCode": [
        {
          "lineNum": 80,
          "content": "function setConditionalMetaTags("
        },
        {
          "lineNum": 81,
          "content": "  tags: Array<{ property: string; content: string | undefined; isProperty?: boolean }>"
        },
        {
          "lineNum": 82,
          "content": "): void {"
        },
        {
          "lineNum": 83,
          "content": "  tags.forEach(({ property, content, isProperty = false }) => {"
        },
        {
          "lineNum": 84,
          "content": "    if (content) {"
        },
        {
          "lineNum": 85,
          "content": "      setMetaTag(property, content, isProperty);"
        },
        {
          "lineNum": 86,
          "content": "    }"
        },
        {
          "lineNum": 87,
          "content": "  });"
        },
        {
          "lineNum": 88,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "BlogFilters (filter callback)",
      "file": "src/sections/BlogFilters/index.tsx",
      "line": 42,
      "actualComplexity": 5,
      "calculatedTotal": 2,
      "difference": -3,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "||",
          "line": 43,
          "name": "logical OR"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 42,
        "end": 43
      },
      "functionCode": [
        {
          "lineNum": 42,
          "content": "        (post) =>"
        },
        {
          "lineNum": 43,
          "content": "          post.title.toLowerCase().includes(query) ||"
        }
      ]
    },
    {
      "functionName": "BlogFilters (useEffect callback)",
      "file": "src/sections/BlogFilters/index.tsx",
      "line": 26,
      "actualComplexity": 3,
      "calculatedTotal": 6,
      "difference": 3,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 30,
          "name": "if statement"
        },
        {
          "type": "if",
          "line": 39,
          "name": "if statement"
        },
        {
          "type": "||",
          "line": 44,
          "name": "logical OR"
        },
        {
          "type": "||",
          "line": 45,
          "name": "logical OR"
        },
        {
          "type": "&&",
          "line": 46,
          "name": "logical AND"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 1,
        "||": 2,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 26,
        "end": 51
      },
      "functionCode": [
        {
          "lineNum": 26,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 27,
          "content": "    let filtered = [...posts]; // Create a copy to avoid mutating"
        },
        {
          "lineNum": 28,
          "content": ""
        },
        {
          "lineNum": 29,
          "content": "    // Filter by category or tag"
        },
        {
          "lineNum": 30,
          "content": "    if (selectedCategory !== \"all\") {"
        },
        {
          "lineNum": 31,
          "content": "      filtered = filtered.filter("
        },
        {
          "lineNum": 32,
          "content": "        (post) => "
        },
        {
          "lineNum": 33,
          "content": "          post.category === selectedCategory || "
        },
        {
          "lineNum": 34,
          "content": "          (post.tags && post.tags.includes(selectedCategory))"
        },
        {
          "lineNum": 35,
          "content": "      );"
        },
        {
          "lineNum": 36,
          "content": "    }"
        },
        {
          "lineNum": 37,
          "content": ""
        },
        {
          "lineNum": 38,
          "content": "    // Filter by search query"
        },
        {
          "lineNum": 39,
          "content": "    if (searchQuery.trim()) {"
        },
        {
          "lineNum": 40,
          "content": "      const query = searchQuery.toLowerCase();"
        },
        {
          "lineNum": 41,
          "content": "      filtered = filtered.filter("
        },
        {
          "lineNum": 42,
          "content": "        (post) =>"
        },
        {
          "lineNum": 43,
          "content": "          post.title.toLowerCase().includes(query) ||"
        },
        {
          "lineNum": 44,
          "content": "          post.excerpt.toLowerCase().includes(query) ||"
        },
        {
          "lineNum": 45,
          "content": "          post.category.toLowerCase().includes(query) ||"
        },
        {
          "lineNum": 46,
          "content": "          (post.tags && post.tags.some(tag => tag.toLowerCase().includes(query)))"
        },
        {
          "lineNum": 47,
          "content": "      );"
        },
        {
          "lineNum": 48,
          "content": "    }"
        },
        {
          "lineNum": 49,
          "content": ""
        },
        {
          "lineNum": 50,
          "content": "    onFilterChange(filtered);"
        },
        {
          "lineNum": 51,
          "content": "  }, [posts, searchQuery, selectedCategory, onFilterChange]);"
        }
      ]
    },
    {
      "functionName": "BlogFilters (arrow function)",
      "file": "src/sections/BlogFilters/index.tsx",
      "line": 63,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 63,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 63,
        "end": 63
      },
      "functionCode": [
        {
          "lineNum": 63,
          "content": "            onChange={(e) => setSelectedCategory(e.target.value)}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/BlogFilters/index.tsx",
      "line": 83,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 83,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 83,
        "end": 83
      },
      "functionCode": [
        {
          "lineNum": 83,
          "content": "          onChange={(e) => setSearchQuery(e.target.value)}"
        }
      ]
    },
    {
      "functionName": "FeatureAccordion",
      "file": "src/sections/FeatureAccordion/index.tsx",
      "line": 93,
      "actualComplexity": 3,
      "calculatedTotal": 1,
      "difference": -2,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 93,
        "end": 260
      },
      "functionCode": [
        {
          "lineNum": 93,
          "content": "export function FeatureAccordion() {"
        },
        {
          "lineNum": 94,
          "content": "  const { currentPresetId } = useTheme();"
        },
        {
          "lineNum": 95,
          "content": "  const isNoirTheme = currentPresetId === 'noir';"
        },
        {
          "lineNum": 96,
          "content": ""
        },
        {
          "lineNum": 97,
          "content": "  // Accordion behavior: one item open at all times"
        },
        {
          "lineNum": 98,
          "content": "  // Initialize with first item's ID, defaulting to 1 if items array is empty"
        },
        {
          "lineNum": 99,
          "content": "  const firstItemId = items[0]?.id ?? 1;"
        },
        {
          "lineNum": 100,
          "content": "  const [activeId, setActiveId] = useState<number>(firstItemId);"
        },
        {
          "lineNum": 101,
          "content": ""
        },
        {
          "lineNum": 102,
          "content": "  // Refs for height matching"
        },
        {
          "lineNum": 103,
          "content": "  const controlsWrapperRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 104,
          "content": "  const contentsWrapperRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 105,
          "content": ""
        },
        {
          "lineNum": 106,
          "content": "  // Match heights between left and right columns (desktop only)"
        },
        {
          "lineNum": 107,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 108,
          "content": "    const matchHeights = () => {"
        },
        {
          "lineNum": 109,
          "content": "      // Only run on desktop (window width > 990px)"
        },
        {
          "lineNum": 110,
          "content": "      if (window.innerWidth <= 990) {"
        },
        {
          "lineNum": 111,
          "content": "        // Reset height on mobile"
        },
        {
          "lineNum": 112,
          "content": "        if (contentsWrapperRef.current) {"
        },
        {
          "lineNum": 113,
          "content": "          contentsWrapperRef.current.style.height = \"\";"
        },
        {
          "lineNum": 114,
          "content": "        }"
        },
        {
          "lineNum": 115,
          "content": "        return;"
        },
        {
          "lineNum": 116,
          "content": "      }"
        },
        {
          "lineNum": 117,
          "content": ""
        },
        {
          "lineNum": 118,
          "content": "      if (controlsWrapperRef.current && contentsWrapperRef.current) {"
        },
        {
          "lineNum": 119,
          "content": "        const leftHeight = controlsWrapperRef.current.offsetHeight;"
        },
        {
          "lineNum": 120,
          "content": "        contentsWrapperRef.current.style.height = `${leftHeight}px`;"
        },
        {
          "lineNum": 121,
          "content": "      }"
        },
        {
          "lineNum": 122,
          "content": "    };"
        },
        {
          "lineNum": 123,
          "content": ""
        },
        {
          "lineNum": 124,
          "content": "    // Match heights on mount, activeId change, and window resize"
        },
        {
          "lineNum": 125,
          "content": "    matchHeights();"
        },
        {
          "lineNum": 126,
          "content": "    window.addEventListener(\"resize\", matchHeights);"
        },
        {
          "lineNum": 127,
          "content": ""
        },
        {
          "lineNum": 128,
          "content": "    // Use a small delay to ensure DOM has updated after activeId change"
        },
        {
          "lineNum": 129,
          "content": "    const timeoutId = setTimeout(matchHeights, 0);"
        },
        {
          "lineNum": 130,
          "content": ""
        },
        {
          "lineNum": 131,
          "content": "    return () => {"
        },
        {
          "lineNum": 132,
          "content": "      window.removeEventListener(\"resize\", matchHeights);"
        },
        {
          "lineNum": 133,
          "content": "      clearTimeout(timeoutId);"
        },
        {
          "lineNum": 134,
          "content": "    };"
        },
        {
          "lineNum": 135,
          "content": "  }, [activeId]);"
        },
        {
          "lineNum": 136,
          "content": ""
        },
        {
          "lineNum": 137,
          "content": "  return ("
        },
        {
          "lineNum": 138,
          "content": "    <Section id=\"projects\">"
        },
        {
          "lineNum": 139,
          "content": "      <Container className={styles.projectsContainer}>"
        },
        {
          "lineNum": 140,
          "content": "      <h2 className={styles.heading}>Recent Projects</h2>"
        },
        {
          "lineNum": 141,
          "content": ""
        },
        {
          "lineNum": 142,
          "content": "        <div className={styles.wrapper}>"
        }
      ]
    },
    {
      "functionName": "matchHeights (arrow function)",
      "file": "src/sections/FeatureAccordion/index.tsx",
      "line": 160,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 160,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 160,
        "end": 160
      },
      "functionCode": [
        {
          "lineNum": 160,
          "content": "                        onClick={() => setActiveId(item.id)}"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/FeatureAccordion/index.tsx",
      "line": 209,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 209,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 209,
        "end": 209
      },
      "functionCode": [
        {
          "lineNum": 209,
          "content": "                      onChange={() => setActiveId(item.id)}"
        }
      ]
    },
    {
      "functionName": "max callback",
      "file": "scripts/generate-complexity-report.js",
      "line": 33,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 33,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 33,
        "end": 33
      },
      "functionCode": [
        {
          "lineNum": 33,
          "content": "const maxComplexity = allFunctions.length > 0 ? Math.max(...allFunctions.map(i => parseInt(i.complexity))) : 0;"
        }
      ]
    },
    {
      "functionName": "round callback",
      "file": "scripts/generate-complexity-report.js",
      "line": 34,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 34,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 34,
        "end": 34
      },
      "functionCode": [
        {
          "lineNum": 34,
          "content": "const avgComplexity = allFunctions.length > 0 ? Math.round(allFunctions.reduce((sum, i) => sum + parseInt(i.complexity), 0) / allFunctions.length) : 0;"
        }
      ]
    },
    {
      "functionName": "currentOnSelect (IntersectionObserver callback)",
      "file": "src/sections/AgencyLogos/index.tsx",
      "line": 141,
      "actualComplexity": 4,
      "calculatedTotal": 3,
      "difference": -1,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "?.",
          "line": 142,
          "name": "optional chaining"
        },
        {
          "type": "??",
          "line": 142,
          "name": "nullish coalescing"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 1,
        "?.": 1,
        "default parameter": 0
      },
      "boundary": {
        "start": 141,
        "end": 147
      },
      "functionCode": [
        {
          "lineNum": 141,
          "content": "      (entries) => {"
        },
        {
          "lineNum": 142,
          "content": "        const isVisible = entries[0]?.isIntersecting ?? false;"
        },
        {
          "lineNum": 143,
          "content": "        // Only enable autoplay when visible and user hasn't disabled it"
        },
        {
          "lineNum": 144,
          "content": "        if (!isVisible) {"
        },
        {
          "lineNum": 145,
          "content": "          setAutoplayEnabled(false);"
        },
        {
          "lineNum": 146,
          "content": "        }"
        },
        {
          "lineNum": 147,
          "content": "      },"
        }
      ]
    },
    {
      "functionName": "map callback",
      "file": "src/sections/AgencyLogos/index.tsx",
      "line": 213,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 217,
          "name": "ternary operator"
        },
        {
          "type": "default parameter",
          "line": 220,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 213,
        "end": 222
      },
      "functionCode": [
        {
          "lineNum": 213,
          "content": "          {scrollSnaps.map((_, index) => ("
        },
        {
          "lineNum": 214,
          "content": "            <button"
        },
        {
          "lineNum": 215,
          "content": "              key={index}"
        },
        {
          "lineNum": 216,
          "content": "              className={`${styles.dot} ${"
        },
        {
          "lineNum": 217,
          "content": "                index === selectedIndex ? styles.dotActive : \"\""
        },
        {
          "lineNum": 218,
          "content": "              }`}"
        },
        {
          "lineNum": 219,
          "content": "              onClick={() => scrollTo(index)}"
        },
        {
          "lineNum": 220,
          "content": "              aria-label={`Go to slide ${index + 1}`}"
        },
        {
          "lineNum": 221,
          "content": "            />"
        },
        {
          "lineNum": 222,
          "content": "          ))}"
        }
      ]
    },
    {
      "functionName": "AgencyLogosComponent",
      "file": "src/sections/AgencyLogos/index.tsx",
      "line": 24,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 181,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 24,
        "end": 232
      },
      "functionCode": [
        {
          "lineNum": 24,
          "content": "function AgencyLogosComponent() {"
        },
        {
          "lineNum": 25,
          "content": "  const [emblaRef, emblaApi] = useEmblaCarousel({"
        },
        {
          "lineNum": 26,
          "content": "    loop: true,"
        },
        {
          "lineNum": 27,
          "content": "    align: \"start\","
        },
        {
          "lineNum": 28,
          "content": "    dragFree: true,"
        },
        {
          "lineNum": 29,
          "content": "    skipSnaps: false,"
        },
        {
          "lineNum": 30,
          "content": "    containScroll: \"trimSnaps\","
        },
        {
          "lineNum": 31,
          "content": "  });"
        },
        {
          "lineNum": 32,
          "content": "  const [selectedIndex, setSelectedIndex] = useState(0);"
        },
        {
          "lineNum": 33,
          "content": "  const [scrollSnaps, setScrollSnaps] = useState<number[]>([]);"
        },
        {
          "lineNum": 34,
          "content": "  const [autoplayEnabled, setAutoplayEnabled] = useState(true);"
        },
        {
          "lineNum": 35,
          "content": "  const viewportRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 36,
          "content": ""
        },
        {
          "lineNum": 37,
          "content": "  const scrollTo = useCallback("
        },
        {
          "lineNum": 38,
          "content": "    (index: number) => {"
        },
        {
          "lineNum": 39,
          "content": "      if (emblaApi) {"
        },
        {
          "lineNum": 40,
          "content": "        setAutoplayEnabled(false); // Stop autoplay on user interaction"
        },
        {
          "lineNum": 41,
          "content": "        emblaApi.scrollTo(index);"
        },
        {
          "lineNum": 42,
          "content": "      }"
        },
        {
          "lineNum": 43,
          "content": "    },"
        },
        {
          "lineNum": 44,
          "content": "    [emblaApi]"
        },
        {
          "lineNum": 45,
          "content": "  );"
        },
        {
          "lineNum": 46,
          "content": ""
        },
        {
          "lineNum": 47,
          "content": "  const onSelect = useCallback(() => {"
        },
        {
          "lineNum": 48,
          "content": "    if (!emblaApi) return;"
        },
        {
          "lineNum": 49,
          "content": "    setSelectedIndex(emblaApi.selectedScrollSnap());"
        },
        {
          "lineNum": 50,
          "content": "  }, [emblaApi]);"
        },
        {
          "lineNum": 51,
          "content": ""
        },
        {
          "lineNum": 52,
          "content": "  // Store onSelect in ref so effect only depends on emblaApi"
        },
        {
          "lineNum": 53,
          "content": "  const onSelectRef = useRef(onSelect);"
        },
        {
          "lineNum": 54,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 55,
          "content": "    onSelectRef.current = onSelect;"
        },
        {
          "lineNum": 56,
          "content": "  }, [onSelect]);"
        },
        {
          "lineNum": 57,
          "content": ""
        },
        {
          "lineNum": 58,
          "content": "  // Track handlers for each emblaApi instance using a Map"
        },
        {
          "lineNum": 59,
          "content": "  const handlersMapRef = useRef<Map<typeof emblaApi, {"
        },
        {
          "lineNum": 60,
          "content": "    onSelect: () => void;"
        },
        {
          "lineNum": 61,
          "content": "    handleReInit: () => void;"
        },
        {
          "lineNum": 62,
          "content": "    handlePointerDown: () => void;"
        },
        {
          "lineNum": 63,
          "content": "  }>>(new Map());"
        },
        {
          "lineNum": 64,
          "content": ""
        },
        {
          "lineNum": 65,
          "content": "  // Track previous emblaApi for cleanup"
        },
        {
          "lineNum": 66,
          "content": "  const prevEmblaApiRef = useRef<typeof emblaApi>(null);"
        },
        {
          "lineNum": 67,
          "content": ""
        },
        {
          "lineNum": 68,
          "content": "  // Cleanup previous emblaApi when it changes (runs synchronously before main effect)"
        },
        {
          "lineNum": 69,
          "content": "  useLayoutEffect(() => {"
        },
        {
          "lineNum": 70,
          "content": "    const prevApi = prevEmblaApiRef.current;"
        },
        {
          "lineNum": 71,
          "content": "    if (prevApi && prevApi !== emblaApi) {"
        },
        {
          "lineNum": 72,
          "content": "      const prevHandlers = handlersMapRef.current.get(prevApi);"
        },
        {
          "lineNum": 73,
          "content": "      if (prevHandlers) {"
        }
      ]
    },
    {
      "functionName": "anonymous arrow function",
      "file": "src/sections/AgencyLogos/index.tsx",
      "line": 219,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 219,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 219,
        "end": 219
      },
      "functionCode": [
        {
          "lineNum": 219,
          "content": "              onClick={() => scrollTo(index)}"
        }
      ]
    },
    {
      "functionName": "handleContactClick",
      "file": "src/sections/Hero/index.tsx",
      "line": 9,
      "actualComplexity": 4,
      "calculatedTotal": 1,
      "difference": -3,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 9,
        "end": 24
      },
      "functionCode": [
        {
          "lineNum": 9,
          "content": "  const handleContactClick = (e: React.MouseEvent<HTMLAnchorElement>) => {"
        },
        {
          "lineNum": 10,
          "content": "    // If we're already on the home page with #contact, manually scroll"
        },
        {
          "lineNum": 11,
          "content": "    if (location.pathname === \"/\" && location.hash === \"#contact\") {"
        },
        {
          "lineNum": 12,
          "content": "      e.preventDefault();"
        },
        {
          "lineNum": 13,
          "content": "      const element = document.querySelector(\"#contact\");"
        },
        {
          "lineNum": 14,
          "content": "      if (element) {"
        },
        {
          "lineNum": 15,
          "content": "        const headerOffset = 110;"
        },
        {
          "lineNum": 16,
          "content": "        const elementPosition = element.getBoundingClientRect().top;"
        },
        {
          "lineNum": 17,
          "content": "        const offsetPosition = elementPosition + window.scrollY - headerOffset;"
        },
        {
          "lineNum": 18,
          "content": "        window.scrollTo({"
        },
        {
          "lineNum": 19,
          "content": "          top: offsetPosition,"
        },
        {
          "lineNum": 20,
          "content": "          behavior: \"smooth\","
        },
        {
          "lineNum": 21,
          "content": "        });"
        },
        {
          "lineNum": 22,
          "content": "      }"
        },
        {
          "lineNum": 23,
          "content": "    }"
        },
        {
          "lineNum": 24,
          "content": "  };"
        }
      ]
    },
    {
      "functionName": "TopBanner",
      "file": "src/sections/TopBanner/index.tsx",
      "line": 5,
      "actualComplexity": 3,
      "calculatedTotal": 1,
      "difference": -2,
      "category": "(none)",
      "decisionPoints": [],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 5,
        "end": 71
      },
      "functionCode": [
        {
          "lineNum": 5,
          "content": "export function TopBanner() {"
        },
        {
          "lineNum": 6,
          "content": "  const [isVisible, setIsVisible] = useState(true);   // user can close permanently"
        },
        {
          "lineNum": 7,
          "content": "  const [isHidden, setIsHidden] = useState(false);    // scroll-controlled (slides away)"
        },
        {
          "lineNum": 8,
          "content": "  const bannerRef = useRef<HTMLDivElement>(null);"
        },
        {
          "lineNum": 9,
          "content": ""
        },
        {
          "lineNum": 10,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 11,
          "content": "    const root = document.documentElement;"
        },
        {
          "lineNum": 12,
          "content": ""
        },
        {
          "lineNum": 13,
          "content": "    const updateVars = () => {"
        },
        {
          "lineNum": 14,
          "content": "      // If user closed it OR it's scrolled-hidden, treat banner height as 0"
        },
        {
          "lineNum": 15,
          "content": "      const h ="
        },
        {
          "lineNum": 16,
          "content": "        isVisible && !isHidden && bannerRef.current"
        },
        {
          "lineNum": 17,
          "content": "          ? bannerRef.current.offsetHeight"
        },
        {
          "lineNum": 18,
          "content": "          : 0;"
        },
        {
          "lineNum": 19,
          "content": ""
        },
        {
          "lineNum": 20,
          "content": "      root.style.setProperty(\"--banner-height\", `${h}px`);"
        },
        {
          "lineNum": 21,
          "content": "    };"
        },
        {
          "lineNum": 22,
          "content": ""
        },
        {
          "lineNum": 23,
          "content": "    updateVars();"
        },
        {
          "lineNum": 24,
          "content": "    window.addEventListener(\"resize\", updateVars);"
        },
        {
          "lineNum": 25,
          "content": "    return () => window.removeEventListener(\"resize\", updateVars);"
        },
        {
          "lineNum": 26,
          "content": "  }, [isVisible, isHidden]);"
        },
        {
          "lineNum": 27,
          "content": ""
        },
        {
          "lineNum": 28,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 29,
          "content": "    let ticking = false;"
        },
        {
          "lineNum": 30,
          "content": ""
        },
        {
          "lineNum": 31,
          "content": "    const onScroll = () => {"
        },
        {
          "lineNum": 32,
          "content": "      if (ticking) return;"
        },
        {
          "lineNum": 33,
          "content": "      ticking = true;"
        },
        {
          "lineNum": 34,
          "content": ""
        },
        {
          "lineNum": 35,
          "content": "      window.requestAnimationFrame(() => {"
        },
        {
          "lineNum": 36,
          "content": "        const y = window.scrollY || document.documentElement.scrollTop;"
        },
        {
          "lineNum": 37,
          "content": "        // Tune this threshold to match main site (try 10, 20, 40)"
        },
        {
          "lineNum": 38,
          "content": "        setIsHidden(y > 20);"
        },
        {
          "lineNum": 39,
          "content": "        ticking = false;"
        },
        {
          "lineNum": 40,
          "content": "      });"
        },
        {
          "lineNum": 41,
          "content": "    };"
        },
        {
          "lineNum": 42,
          "content": ""
        },
        {
          "lineNum": 43,
          "content": "    onScroll(); // initialize"
        },
        {
          "lineNum": 44,
          "content": "    window.addEventListener(\"scroll\", onScroll, { passive: true });"
        },
        {
          "lineNum": 45,
          "content": "    return () => window.removeEventListener(\"scroll\", onScroll);"
        },
        {
          "lineNum": 46,
          "content": "  }, []);"
        },
        {
          "lineNum": 47,
          "content": ""
        },
        {
          "lineNum": 48,
          "content": "  // If user closed it, remove entirely (like now)"
        },
        {
          "lineNum": 49,
          "content": "  if (!isVisible) return null;"
        },
        {
          "lineNum": 50,
          "content": ""
        },
        {
          "lineNum": 51,
          "content": "  return ("
        },
        {
          "lineNum": 52,
          "content": "    <div"
        },
        {
          "lineNum": 53,
          "content": "      ref={bannerRef}"
        },
        {
          "lineNum": 54,
          "content": "      className={`${styles.banner} ${isHidden ? styles.hidden : \"\"}`}"
        }
      ]
    },
    {
      "functionName": "onScroll (arrow function)",
      "file": "src/sections/TopBanner/index.tsx",
      "line": 63,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 63,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 63,
        "end": 63
      },
      "functionCode": [
        {
          "lineNum": 63,
          "content": "          onClick={() => setIsVisible(false)}"
        }
      ]
    },
    {
      "functionName": "getGrayscaleImageUrl",
      "file": "src/utils/imageGrayscale.ts",
      "line": 11,
      "actualComplexity": 4,
      "calculatedTotal": 2,
      "difference": -2,
      "category": "under-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 12,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 1,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 11,
        "end": 28
      },
      "functionCode": [
        {
          "lineNum": 11,
          "content": "export function getGrayscaleImageUrl(imageUrl: string, isNoirTheme: boolean): string {"
        },
        {
          "lineNum": 12,
          "content": "  if (!isNoirTheme) {"
        },
        {
          "lineNum": 13,
          "content": "    return imageUrl;"
        },
        {
          "lineNum": 14,
          "content": "  }"
        },
        {
          "lineNum": 15,
          "content": ""
        },
        {
          "lineNum": 16,
          "content": "  // Check if it's a picsum.photos URL"
        },
        {
          "lineNum": 17,
          "content": "  if (imageUrl.includes('picsum.photos')) {"
        },
        {
          "lineNum": 18,
          "content": "    // Check if URL already has query parameters"
        },
        {
          "lineNum": 19,
          "content": "    const hasQuery = imageUrl.includes('?');"
        },
        {
          "lineNum": 20,
          "content": "    const separator = hasQuery ? '&' : '?';"
        },
        {
          "lineNum": 21,
          "content": "    "
        },
        {
          "lineNum": 22,
          "content": "    // Add grayscale parameter"
        },
        {
          "lineNum": 23,
          "content": "    return `${imageUrl}${separator}grayscale`;"
        },
        {
          "lineNum": 24,
          "content": "  }"
        },
        {
          "lineNum": 25,
          "content": ""
        },
        {
          "lineNum": 26,
          "content": "  // For non-picsum URLs, return as-is (will use CSS filter instead)"
        },
        {
          "lineNum": 27,
          "content": "  return imageUrl;"
        },
        {
          "lineNum": 28,
          "content": "}"
        }
      ]
    },
    {
      "functionName": "useImagePreload (useEffect callback)",
      "file": "src/hooks/useImagePreload.ts",
      "line": 13,
      "actualComplexity": 3,
      "calculatedTotal": 5,
      "difference": 2,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "if",
          "line": 14,
          "name": "if statement"
        },
        {
          "type": "default parameter",
          "line": 28,
          "name": "default parameter"
        },
        {
          "type": "default parameter",
          "line": 31,
          "name": "default parameter"
        },
        {
          "type": "if",
          "line": 38,
          "name": "if statement"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 2,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 2
      },
      "boundary": {
        "start": 13,
        "end": 47
      },
      "functionCode": [
        {
          "lineNum": 13,
          "content": "  useEffect(() => {"
        },
        {
          "lineNum": 14,
          "content": "    if (!imageUrl) return;"
        },
        {
          "lineNum": 15,
          "content": ""
        },
        {
          "lineNum": 16,
          "content": "    const processedUrl = getGrayscaleImageUrl(imageUrl, isNoirTheme);"
        },
        {
          "lineNum": 17,
          "content": ""
        },
        {
          "lineNum": 18,
          "content": "    // Create preload link for faster LCP"
        },
        {
          "lineNum": 19,
          "content": "    const link = document.createElement(\"link\");"
        },
        {
          "lineNum": 20,
          "content": "    link.setAttribute(\"rel\", \"preload\");"
        },
        {
          "lineNum": 21,
          "content": "    link.setAttribute(\"as\", \"image\");"
        },
        {
          "lineNum": 22,
          "content": "    link.setAttribute(\"href\", processedUrl);"
        },
        {
          "lineNum": 23,
          "content": "    link.setAttribute(\"fetchPriority\", \"high\");"
        },
        {
          "lineNum": 24,
          "content": "    document.head.appendChild(link);"
        },
        {
          "lineNum": 25,
          "content": ""
        },
        {
          "lineNum": 26,
          "content": "    // Detect when the image is loaded"
        },
        {
          "lineNum": 27,
          "content": "    const img = new Image();"
        },
        {
          "lineNum": 28,
          "content": "    img.onload = () => {"
        },
        {
          "lineNum": 29,
          "content": "      setImageLoaded(true);"
        },
        {
          "lineNum": 30,
          "content": "    };"
        },
        {
          "lineNum": 31,
          "content": "    img.onerror = () => {"
        },
        {
          "lineNum": 32,
          "content": "      // Show content even if image fails to load"
        },
        {
          "lineNum": 33,
          "content": "      setImageLoaded(true);"
        },
        {
          "lineNum": 34,
          "content": "    };"
        },
        {
          "lineNum": 35,
          "content": "    img.src = processedUrl;"
        },
        {
          "lineNum": 36,
          "content": "    "
        },
        {
          "lineNum": 37,
          "content": "    // Handle already cached images"
        },
        {
          "lineNum": 38,
          "content": "    if (img.complete) {"
        },
        {
          "lineNum": 39,
          "content": "      setTimeout(() => setImageLoaded(true), 0);"
        },
        {
          "lineNum": 40,
          "content": "    }"
        },
        {
          "lineNum": 41,
          "content": ""
        },
        {
          "lineNum": 42,
          "content": "    return () => {"
        },
        {
          "lineNum": 43,
          "content": "      if (document.head.contains(link)) {"
        },
        {
          "lineNum": 44,
          "content": "        document.head.removeChild(link);"
        },
        {
          "lineNum": 45,
          "content": "      }"
        },
        {
          "lineNum": 46,
          "content": "    };"
        },
        {
          "lineNum": 47,
          "content": "  }, [imageUrl, isNoirTheme]);"
        }
      ]
    },
    {
      "functionName": "CustomerSpotlight",
      "file": "src/sections/CustomerSpotlight/index.tsx",
      "line": 34,
      "actualComplexity": 3,
      "calculatedTotal": 4,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 55,
          "name": "ternary operator"
        },
        {
          "type": "||",
          "line": 58,
          "name": "logical OR"
        },
        {
          "type": "default parameter",
          "line": 80,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 1,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 34,
        "end": 109
      },
      "functionCode": [
        {
          "lineNum": 34,
          "content": "export function CustomerSpotlight() {"
        },
        {
          "lineNum": 35,
          "content": ""
        },
        {
          "lineNum": 36,
          "content": "  const [selectedIndex, setSelectedIndex] = useState(0);"
        },
        {
          "lineNum": 37,
          "content": ""
        },
        {
          "lineNum": 38,
          "content": "  const scrollPrev = () => {"
        },
        {
          "lineNum": 39,
          "content": "    setSelectedIndex((prev) => (prev === 0 ? testimonials.length - 1 : prev - 1));"
        },
        {
          "lineNum": 40,
          "content": "  };"
        },
        {
          "lineNum": 41,
          "content": ""
        },
        {
          "lineNum": 42,
          "content": "  const scrollNext = () => {"
        },
        {
          "lineNum": 43,
          "content": "    setSelectedIndex((prev) => (prev === testimonials.length - 1 ? 0 : prev + 1));"
        },
        {
          "lineNum": 44,
          "content": "  };"
        },
        {
          "lineNum": 45,
          "content": ""
        },
        {
          "lineNum": 46,
          "content": "  const currentTestimonial = testimonials[selectedIndex];"
        },
        {
          "lineNum": 47,
          "content": ""
        },
        {
          "lineNum": 48,
          "content": "  return ("
        },
        {
          "lineNum": 49,
          "content": "    <Section variant=\"alt\">"
        },
        {
          "lineNum": 50,
          "content": "      <Container className={styles.referencesContainer}>"
        },
        {
          "lineNum": 51,
          "content": "        <h2 className={styles.heading}>References</h2>"
        },
        {
          "lineNum": 52,
          "content": "        <div className={styles.wrapper}>"
        },
        {
          "lineNum": 53,
          "content": "          <div className={styles.image}>"
        },
        {
          "lineNum": 54,
          "content": "            <div className={styles.imageContainer}>"
        },
        {
          "lineNum": 55,
          "content": "              {currentTestimonial.image ? ("
        },
        {
          "lineNum": 56,
          "content": "                <img"
        },
        {
          "lineNum": 57,
          "content": "                  src={currentTestimonial.image}"
        },
        {
          "lineNum": 58,
          "content": "                  alt={currentTestimonial.alt || currentTestimonial.author}"
        },
        {
          "lineNum": 59,
          "content": "                  className={styles.imageContent}"
        },
        {
          "lineNum": 60,
          "content": "                />"
        },
        {
          "lineNum": 61,
          "content": "              ) : ("
        },
        {
          "lineNum": 62,
          "content": "                <span className={styles.placeholderText}>Image</span>"
        },
        {
          "lineNum": 63,
          "content": "              )}"
        },
        {
          "lineNum": 64,
          "content": "            </div>"
        },
        {
          "lineNum": 65,
          "content": "          </div>"
        },
        {
          "lineNum": 66,
          "content": "          <div className={styles.quote}>"
        },
        {
          "lineNum": 67,
          "content": "            <div className={styles.quoteContent}>"
        },
        {
          "lineNum": 68,
          "content": "              <blockquote className={styles.blockquote}>"
        },
        {
          "lineNum": 69,
          "content": "                \"{currentTestimonial.quote}\""
        },
        {
          "lineNum": 70,
          "content": "              </blockquote>"
        },
        {
          "lineNum": 71,
          "content": "              <div className={styles.quoteAuthor}>"
        },
        {
          "lineNum": 72,
          "content": "                <div className={styles.authorName}>{currentTestimonial.author}</div>"
        },
        {
          "lineNum": 73,
          "content": "                <div className={styles.authorRole}>{currentTestimonial.role}</div>"
        },
        {
          "lineNum": 74,
          "content": "              </div>"
        },
        {
          "lineNum": 75,
          "content": "            </div>"
        },
        {
          "lineNum": 76,
          "content": "            <div className={styles.controls}>"
        },
        {
          "lineNum": 77,
          "content": "              <button"
        },
        {
          "lineNum": 78,
          "content": "                className={styles.arrow}"
        },
        {
          "lineNum": 79,
          "content": "                onClick={scrollPrev}"
        },
        {
          "lineNum": 80,
          "content": "                aria-label=\"Previous testimonial\""
        },
        {
          "lineNum": 81,
          "content": "              >"
        },
        {
          "lineNum": 82,
          "content": "                <ChevronLeft size={24} />"
        },
        {
          "lineNum": 83,
          "content": "              </button>"
        }
      ]
    },
    {
      "functionName": "scrollNext (map callback)",
      "file": "src/sections/CustomerSpotlight/index.tsx",
      "line": 85,
      "actualComplexity": 2,
      "calculatedTotal": 3,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 89,
          "name": "ternary operator"
        },
        {
          "type": "default parameter",
          "line": 92,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 85,
        "end": 94
      },
      "functionCode": [
        {
          "lineNum": 85,
          "content": "                {testimonials.map((_, index) => ("
        },
        {
          "lineNum": 86,
          "content": "                  <button"
        },
        {
          "lineNum": 87,
          "content": "                    key={index}"
        },
        {
          "lineNum": 88,
          "content": "                    className={`${styles.dot} ${"
        },
        {
          "lineNum": 89,
          "content": "                      index === selectedIndex ? styles.dotActive : \"\""
        },
        {
          "lineNum": 90,
          "content": "                    }`}"
        },
        {
          "lineNum": 91,
          "content": "                    onClick={() => setSelectedIndex(index)}"
        },
        {
          "lineNum": 92,
          "content": "                    aria-label={`Go to testimonial ${index + 1}`}"
        },
        {
          "lineNum": 93,
          "content": "                  />"
        },
        {
          "lineNum": 94,
          "content": "                ))}"
        }
      ]
    },
    {
      "functionName": "scrollNext (arrow function)",
      "file": "src/sections/CustomerSpotlight/index.tsx",
      "line": 91,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 91,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 91,
        "end": 91
      },
      "functionCode": [
        {
          "lineNum": 91,
          "content": "                    onClick={() => setSelectedIndex(index)}"
        }
      ]
    },
    {
      "functionName": "CampaignBanner",
      "file": "src/sections/CampaignBanner/index.tsx",
      "line": 8,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "ternary",
          "line": 22,
          "name": "ternary operator"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 1,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 0
      },
      "boundary": {
        "start": 8,
        "end": 59
      },
      "functionCode": [
        {
          "lineNum": 8,
          "content": "export function CampaignBanner() {"
        },
        {
          "lineNum": 9,
          "content": "  const { currentPresetId } = useTheme();"
        },
        {
          "lineNum": 10,
          "content": "  const isNoirTheme = currentPresetId === 'noir';"
        },
        {
          "lineNum": 11,
          "content": ""
        },
        {
          "lineNum": 12,
          "content": "  return ("
        },
        {
          "lineNum": 13,
          "content": "    <Section className={styles.banner} id=\"contact\">"
        },
        {
          "lineNum": 14,
          "content": "      <Container className={styles.contactContainer}>"
        },
        {
          "lineNum": 15,
          "content": "        <div className={styles.wrapper}>"
        },
        {
          "lineNum": 16,
          "content": "          <div className={styles.content}>"
        },
        {
          "lineNum": 17,
          "content": "            <h2 className={styles.heading}>"
        },
        {
          "lineNum": 18,
          "content": "              Let's{\" \"}"
        },
        {
          "lineNum": 19,
          "content": "              <span className={styles.accent}>Connect</span>"
        },
        {
          "lineNum": 20,
          "content": "            </h2>"
        },
        {
          "lineNum": 21,
          "content": "            <p className={styles.text}>"
        },
        {
          "lineNum": 22,
          "content": "              Interested in working together? Reach out via{\" \"}"
        },
        {
          "lineNum": 23,
          "content": "              <a href=\"mailto:JHJonathanHammond@gmail.com\" className={styles.link}>"
        },
        {
          "lineNum": 24,
          "content": "                email"
        },
        {
          "lineNum": 25,
          "content": "              </a>"
        },
        {
          "lineNum": 26,
          "content": "              {\" \"}or connect on{\" \"}"
        },
        {
          "lineNum": 27,
          "content": "              <a "
        },
        {
          "lineNum": 28,
          "content": "                href=\"https://www.linkedin.com/in/jonamichahammo\" "
        },
        {
          "lineNum": 29,
          "content": "                target=\"_blank\" "
        },
        {
          "lineNum": 30,
          "content": "                rel=\"noopener noreferrer\""
        },
        {
          "lineNum": 31,
          "content": "                className={styles.link}"
        },
        {
          "lineNum": 32,
          "content": "              >"
        },
        {
          "lineNum": 33,
          "content": "                LinkedIn"
        },
        {
          "lineNum": 34,
          "content": "              </a>"
        },
        {
          "lineNum": 35,
          "content": "              {\" \"}to discuss opportunities."
        },
        {
          "lineNum": 36,
          "content": "            </p>"
        },
        {
          "lineNum": 37,
          "content": "            <div className={styles.cta}>"
        },
        {
          "lineNum": 38,
          "content": "              <a "
        },
        {
          "lineNum": 39,
          "content": "                href=\"/JonathanHammondResume.pdf\" "
        },
        {
          "lineNum": 40,
          "content": "                download=\"Jonathan-Hammond-Resume.pdf\""
        },
        {
          "lineNum": 41,
          "content": "                className={buttonStyles.primary}"
        },
        {
          "lineNum": 42,
          "content": "              >"
        },
        {
          "lineNum": 43,
          "content": "                Download Resume"
        },
        {
          "lineNum": 44,
          "content": "              </a>"
        },
        {
          "lineNum": 45,
          "content": "            </div>"
        },
        {
          "lineNum": 46,
          "content": "          </div>"
        },
        {
          "lineNum": 47,
          "content": "          <div className={styles.image}>"
        },
        {
          "lineNum": 48,
          "content": "            <img "
        },
        {
          "lineNum": 49,
          "content": "              src=\"/Jonathan_Hammond.webp\" "
        },
        {
          "lineNum": 50,
          "content": "              alt=\"Jonathan Hammond\""
        },
        {
          "lineNum": 51,
          "content": "              className={styles.imageContent}"
        },
        {
          "lineNum": 52,
          "content": "              style={{ filter: getGrayscaleFilter(isNoirTheme) }}"
        },
        {
          "lineNum": 53,
          "content": "            />"
        },
        {
          "lineNum": 54,
          "content": "          </div>"
        },
        {
          "lineNum": 55,
          "content": "        </div>"
        },
        {
          "lineNum": 56,
          "content": "      </Container>"
        },
        {
          "lineNum": 57,
          "content": "    </Section>"
        }
      ]
    },
    {
      "functionName": "Footer (map callback)",
      "file": "src/sections/Footer/index.tsx",
      "line": 52,
      "actualComplexity": 1,
      "calculatedTotal": 2,
      "difference": 1,
      "category": "over-counting",
      "decisionPoints": [
        {
          "type": "default parameter",
          "line": 59,
          "name": "default parameter"
        }
      ],
      "breakdown": {
        "base": 1,
        "if": 0,
        "else if": 0,
        "for": 0,
        "for...of": 0,
        "for...in": 0,
        "while": 0,
        "do...while": 0,
        "switch": 0,
        "case": 0,
        "catch": 0,
        "ternary": 0,
        "&&": 0,
        "||": 0,
        "??": 0,
        "?.": 0,
        "default parameter": 1
      },
      "boundary": {
        "start": 52,
        "end": 65
      },
      "functionCode": [
        {
          "lineNum": 52,
          "content": "              {socialLinks.map((social) => {"
        },
        {
          "lineNum": 53,
          "content": "                const Icon = social.icon;"
        },
        {
          "lineNum": 54,
          "content": "                return ("
        },
        {
          "lineNum": 55,
          "content": "                  <a"
        },
        {
          "lineNum": 56,
          "content": "                    key={social.label}"
        },
        {
          "lineNum": 57,
          "content": "                    href={social.href}"
        },
        {
          "lineNum": 58,
          "content": "                    className={styles.socialLink}"
        },
        {
          "lineNum": 59,
          "content": "                    aria-label={social.label}"
        },
        {
          "lineNum": 60,
          "content": "                    target=\"_blank\""
        },
        {
          "lineNum": 61,
          "content": "                  >"
        },
        {
          "lineNum": 62,
          "content": "                    <Icon size={20} />"
        },
        {
          "lineNum": 63,
          "content": "                  </a>"
        },
        {
          "lineNum": 64,
          "content": "                );"
        },
        {
          "lineNum": 65,
          "content": "              })}"
        }
      ]
    }
  ]
}