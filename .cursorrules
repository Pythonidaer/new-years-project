# Cursor Content Rules ‚Äî Interview Blog Articles

## üöÄ Quick Start for Agents

**When starting a new session, read these files in order to understand the project:**

### 1. Current Status & TODOs
- **`README.md`** - **START HERE** - Contains current TODO list and next priority (currently: Mobile Responsiveness)
  - See section "üéØ Next Priority: Mobile Responsiveness" for current focus
  - See "TODO: Lighthouse 100 Score & SEO Optimization" for remaining tasks
  - Review "Notes" section for important implementation details

### 2. Project Overview
- **`docs/PROJECT_SUMMARY.md`** - Complete project overview, architecture, and current state
  - Project structure and tech stack
  - Key features (Content System, Blog System, Theming System)
  - Important files to read for each feature
  - Current status and next steps

### 3. Documentation Index
- **`docs/README.md`** - Documentation structure and quick links
  - Organized by topic (blog, theming, workflow, reference)
  - Quick links to relevant documentation

### 4. Key Documentation by Task Type

**For Blog Work:**
- `docs/blog/BLOG_POST_INTEGRATION.md` - Blog post integration process

**For Theming Work:**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** for theme picker
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Package extraction plan
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan

**For Workflow/Methodology:**
- `docs/workflow/SCALABLE_CURSOR_WEBSITE_REBUILD_WORKFLOW.md` - General methodology

**For Historical Reference:**
- `docs/reference/` - Mark43 reference materials (historical)

### 5. Code Structure Understanding
- **`src/design/tokens.css`** - CSS variables and design tokens
- **`src/context/ThemeContext.tsx`** - Theme state management
- **`src/components/ThemePicker/`** - Theme picker UI component
- **`src/data/blog/`** - Blog post data and utilities
- **`src/pages/`** - Page components (Home, Blog, BlogPost)
- **`src/sections/`** - Reusable section components

### 5a. Path Aliases
- **Path alias `@/` is configured** - Maps to `src/` directory
- **Configuration:**
  - `vite.config.ts` - Vite resolve alias: `"@": path.resolve(__dirname, "./src")`
  - `tsconfig.app.json` - TypeScript path mapping: `"@/*": ["./src/*"]`
- **Usage:** Always use `@/` prefix for imports from `src/` directory
  - ‚úÖ `import { Header } from "@/sections/Header";`
  - ‚úÖ `import { useTheme } from "@/context/useTheme";`
  - ‚ùå `import { Header } from "../sections/Header";` (avoid relative paths)
- **Benefits:** Cleaner imports, easier refactoring, better maintainability

### 6. Mobile Responsiveness - ‚úÖ COMPLETED
**Status:** Mobile responsiveness has been fully implemented across all components.

**Completed Work:**
- All core layout components (Header, Hero, Footer)
- Complete blog system (BlogPost, Blog listing, FeaturedBlogPost, BlogFilters, BlogGrid, LatestBlogs)
- Responsive breakpoints implemented: Mobile (< 768px), Tablet (768px-990px), iPad Landscape (768px-1024px), Desktop (> 990px)
- Accessibility improvements (touch targets, descriptive links, form attributes)
- SEO improvements (valid robots.txt)

**See `README.md` section "‚úÖ Mobile Responsiveness - COMPLETED" for full details.**

---

These rules enforce writing quality, structure, and consistency for interview-style blog articles rendered via `html-react-parser`.

---

## Purpose

Ensure all generated or edited articles:
- Are junior-friendly but senior-accurate
- Are paragraph-driven (Mark43-style), not list-heavy
- Encode semantic intent using HTML + CSS classes
- End with a clear interview-ready takeaway

These rules apply to **all blog article content files**.

---

## Required Structure Rules

### 1. Introduction
- The article **must explicitly state the interview question** in the introduction.
- This must appear within the first 1‚Äì2 paragraphs.
- Example phrasing:
  > ‚ÄúThis article answers the interview question: ‚Äò‚Ä¶‚Äô‚Äù

---

### 2. Semantic HTML Classes (Mandatory)

Articles must use the following semantic wrappers:

- `<div class="explanation">`  
  For conceptual explanations and reasoning.

- `<div class="example">`  
  For concrete scenarios, real-world illustrations, or case studies.

- `<div class="takeaway">`  
  For actionable guidance, heuristics, or interview-ready summaries.

**Rules:**
- Every article must contain **at least one** `.explanation` block.
- Every article must contain **at least one** `.example` block.
- Every article must end with a `.takeaway` block.

---

### 3. Code Examples
- All code must be wrapped in:
  ```html
  <pre><code>...</code></pre>
  ```
- Do not embed code inline inside paragraphs.

---

## Writing Style Rules

### 4. Paragraph-First Writing
- Default to paragraphs, not lists.
- Paragraphs should be **2‚Äì4 sentences**.
- Lists are allowed **only** for:
  - Step-by-step procedures
  - Checklists
  - Explicit enumerations after explanation

**Anti-pattern:** Long explanatory bullet lists.

---

### 5. Bold Lead-Ins
- Key ideas should begin with a **bold lead-in sentence fragment**, followed by explanation.
- Example:
  ```html
  <p><strong>Stability matters more than reuse.</strong> A shared component that changes weekly...</p>
  ```

---

### 6. Junior-Friendly Clarity
When reviewing content:
- If a term is introduced, ensure it is explained plainly.
- If a decision is described, ensure the *reasoning* is stated.
- If tradeoffs exist, they must be acknowledged.

---

## Required Closing Section

### 7. Final Takeaway (Hard Requirement)
The article **must end** with a `<div class="takeaway">` that includes:
- A plain-language summary of the core idea
- A concise, interview-ready answer (1‚Äì2 short paragraphs max)

This section should answer:
> ‚ÄúWhat would you actually say out loud in an interview?‚Äù

---

## Editing & Review Rules

### 8. Editor Pass Expectations
When editing or refactoring articles:
- Convert list-heavy explanations into paragraphs
- Preserve meaning; do not introduce new concepts
- Improve clarity where ideas are implied but not stated
- Ensure all structural requirements still pass

---

## Non-Goals
These rules do NOT require:
- Mentioning SEO, Google, or ranking considerations
- Marketing language or calls-to-action
- Overly verbose explanations

Focus on clarity, correctness, and usefulness.

---

## Blog Post Integration

### 9. Standard Blog Integration Command

When the user says "Please add/integrate/incorporate the <filename>.json file" or similar, follow this process:

**Reference**: Full details in `docs/blog/BLOG_POST_INTEGRATION.md`

**Quick Integration Steps**:

1. **Update JSON file format** (if needed):
   - Ensure `id` is a **number** (must be unique across ALL posts - check existing IDs)
   - Convert `date` to human-readable format: "January 11, 2026" (not ISO format like "2026-01-11")
   - Update `image` to: `https://picsum.photos/367/197?random=N` (find next available number)
   - Add `slug` field if missing (generate from title if needed)
   - Format `tags` as Title Case with spaces (e.g., "React", "Component Design", "State Management & Data Flow")
   - Ensure `category` matches existing category from `src/data/blog/categories.ts`
   - Verify `content` is HTML (not Markdown) - all code must be in `<pre><code>...</code></pre>` blocks
   - Format code blocks with proper line breaks for readability

2. **Find next unique ID**:
   - Check all existing blog post IDs: `grep '"id":' src/data/blog/*.json`
   - Assign next sequential number (e.g., if highest is 7, use 8)
   - **Critical**: IDs must be unique across ALL posts (not just within topics) because `getRelatedPosts()` uses IDs

3. **Find next available image random number**:
   - Check existing random numbers: `grep -h "random=" src/data/blog/*.json | grep -o "random=[0-9]*" | sort -t= -k2 -n | tail -1`
   - Use next number (e.g., if highest is 44, use 45)

4. **Register in blog system**:
   - **File**: `src/data/blog/index.ts`
     - Add import statement at top: `import <camelCaseName>Posts from "./<filename>.json";`
     - Add entry to `blogPostsByTopic` object: `<topic_id>: <camelCaseName>Posts as BlogPosts,`
   - **File**: `src/content/topics.ts`
     - Add topic entry to `topics` array with `id` (filename without .json), `label` (human-readable title), and `description`

5. **Verify**:
   - Run `npm test -- --run`
   - Check for linting errors: `read_lints` on modified files
   - Verify unique ID assignment
   - Ensure all tests pass

**Command Examples** (all trigger the same process):
- "Please add the interview_example.json file"
- "Please incorporate interview_example.json"
- "Please integrate @interview_example.json"
- "Please add @src/data/blog/interview_example.json"

**Important Notes**:
- Blog post IDs must be **unique across all posts** (not just within topics) because `getRelatedPosts()` uses `findIndex((p) => p.id === currentPostId)` to locate posts
- Tags should match existing category names where possible (e.g., use "Frontend Architecture" if the post is about frontend architecture)
- Category must exist in `ALL_CATEGORIES` array in `src/data/blog/categories.ts` (or you must add it there first)
- Topic ID in `topics.ts` must match the filename (without `.json` extension)

---

## Theming System

### 10. Theming System Architecture

**Current Stage: Stage 2 Complete**

The theming system has been fully implemented through Stage 2:

- ‚úÖ **Stage 1 Complete**: All colors migrated to semantic CSS variables
- ‚úÖ **Stage 2 Complete**: ThemePicker component with presets and contrast checking
- üîÑ **Stage 3 Pending**: Advanced color picker integration

**Core Architecture:**

The theming system follows a clear separation of concerns:

1. **CSS Variables Layer** (`src/design/tokens.css`):
   - **Themeable colors** are defined on `#root` (e.g., `--color-bg`, `--color-primary`)
   - **Non-themeable tokens** (fonts, spacing, layout) are defined on `:root`
   - All components use `var(--color-*)` tokens instead of hardcoded colors
   - This allows React to dynamically update colors by modifying CSS variables on `#root`

2. **React State Layer** (`src/context/ThemeContext.tsx`):
   - Manages theme state as a JavaScript object (`Theme` type)
   - Provides `ThemeProvider` that wraps the app
   - `useTheme()` hook for accessing/updating theme
   - Applies theme changes to DOM by updating CSS variables on `#root` element
   - Persists theme to `localStorage` for no-flicker loading
   - Handles preset management (built-in + custom presets)

3. **UI Layer** (`src/components/ThemePicker/`):
   - Floating color picker UI (fixed position, bottom-left corner)
   - Allows users to customize colors in real-time
   - Saves/loads presets, exports/imports themes
   - Uses fixed colors for UI (theme-agnostic) so picker remains visible regardless of theme

4. **Utility Layer** (`src/utils/contrast.ts`):
   - WCAG contrast checking utilities
   - Validates text readability on backgrounds and gradients
   - Provides warnings for accessibility issues

**Key Files:**
- `src/design/tokens.css` - CSS variable definitions (themeable on `#root`, non-themeable on `:root`)
- `src/context/ThemeContext.tsx` - Theme state management, presets, persistence, DOM application
- `src/context/themeData.ts` - Re-exports types and themes from `themes/` directory
- `src/context/themes/` - Individual theme files (each theme in its own file, e.g., `default.ts`, `noir.ts`, `king.ts`)
  - `themes/types.ts` - Theme and Preset type definitions
  - `themes/index.ts` - Exports all built-in presets array
- `src/components/ThemePicker/` - Floating color picker UI with preset management (positioned bottom-left)
- `src/utils/contrast.ts` - WCAG contrast checking with detailed warnings
- `src/design/theming-goals.md` - Original theming architecture documentation

**Documentation Structure:**

Documentation is organized into subfolders:
- `docs/blog/` - Blog post integration guides
- `docs/theming/` - Theme picker and theming system documentation
- `docs/workflow/` - Workflow and methodology guides
- `docs/reference/` - Historical reference documentation
- `docs/PROJECT_SUMMARY.md` - Main project overview (root level)

**Documentation Files (READ THESE FOR THEME PICKER WORK):**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** - Complete guide for React package usage, customization, token creation, preset management, accessibility checks, image-based themes, and adapting to existing codebases
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan for npm package with TDD approach, phases, and architecture decisions
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for adding theme picker to new projects
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan for npm package extraction
- `src/design/theming-goals.md` - Architecture overview and design decisions

**When working on theme picker related tasks, ALWAYS read:**
1. `docs/theming/REACT_PACKAGE_GUIDE.md` - For user-facing features, customization, and API usage
2. `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - For extraction/package development work
3. `docs/theming/COLOR_PICKER_INTEGRATION.md` - For integration patterns and file structure

**Built-in Preset Themes (31 total):**
1. **Default** - Dark theme with blue accents (Midnight Blue)
2. **Cedar Oak** - Warm earth tones (browns/greens)
3. **Mark43** - Original Mark43-inspired theme (orange/blue) - *Commented out in UI but code preserved*
4. **Sage Green** - Light theme with green tones
5. **Crimson Flame** - Fire fighter inspired (red/orange)
6. **Vapor Wave** - 80s aesthetic (magenta/cyan)
7. **Gothic** - Dark theme with purple accents
8. **Horror** - Dark theme with red accents
9. **Pride** - Progress Pride Flag colors (rainbow stripes: red, orange, yellow, green, blue, purple; chevron: white, pink, light blue, brown, black)
10. **Yuko** - Vibrant kaiju-inspired theme (hot pink, neon yellow, crimson red, light blue)
11. **Hokusai** - Japanese woodblock print inspired (deep blue-teal, pale yellow-orange, burnt orange, light blue accents)
12. **Noname** - Vibrant digital art inspired (light purple, bright blue, green, yellow, red accents)
13. **Sadikovic** - Boxing arena inspired (dark blue-black, electric blue, purple, gold, red accents)
14. **AFB** - Boxing gloves inspired (royal blue, metallic purple, gold, crimson red accents)
15. **TUF** - Athletic gear inspired (royal blue tank top, black base, red accents, silver/metallic grey gloves)
16. **Royboy** - Warm sepia portrait inspired (dark brown-black, muted reddish-brown, warm cream/blonde)
17. **Dalmatian** - High contrast black and white with warm blonde accents (diagonal split hoodie, minimalist)
18. **Querida** - Modern gray base with vibrant lime green accents (modern building, clean aesthetic)
19. **Ris** - Bright yellow background with light blue, red, purple, and brown accents (whimsical cartoon art)
20. **Gulu** - Warm beagle-inspired theme (cream, tan, rich browns)
21. **Maxine** - Vibrant portrait-inspired theme (platinum blonde, purple, orange, pink)
22. **Sunrise** - Coastal sunrise theme (light blue, teal, orange, purple)
23. **Noir** - Classic black and white photography theme (grayscale)
24. **Hatsune** - Anime-inspired theme (bright teal, light blue, purple, pink)
25. **Scotland** - Rugged valley landscape theme (pale grey-blue sky, dark blue-grey river, golden brown heather, muted greens)
26. **PBR** - Pabst Blue Ribbon inspired theme (PBR blue #003DA5, red accents, light blue-tinted backgrounds, dark blue footer)
27. **Reeses** - Reese's Pieces candy inspired theme (bright orange #B34D00, yellow accents, light orange-tinted backgrounds, dark brown-black footer)
28. **Fallout** - Vault-Tec inspired theme (Vault-Tec blue #0066CC, gold accents #FFD700, light blue-tinted backgrounds, dark blue footer, purple-blue hero radial #434fad)
29. **Berg√©** - Vibrant fashion-inspired theme (forest green #1F7A1F primary, hot pink #FF1493 accents, light green-tinted backgrounds, dark green footer)
30. **Pink** - Soft pink gerbera daisy inspired theme (soft peach-pink background, vibrant rose accents #ff66a3, WCAG AA compliant)
31. **King** - Dignified portrait-inspired theme (dark brown/charcoal base, warm golden-brown accents, muted green secondary elements, white/cream text) - *Built-in theme with audio easter egg (I Have a Dream speech)*

**Important Theme Picker Rules:**
- **Built-in themes MUST NOT have trash/delete icons** - Only custom user-created presets can be deleted
- Built-in themes include: Default, Cedar Oak, Sage Green, Crimson Flame, Vapor Wave, Gothic, Horror, Pride, Yuko, Hokusai, Noname, Sadikovic, AFB, TUF, Royboy, Dalmatian, Querida, Ris, Gulu, Maxine, Sunrise, Noir, Hatsune, Trippie, Scotland, PBR, Reeses, Fallout, Berg√©, Pink, Dayglow, and **King**
- When adding new built-in themes, ensure they are added to the `isBuiltIn` check in `ThemePicker.tsx` (around line 406)
- Do NOT add delete/trash functionality for built-in themes unless explicitly requested by the user
- The trash icon is conditionally rendered based on `!isBuiltIn` check - built-in themes should never show delete buttons

**Important Implementation Notes:**
- **CSS variables are the styling layer**: All color styling happens via CSS variables (`var(--color-*)`)
- **React manages the data**: ThemeContext holds theme state and applies it to DOM
- **Semantic tokens**: Colors use semantic names (e.g., `--color-primary`, `--color-text`) not raw colors
- **Themeable colors on `#root`**: Allows nested theme overrides in the future
- **Non-themeable tokens on `:root`**: Fonts, spacing, and layout values are static
- All preset themes meet WCAG AA contrast requirements (‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic) so it doesn't change with theme
- ThemePicker positioned bottom-left corner (matching Mark43 design)
- Contrast checker validates text on gradients by checking both start and end colors
- Semi-transparent colors are blended with backgrounds before contrast calculation
- Custom presets are stored in separate `localStorage` key from active theme
- Theme is applied to DOM before React render to prevent flicker on page load

### 11. Theme Picker Documentation & npm Package

**For Theme Picker Development & Customization:**

When working on theme picker features, customization, or npm package extraction:

1. **Read Primary Documentation:**
   - `docs/theming/REACT_PACKAGE_GUIDE.md` - Complete user guide covering:
     - Installation & setup
     - Token creation & theme definition
     - Adding theme presets
     - Adding accessibility checks (with code examples)
     - Creating themes from images
     - Customization (button colors, categories, CSS variables)
     - Adapting to existing codebases
     - Cursor rules & AI prompts for users
     - API reference
     - Troubleshooting

2. **For npm Package Extraction:**
   - `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan with:
     - TDD approach (tests in `src/__tests__/`)
     - Phase-by-phase extraction plan
     - Package architecture
     - Testing strategy
     - Publishing checklist

3. **For Integration:**
   - `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for:
     - File structure
     - Dependencies
     - Step-by-step integration
     - API reference

**Key Principles:**
- All theme colors must be on `#root` (not `:root`)
- CSS variables follow pattern: `--color-{kebab-case-key}`
- Always check contrast ratios (WCAG AA: ‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic)
- Tests should be written first (TDD approach)
- Documentation should be comprehensive and user-friendly

**When Adding New Features:**
- Update relevant documentation files
- Add tests following TDD approach
- Update API reference if needed
- Provide examples in documentation

---

## Summary Checklist

Before merging or publishing:
- [ ] Interview question stated in intro
- [ ] `.explanation` present
- [ ] `.example` present
- [ ] Final `.takeaway` present and interview-ready
- [ ] Paragraph-driven, list-light writing
- [ ] Valid HTML compatible with `html-react-parser`

---

## Website Domain Information

**Production Domain:** `floatingpla.net`
- All meta tags, sitemaps, and external URLs should use `https://floatingpla.net`
- When updating robots.txt, Open Graph tags, or canonical URLs, use this domain
- The website is deployed at: `https://floatingpla.net`

---

## Agent Session Checklist

**Before starting work, ensure you have:**
- [ ] Read `README.md` to understand current TODOs and priorities
- [ ] Read `docs/PROJECT_SUMMARY.md` for project overview
- [ ] Reviewed `docs/README.md` for documentation structure
- [ ] Understood the current priority (check README.md "üéØ Next Priority" section)
- [ ] Located relevant documentation for your task type
- [ ] Familiarized yourself with key code files mentioned in PROJECT_SUMMARY.md

---

## Test Driven Development (TDD) Environment

### 12. TDD Workflow & Testing Standards

**This project operates in a Test Driven Development (TDD) environment.**

**Core TDD Principles:**
- **Write tests first** - Tests should be written before or alongside implementation
- **Red-Green-Refactor cycle** - Write failing test ‚Üí Make it pass ‚Üí Refactor
- **Test coverage is important** - Aim for high coverage of business logic and critical paths
- **Tests document behavior** - Tests serve as living documentation of expected behavior

**Testing Stack:**
- **Vitest** - Test runner and framework
- **@testing-library/react** - React component testing utilities
- **@testing-library/jest-dom** - Custom DOM matchers
- **@vitest/coverage-v8** - Code coverage reporting (v8 provider)

**Test Commands:**
- `npm test` - Run tests in watch mode (development)
- `npm run test:coverage:all` - Run tests once with coverage report
- `npm run test:ui` - Open Vitest UI for interactive test running and debugging

**Useful Terminal Commands for Testing & Coverage Analysis:**

1. **Run specific test file:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run
   ```

2. **Check coverage for specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx
   ```

3. **Get test summary (pass/fail counts):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -E "(Test Files|Tests )" | head -2
   ```

4. **Get coverage stats for specific source file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | head -1
   ```

5. **View detailed test output (last 30 lines):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | tail -30
   ```

6. **Check for specific test failures:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -A 10 "FAIL"
   ```

7. **Get coverage percentage for a specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | grep -oE "[0-9]+\.[0-9]+"
   ```

8. **Check linting errors for test file:**
   ```bash
   # Use read_lints tool in Cursor, or:
   npm run lint -- src/__tests__/ComponentName.test.tsx
   ```

**Identifying Coverage Gaps:**
- After running coverage, check `coverage/index.html` for line-by-line coverage
- Look for red/yellow lines indicating uncovered code
- Use the grep commands above to quickly check coverage percentages
- Focus on uncovered branches (if statements, ternary operators, etc.)

**When Writing or Modifying Code:**

1. **Before implementing a feature:**
   - Consider what tests are needed
   - Write test cases that describe the expected behavior
   - Run tests to see them fail (Red)

2. **During implementation:**
   - Write minimal code to make tests pass (Green)
   - Refactor while keeping tests green (Refactor)

3. **After implementation:**
   - **ALWAYS run test coverage** to verify coverage:
     ```bash
     npm run test:coverage
     ```
   - Review coverage report in `coverage/index.html` or terminal output
   - Identify any uncovered code paths
   - Add tests for edge cases and error handling

**Code Coverage Standards:**

**Minimum Coverage Targets:**
- **Statements: 80%**
- **Lines: 80%**
- **Functions: 80%**
- **Branches: 65%**

These thresholds represent a practical, professional baseline for a frontend React project.

**Coverage Guidelines:**
- Coverage should reflect **meaningful, behavior-focused tests**‚Äînot artificially inflated metrics
- **Prioritize testing:**
  - Core utilities and business logic
  - Critical user flows
  - Error and edge cases that can realistically occur
- **Avoid writing contrived tests** solely to reach 100% coverage

**Acceptable Exceptions:**
Some branches may remain uncovered when they:
- Represent defensive guards unlikely to occur in real usage
- Depend on browser or third-party behaviors difficult to simulate
- Require unnatural hacks that reduce test quality

**Target Philosophy:**
- **Utilities:** strive for 90%+ coverage
- **Components:** 75‚Äì85% is acceptable
- **Branch coverage** will naturally be lower than statements

**When Reviewing Code:**
- New features should maintain or improve existing coverage
- Large logic changes must include updated tests
- Refactors should not reduce overall coverage without justification

**Exclude from coverage** (already configured in `vitest.config.ts`):
- Type definition files (`src/**/types.ts`)
- Pure constant data files (`src/data/blog/categories.ts`)
- Context instance files (`src/context/ThemeContextInstance.ts`)
- Test files themselves
- Setup files

**Test File Structure:**
- Test files live in `src/__tests__/` directory
- Naming: `ComponentName.test.tsx` or `feature.test.tsx`
- Use `describe` blocks to group related tests
- Use `it` or `test` for individual test cases
- Follow AAA pattern: Arrange, Act, Assert

**Example Test Structure:**
```typescript
import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import { Component } from "@/components/Component";
import { ThemeProvider } from "@/context/ThemeContext";

describe("Component", () => {
  it("renders correctly", () => {
    render(
      <ThemeProvider>
        <Component />
      </ThemeProvider>
    );
    expect(screen.getByText("Expected Text")).toBeTruthy();
  });
});
```

**When AI Assistant Should Suggest Running Coverage:**

The AI assistant should **automatically suggest running test coverage** in these scenarios:

1. **After creating new test files:**
   - "I've created tests for ComponentX. Run `npm run test:coverage` to see the coverage improvement."

2. **After implementing new features:**
   - "Feature implementation complete. Run `npm run test:coverage` to verify test coverage."

3. **After modifying existing code:**
   - "Code changes complete. Run `npm run test:coverage` to ensure existing tests still pass and coverage is maintained."

4. **When user asks about test coverage:**
   - "To check current test coverage, run: `npm run test:coverage`"
   - "The coverage report will show in the terminal and be saved to `coverage/index.html` for detailed analysis."

5. **When identifying low coverage areas:**
   - "I notice ComponentX has low coverage. After adding tests, run `npm run test:coverage` to verify improvement."

**Coverage Report Locations:**
- **Terminal output** - Summary statistics (statements, branches, functions, lines)
- **`coverage/index.html`** - Interactive HTML report with line-by-line coverage
- **`coverage/coverage-summary.json`** - Machine-readable JSON report

**Best Practices:**
- Run `npm run test:coverage` **before committing** significant changes
- Review coverage reports to identify untested code paths
- Focus on testing **user-facing behavior** rather than implementation details
- Use `ThemeProvider` wrapper in tests for components that use `useTheme()`
- Use `BrowserRouter` wrapper for components that use React Router
- Mock external dependencies (APIs, browser APIs like Audio) appropriately
- Clean up after tests (clear localStorage, restore mocks, etc.)

**Common Testing Patterns & Gotchas:**

1. **Testing Components with `useParams` (React Router):**
   - **Problem:** `useParams()` returns `undefined` if the component isn't rendered within a matching route
   - **Solution:** Wrap component in `<Routes><Route>` to match the route pattern:
     ```tsx
     render(
       <MemoryRouter initialEntries={['/resources/blog/my-slug']}>
         <Routes>
           <Route path="/resources/blog/:slug" element={<BlogPost />} />
         </Routes>
       </MemoryRouter>
     );
     ```
   - **Don't:** Just use `<MemoryRouter>` with the path - this won't match the route and `useParams` will be undefined

2. **Testing Components with ThemeProvider:**
   - **Problem:** `currentPresetId` is derived by matching the saved theme object to presets, not read directly from localStorage
   - **Solution:** Set the actual theme object in localStorage (not just a preset ID):
     ```tsx
     import { builtInPresets } from "@/context/themeData";
     const noirPreset = builtInPresets.find(p => p.id === 'noir');
     if (noirPreset) {
       localStorage.setItem('user-theme', JSON.stringify(noirPreset.theme));
     }
     ```
   - **Why:** ThemeProvider matches the saved theme to find the preset ID, so the theme object must match exactly
   - **Note:** `themeData.ts` now re-exports from `themes/` directory. Each theme is in its own file (e.g., `themes/noir.ts`, `themes/default.ts`)

3. **Mocking Browser APIs (Image, Audio, etc.):**
   - **Problem:** Constructor mocks need to return the same object instance for property assignments to work
   - **Solution:** Use a consistent mock object with getter/setter for properties:
     ```tsx
     let mockImage = {
       onload: null,
       onerror: null,
       get src() { return this._src || ''; },
       set src(value) { this._src = value; },
       complete: false,
     };
     global.Image = vi.fn(() => mockImage) as any;
     ```
   - **Why:** When code does `img.src = url`, it needs to set the property on the returned mock object

4. **Debugging Test Failures - Systematic Approach:**
   - **Start with simpler tests:** Fix basic rendering tests before complex hook/effect tests
   - **Identify root cause:** If many tests fail, find the common issue (e.g., route matching, context initialization)
   - **Verify assumptions:** Check if mocks are set up correctly, if context providers are initialized, if routes match
   - **Use human-in-the-loop:** After 2-3 attempts, ask for guidance rather than continuing to guess

5. **Testing Custom Hooks:**
   - **Isolation tests:** Test hooks with `renderHook` to verify they work in isolation
   - **Component integration:** If hook works in isolation but fails in component, check:
     - Is the hook receiving correct parameters?
     - Is the component's context/provider initialized?
     - Are effects running (may need `act()` or `waitFor()`)?
   - **Common issue:** Hook works standalone but fails in component = context/initialization problem, not hook problem

**Test Coverage Configuration:**
- Coverage provider: `v8` (fast, modern)
- Reporters: `text` (terminal), `json` (machine-readable), `html` (browsable)
- Coverage includes: `src/**/*.{ts,tsx}`
- Exclusions configured in `vitest.config.ts` for non-testable files

---

### 13. Cyclomatic Complexity Standards

**This project uses JS-Friendly Cyclomatic Complexity rules for JavaScript/TypeScript.**

**You are writing JavaScript/TypeScript using JS-friendly cyclomatic complexity rules. Follow these rules strictly:**

**Base Rule:**
- Every function starts with complexity = 1 (base).
- Base values do NOT stack across function boundaries.

**What Increases Complexity (+1 each):**

**Control Flow:**
- `if`, `else if`
- `for`, `for...of`, `for...in`, `while`, `do...while`
- `switch` ‚Üí each `case` / `default`
- `catch`
- Early return guarded by a condition

**Expressions:**
- Ternary operator: `cond ? a : b`
- Logical operators: `&&`, `||`
- Nullish coalescing: `??`
- Optional chaining: `?.`

**Function Parameters:**
- **Default parameters** - ESLint's `classic` variant counts default parameter values as decision points

**Important:** Each logical operator counts independently:
- `a && b && c` ‚Üí +2 complexity (two `&&` operators)
- `a || b` ‚Üí +1 complexity (one `||` operator)
- `a ?? b ?? c` ‚Üí +2 complexity (two `??` operators)
- `a?.b?.c` ‚Üí +2 complexity (two `?.` operators)

**What Does NOT Increase Complexity:**
- Function calls (including `setTimeout`, `requestAnimationFrame`)
- `async` / `await`
- JSX rendering (without conditionals)
- `.map`, `.forEach`, `.filter` (unless they contain decision points)
- Boolean comparisons passed as arguments: `setState(x > 10)` does NOT add complexity
- Sequential statements (assignments, calls, logging, object/array literals, destructuring, arithmetic/string ops, unconditional return)
- TypeScript types/interfaces/generics (compile-time only)
- Hook calls (only callbacks count)
- Literals, destructuring; arithmetic, strings
- Property access; method calls
- Unconditional `return`

**Per-Function Accounting (Critical Rule):**
- Cyclomatic complexity is **per function**, not per file or component.
- **Correct:** Parent function: 3, Nested callback: 4 (each measured independently)
- **Incorrect:** Parent function: 7 ‚ùå (do NOT auto-sum children)
- If rollups are shown, they must be explicitly labeled (e.g., "tree sum").

**JSX-Specific Rules:**
- JSX volume ‚â† complexity
- Skeleton / layout components are usually complexity = 1
- Inline callbacks (`onClick={() => ...}`) are:
  - complexity = 1 (base)
  - optional to include in reports

**Complexity Targets:**
- **Default:** Keep cyclomatic complexity ‚â§ 10 per function/method
- **UI Components, Hooks, Event Handlers:** Prefer ‚â§ 6
- **Exceptions:** Any function expected to exceed 10 must be intentionally refactored or split unless there is a strong reason (documented inline)

**Design Constraints to Keep Complexity Low:**

When generating code, prefer patterns that naturally reduce branching:

1. **Early returns / guard clauses** to avoid deep nesting
2. **Extract helpers** when logic branches: move a branchy block into a named function with a focused purpose
3. **Replace long if/else chains** with:
   - A lookup map/object of handlers (`const handlers = { ... }`)
   - Strategy functions
   - Small pure functions that return a value (then render/use the value)
4. **Split "do everything" functions** into:
   - Parsing/validation (pure)
   - Decision logic (pure)
   - Side effects (isolated)
5. **Keep callbacks small** (`map`, `filter`, `reduce`, event handlers); if branching appears, extract to a named function
6. **Prefer data-driven configuration** over branching (e.g., arrays of rules, tables of constants)
7. **Prefer early returns and simple expressions** to reduce decision density
8. **Avoid chaining multiple `&&` / `||`** in a single expression when clarity suffers
9. **When complexity exceeds 5, consider refactoring** into smaller functions

**Testing / Maintainability Requirements:**
- Keep decision logic in pure functions (easy to unit test)
- Components should mostly compose UI; non-trivial conditional logic belongs in helpers/hooks
- Limit nesting depth (aim ‚â§ 2) and avoid combining multiple concerns in one function

**Recommended Report Fields (for clarity):**
For each function:
- **CC (self)** ‚Äì complexity of the function itself
- **Decision sources** ‚Äì `if`, `?:`, `&&`, `||`
- **Nested max CC** ‚Äì highest child complexity (optional)
- **Tree sum CC** ‚Äì sum of all nested functions (optional, custom)

**ESLint Enforcement:**
- Complexity rule is configured in `eslint.config.js` (threshold and variant; report generator reads threshold via `scripts/get-complexity-threshold.js`)
- File length: `max-lines: ["warn", { max: 1000, skipBlankLines: true, skipComments: true }]` in `eslint.config.js`
- Use `npm run lint` to check for complexity and file length violations
- Use `npm run lint:complexity` to generate the HTML complexity report (AST parser, threshold from config)
- Use `npm run lint:complexity:all` to generate report with all functions visible by default
- Use `npm run lint:complexity:all-columns` to show all breakdown columns by default
- Use `npm run lint:complexity:hide-table` to hide the breakdown table by default
- Use `npm run lint:complexity:export` to also write TXT/MD exports to `complexity/reports/` (or `package.json` ‚Üí `complexityReport.exportDir`)

**Complexity Report (scripts):**

A custom report generator (`scripts/generate-complexity-report.js`) produces an HTML report (Vitest-style UI, folder navigation, per-file breakdown tables, decision-point breakdown). Output: `complexity/index.html`, `complexity/<folder_path>/index.html`, `complexity/<folder_path>/<file>.html`. Intermediate ESLint output: `scripts/complexity-report.json` (gitignored). For how it works, module layout, completed work, and TODOs, see **`scripts/README.md`**.

**File Length Guidelines:**
- **Target:** Keep files under **1,000 lines** (reduces AI confusion and improves maintainability).
- **ESLint:** `max-lines` in `eslint.config.js` (1000, skip blank lines and comments). When splitting, use TDD and keep module interfaces focused.
- **When exceeding limit:** Inform the user, suggest splitting into smaller modules, and propose a refactoring plan if significantly over. Current files over the guideline are noted in `scripts/README.md`.

---

### 14. Frontend Performance Monitoring + Jank Prevention (Vite + React + TS)

## Goal
Prevent "choppy" UI (dropped frames) during scroll, hover, and drawer transitions by enforcing GPU-friendly animations, avoiding layout thrash, and using a repeatable profiling workflow.

---

## Core Principles (non-negotiable)
1) **Prefer compositor-friendly animations**
   - Only animate: `transform`, `opacity`
   - Avoid animating layout/paint-heavy properties: `top`, `left`, `right`, `bottom`, `width`, `height`, `margin`, `padding`, `border-width`, `box-shadow`, `filter`, `backdrop-filter`, large-area `background-color`

2) **No layout thrash**
   - Avoid frequent layout reads/writes in the same tick (e.g. `getBoundingClientRect()` + style/state updates repeatedly)
   - Avoid running expensive work directly in `scroll`/`mousemove` handlers
   - If measuring layout is required, do it **once per frame** via `requestAnimationFrame` and batch writes

3) **Avoid repaint storms**
   - Do not animate `box-shadow` on large containers/cards during scroll/hover
   - Prefer pseudo-element overlays (`::before`/`::after`) with `opacity` + `transform` to simulate borders/glow/shadow

4) **Minimize global invalidations**
   - Be cautious when updating many CSS variables on `:root` (can trigger broad style recalculation and repaint)
   - If theme switching is expensive, reduce the number of vars changed, scope variables to a container, or defer non-critical updates

---

## Animation Patterns (use these)
### Drawer / Slide panels
- Animate the panel using `transform: translateX(...)` (or `translateY`)
- Use `opacity` for fade
- Optional: `will-change: transform, opacity` only on the animated element (remove when idle if possible)

### Hover effects for cards/buttons
- Use `transform: translateY(-Npx)` or `scale()`
- Simulate border/shadow via pseudo-element:
  - `::before` absolute positioned overlay
  - animate overlay `opacity` (and optionally `transform: scale()`)

### Smooth scroll / click-to-scroll
- Avoid doing repeated layout reads during scroll
- Prefer CSS `scroll-margin-top` for fixed headers
- Compute target offset once, then scroll once

---

## Anti-Patterns (do NOT generate)
- Animations that change `top`/`height`/`width` during scroll or hover
- Animating `box-shadow` on large surfaces or repeated elements
- Animating `background-color` on large containers during scroll
- Scroll handlers that call `setState` every event without throttling/rAF
- Tight loops that measure DOM and write styles repeatedly

---

## Performance Debugging Workflow (required when UI feels choppy)
### 1) Validate in Production Preview
- Always reproduce in:
  - `npm run build && npm run preview`
- Dev mode can mislead due to extra checks and tooling overhead.

### 2) Chrome Performance Trace (primary tool for jank)
When recording:
- Record **one interaction only** (e.g. one drawer open, one scroll segment)
- Stop within ~2 seconds

When analyzing:
- Zoom into the red/dropped frame region
- Check **Animations track**:
  - If you see `top`, `height`, `box-shadow`, `background-color` ‚Üí treat as a rendering pipeline issue and refactor CSS.
- Use **Bottom-up** to identify whether time is dominated by:
  - Scripting (JS)
  - Rendering (Layout / Recalculate Style)
  - Painting (Paint)
  - Compositing (Composite Layers)

### 3) React Profiler (secondary tool)
If scripting dominates:
- Use React Profiler to find unexpected rerender cascades
- Watch for context provider rerenders and unstable context values
- Prefer splitting contexts (State vs Actions) and memoizing provider values

---

## Implementation Requirements for Changes
When refactoring for performance:
1) Replace layout/paint animations with `transform/opacity` equivalents.
2) Add a short comment near the animation CSS stating:
   - "Perf: transform/opacity only to avoid layout/paint on scroll/hover."
3) If adding DOM measurement:
   - Use `requestAnimationFrame` batching or `ResizeObserver`/`IntersectionObserver`.
4) If adding event listeners:
   - Ensure cleanup
   - Avoid high-frequency state updates
   - Use passive scroll listeners where appropriate

---

## Definition of Done (for UI changes)
Before merging any UI animation or interaction change:
- [ ] Verified in `build + preview`
- [ ] Performance trace shows no sustained dropped frames during the interaction
- [ ] Animations track contains only `transform`/`opacity` for the interaction
- [ ] No new scroll/mousemove handlers doing per-event heavy work
- [ ] If context changed, confirm no large rerender cascade in React Profiler

---

## If Unsure
If you are about to animate anything other than `transform`/`opacity`, stop and propose a compositor-friendly alternative using pseudo-elements or transforms.

---

## Airbnb JavaScript Style Guide (ES2015+)

**Style baseline:** [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) (full README). *A mostly reasonable approach to JavaScript.*

**Note:** The guide assumes Babel (e.g. [babel-preset-airbnb](https://www.npmjs.com/package/babel-preset-airbnb)) and shims/polyfills (e.g. [airbnb-browser-shims](https://www.npmjs.com/package/airbnb-browser-shims)) where needed. Other guides: [React](https://github.com/airbnb/javascript/tree/master/react), [CSS-in-JavaScript](https://github.com/airbnb/javascript/tree/master/css-in-javascript), [CSS & Sass](https://github.com/airbnb/css).

This repo is an NPM package using ESM import/export. Module behavior is controlled via `package.json` and enforced via ESLint.

### 0) Hard constraints
- Use ESM syntax only: `import` / `export`. Do not use `require` / `module.exports`.
- Assume `package.json` defines module format (e.g., `"type": "module"`) and entrypoints.
- Assume ESLint is authoritative. Do not fight lint rules; refactor to satisfy them.
- Do not use TC39 proposals that have not reached stage 3.

### 1) Package.json / public API rules (NPM package conventions)
- Treat `src/index.js` (or declared entry) as the public surface.
- Prefer exporting from a single entry (barrel) unless instructed otherwise.
- Avoid deep imports as part of public API unless explicitly designed:
  - Consumers should import from the package root, not internal paths.
- Keep exports stable: avoid breaking changes to names/paths without intent.

### 2) Layering / boundaries (lint-enforced architecture)
- Keep dependencies directional and predictable.
- If the repo uses folder boundaries, follow them strictly (no cross-layer imports).
- If `import/no-restricted-paths` zones exist, comply:
  - Do not import across disallowed directories.
  - If code needs shared logic, move it into an allowed shared module.

### 3) Types (primitives vs complex)
- **Primitives** (value copy): string, number, boolean, null, undefined, symbol, bigint.
- **Complex** (reference): object, array, function. Mutating a copy mutates the original.
- Use Symbols/BigInt only in environments that support them natively (no faithful polyfill).

### 4) References & variables
- Use `const` by default; use `let` only when reassignment is required. Never use `var`.
- One `const` or `let` per declaration (no chained declarations).
- Group all `const`s then all `let`s. Define variables where they are used (block scope).
- Do not chain assignments (`let a = b = c = 1` creates globals). No `++`/`--`; use `+= 1`/`-= 1`.
- No unused variables. No linebreak before/after `=` in assignment (use parens if line too long).
- Variables, classes, and functions should be defined before use (no-use-before-define).

### 5) Objects
- Use object literals `{}`; never `new Object()`.
- Use computed property names for dynamic keys: `{ [getKey('enabled')]: true }`.
- Prefer property shorthand `{ a }` and method shorthand `{ foo() {} }`. Group shorthand first.
- Only quote keys that require it (invalid identifiers).
- Never call `obj.hasOwnProperty()` directly: use `Object.hasOwn(obj, key)` (ES2022+) or `Object.prototype.hasOwnProperty.call(obj, key)`.
- Prefer object spread/rest over `Object.assign` for shallow copies and omission.

### 6) Arrays
- Use array literals `[]`; never `new Array()`. Use `.push()` to append.
- Prefer spread for copying: `const copy = [...arr]`. For iterables, spread or `Array.from`; for array-like, `Array.from(arrLike)`.
- Prefer `Array.from(iterable, mapFn)` when mapping while converting (avoids intermediate array).
- Array method callbacks must return when needed (e.g. `reduce`/`filter`); omit return only for single-expression no-side-effect (per arrow implicit-return rules).
- Multiline arrays: one item per line with trailing comma; no bracket newline for single-line.

### 7) Destructuring
- Prefer object destructuring for multiple properties; array destructuring when appropriate.
- Prefer object destructuring for multiple return values (not array) so callers can select by name and order can change.
- Destructure function params only when it improves clarity of the API.

### 8) Strings
- Use single quotes `'...'`. Use template literals for interpolation: `` `Hello ${name}` `` (no space inside `${}`).
- Avoid long concatenation across lines; keep long strings on one line or use templates.
- Never use `eval()`. Do not unnecessarily escape characters.

### 9) Functions
- Prefer named function expressions over declarations (hoisting clarity). IIFEs: wrap in parens `(function () { }());`
- Never declare a function inside a non-function block (if/while etc); assign to a variable instead.
- Never name a parameter `arguments`. Use rest `...args` instead of `arguments`.
- Default params: prefer over mutating params; no side effects in default; put defaults last.
- Never use the `Function` constructor. Spacing: space before `()` in declarations/calls.
- Never mutate or reassign parameters. Prefer spread `...` over `apply` for variadic calls.
- Multiline signatures/invocations: one argument per line, trailing comma.

### 10) Arrow functions
- Prefer arrows for inline callbacks. Always use parentheses around arguments: `(x) => x * x`.
- Implicit return only for single expression without side effects; otherwise use braces and `return`.
- Multi-line expression: wrap in parens. Avoid `=>` next to `<=`/`>=` (wrap ternary in parens or use block).

### 11) Classes & constructors
- Use `class`; use `extends` for inheritance. Prefer small focused classes.
- Methods can return `this` for chaining. Custom `toString()` is OK; avoid empty or delegating-only constructors.
- No duplicate class members. Instance methods should use `this` or be static.

### 12) Imports / exports (ESM best practices)
- Use `import` / `export` only. No wildcard imports. Do not export directly from an import (re-export from local).
- One import per path (combine default and named). Do not export mutable bindings (use `const`).
- Single-export modules: prefer default export. Put all imports at top; multiline imports with trailing comma.
- No Webpack loader syntax in import. **Import extensions:** Omit `.js`/`.jsx` in import paths only when a build step (Babel, Webpack, Vite, etc.) resolves extensionless paths. When running scripts directly with Node ESM (`node script.js`), include the `.js` extension‚ÄîNode‚Äôs ESM loader does not auto-resolve and will throw `ERR_MODULE_NOT_FOUND` without it.
- Import order: builtins ‚Üí external deps ‚Üí internal ‚Üí relative. No circular deps; no import from dist.

### 13) Iterators and generators
- Prefer `map`/`filter`/`reduce`/`some`/`every`/`find`/`findIndex`; use `Object.keys`/`Object.values`/`Object.entries` for objects. Avoid `for-in`/`for-of` for simple iteration.
- Do not use generators unless necessary (transpilation/portability). If used: `function* foo()` spacing.

### 14) Properties
- Use dot notation when possible; bracket notation when property name is variable.
- Use exponentiation operator `**` instead of `Math.pow`.

### 15) Comparisons & equality
- Use `===` / `!==` only. Use shortcuts for booleans; explicit comparisons for strings and numbers (e.g. `name !== ''`, `length > 0`).
- In `switch`, use braces for `case`/`default` that contain lexical declarations (`let`/`const`/`function`/`class`). Include `default` or document omission.
- Avoid nested ternaries; avoid unneeded ternaries (e.g. `a || b` instead of `a ? a : b`, `a ?? b` for null/undefined).
- When mixing operators, use parentheses to clarify (except `+`, `-`, `**`). Prefer `??` for null/undefined defaults.

### 16) Blocks & control flow
- Use braces for all multiline blocks. Put `else` on same line as closing `}`. Omit `else` after `return`.
- Long conditions: put logical operator at start of continuation line. Do not use selection operators (`&&`/`||`) in place of control statements.

### 17) Comments
- Multiline: `/** ... */`. Single-line: `//` on new line above subject; space after `//`.
- Comment the "why", not the "what". Use `// FIXME:` for problems, `// TODO:` for solutions; keep actionable.

### 18) Whitespace & formatting
- 2-space indentation. Semicolons required. Trailing commas in multiline literals/imports/params. No leading commas.
- Space before leading brace; space after control keywords; space around infix operators. Newline at end of file.
- Long chains: leading dot, one call per line. Blank line after blocks; no padding inside blocks; no multiple blank lines.
- No space inside parens/brackets; space inside braces: `{ a, b }`. Max line length (e.g. 100); no trailing spaces.

### 19) Type casting & coercion
- Coerce at the start of the statement. Use `String()`/`Number()`/`Boolean()` (not `new String`/`new Number`/`new Boolean`). Use `parseInt(s, 10)` with radix. Prefer `!!` or `Boolean()` for booleans.

### 20) Naming
- Avoid single-letter names; be descriptive. camelCase for objects, functions, instances; PascalCase for constructors/classes.
- No leading or trailing underscores. Use arrow functions or `Function#bind` instead of saving `this` as `self`/`that`.
- Default export: filename should match export name (PascalCase for class/singleton, camelCase for function).
- Acronyms: all uppercase or all lowercase. Optionally UPPERCASE for exported immutable constants only.

### 21) Accessors
- Do not use getters/setters; use `getVal()`/`setVal()`. For booleans use `isVal()` or `hasVal()`.

### 22) Standard library
- Use `Number.isNaN` and `Number.isFinite` instead of global `isNaN`/`isFinite`.

### 23) Testing
- Write tests. Prefer many small pure functions; minimize mutations. Be cautious with stubs/mocks. When fixing a bug, add a regression test.

### 24) When uncertain
- Choose the option that reduces surprise for a new reader.
- If a choice impacts the public API, module entrypoints, or export names, ask first.