# Cursor Content Rules ‚Äî Interview Blog Articles

## üöÄ Quick Start for Agents

**When starting a new session, read these files in order to understand the project:**

### 1. Current Status & TODOs
- **`README.md`** - **START HERE** - Contains current TODO list and next priority (currently: Mobile Responsiveness)
  - See section "üéØ Next Priority: Mobile Responsiveness" for current focus
  - See "TODO: Lighthouse 100 Score & SEO Optimization" for remaining tasks
  - Review "Notes" section for important implementation details

### 2. Project Overview
- **`docs/PROJECT_SUMMARY.md`** - Complete project overview, architecture, and current state
  - Project structure and tech stack
  - Key features (Content System, Blog System, Theming System)
  - Important files to read for each feature
  - Current status and next steps

### 3. Documentation Index
- **`docs/README.md`** - Documentation structure and quick links
  - Organized by topic (blog, theming, workflow, reference)
  - Quick links to relevant documentation

### 4. Key Documentation by Task Type

**For Blog Work:**
- `docs/blog/BLOG_POST_INTEGRATION.md` - Blog post integration process

**For Theming Work:**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** for theme picker
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Package extraction plan
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan

**For Workflow/Methodology:**
- `docs/workflow/SCALABLE_CURSOR_WEBSITE_REBUILD_WORKFLOW.md` - General methodology

**For Historical Reference:**
- `docs/reference/` - Mark43 reference materials (historical)

### 5. Code Structure Understanding
- **`src/design/tokens.css`** - CSS variables and design tokens
- **`src/context/ThemeContext.tsx`** - Theme state management
- **`src/components/ThemePicker/`** - Theme picker UI component
- **`src/data/blog/`** - Blog post data and utilities
- **`src/pages/`** - Page components (Home, Blog, BlogPost)
- **`src/sections/`** - Reusable section components

### 5a. Path Aliases
- **Path alias `@/` is configured** - Maps to `src/` directory
- **Configuration:**
  - `vite.config.ts` - Vite resolve alias: `"@": path.resolve(__dirname, "./src")`
  - `tsconfig.app.json` - TypeScript path mapping: `"@/*": ["./src/*"]`
- **Usage:** Always use `@/` prefix for imports from `src/` directory
  - ‚úÖ `import { Header } from "@/sections/Header";`
  - ‚úÖ `import { useTheme } from "@/context/useTheme";`
  - ‚ùå `import { Header } from "../sections/Header";` (avoid relative paths)
- **Benefits:** Cleaner imports, easier refactoring, better maintainability

### 6. Mobile Responsiveness - ‚úÖ COMPLETED
**Status:** Mobile responsiveness has been fully implemented across all components.

**Completed Work:**
- All core layout components (Header, Hero, Footer)
- Complete blog system (BlogPost, Blog listing, FeaturedBlogPost, BlogFilters, BlogGrid, LatestBlogs/LatestNews)
- Responsive breakpoints implemented: Mobile (< 768px), Tablet (768px-990px), iPad Landscape (768px-1024px), Desktop (> 990px)
- Accessibility improvements (touch targets, descriptive links, form attributes)
- SEO improvements (valid robots.txt)

**See `README.md` section "‚úÖ Mobile Responsiveness - COMPLETED" for full details.**

---

These rules enforce writing quality, structure, and consistency for interview-style blog articles rendered via `html-react-parser`.

---

## Purpose

Ensure all generated or edited articles:
- Are junior-friendly but senior-accurate
- Are paragraph-driven (Mark43-style), not list-heavy
- Encode semantic intent using HTML + CSS classes
- End with a clear interview-ready takeaway

These rules apply to **all blog article content files**.

---

## Required Structure Rules

### 1. Introduction
- The article **must explicitly state the interview question** in the introduction.
- This must appear within the first 1‚Äì2 paragraphs.
- Example phrasing:
  > ‚ÄúThis article answers the interview question: ‚Äò‚Ä¶‚Äô‚Äù

---

### 2. Semantic HTML Classes (Mandatory)

Articles must use the following semantic wrappers:

- `<div class="explanation">`  
  For conceptual explanations and reasoning.

- `<div class="example">`  
  For concrete scenarios, real-world illustrations, or case studies.

- `<div class="takeaway">`  
  For actionable guidance, heuristics, or interview-ready summaries.

**Rules:**
- Every article must contain **at least one** `.explanation` block.
- Every article must contain **at least one** `.example` block.
- Every article must end with a `.takeaway` block.

---

### 3. Code Examples
- All code must be wrapped in:
  ```html
  <pre><code>...</code></pre>
  ```
- Do not embed code inline inside paragraphs.

---

## Writing Style Rules

### 4. Paragraph-First Writing
- Default to paragraphs, not lists.
- Paragraphs should be **2‚Äì4 sentences**.
- Lists are allowed **only** for:
  - Step-by-step procedures
  - Checklists
  - Explicit enumerations after explanation

**Anti-pattern:** Long explanatory bullet lists.

---

### 5. Bold Lead-Ins
- Key ideas should begin with a **bold lead-in sentence fragment**, followed by explanation.
- Example:
  ```html
  <p><strong>Stability matters more than reuse.</strong> A shared component that changes weekly...</p>
  ```

---

### 6. Junior-Friendly Clarity
When reviewing content:
- If a term is introduced, ensure it is explained plainly.
- If a decision is described, ensure the *reasoning* is stated.
- If tradeoffs exist, they must be acknowledged.

---

## Required Closing Section

### 7. Final Takeaway (Hard Requirement)
The article **must end** with a `<div class="takeaway">` that includes:
- A plain-language summary of the core idea
- A concise, interview-ready answer (1‚Äì2 short paragraphs max)

This section should answer:
> ‚ÄúWhat would you actually say out loud in an interview?‚Äù

---

## Editing & Review Rules

### 8. Editor Pass Expectations
When editing or refactoring articles:
- Convert list-heavy explanations into paragraphs
- Preserve meaning; do not introduce new concepts
- Improve clarity where ideas are implied but not stated
- Ensure all structural requirements still pass

---

## Non-Goals
These rules do NOT require:
- Mentioning SEO, Google, or ranking considerations
- Marketing language or calls-to-action
- Overly verbose explanations

Focus on clarity, correctness, and usefulness.

---

## Blog Post Integration

### 9. Standard Blog Integration Command

When the user says "Please add/integrate/incorporate the <filename>.json file" or similar, follow this process:

**Reference**: Full details in `docs/blog/BLOG_POST_INTEGRATION.md`

**Quick Integration Steps**:

1. **Update JSON file format** (if needed):
   - Ensure `id` is a **number** (must be unique across ALL posts - check existing IDs)
   - Convert `date` to human-readable format: "January 11, 2026" (not ISO format like "2026-01-11")
   - Update `image` to: `https://picsum.photos/367/197?random=N` (find next available number)
   - Add `slug` field if missing (generate from title if needed)
   - Format `tags` as Title Case with spaces (e.g., "React", "Component Design", "State Management & Data Flow")
   - Ensure `category` matches existing category from `src/data/blog/categories.ts`
   - Verify `content` is HTML (not Markdown) - all code must be in `<pre><code>...</code></pre>` blocks
   - Format code blocks with proper line breaks for readability

2. **Find next unique ID**:
   - Check all existing blog post IDs: `grep '"id":' src/data/blog/*.json`
   - Assign next sequential number (e.g., if highest is 7, use 8)
   - **Critical**: IDs must be unique across ALL posts (not just within topics) because `getRelatedPosts()` uses IDs

3. **Find next available image random number**:
   - Check existing random numbers: `grep -h "random=" src/data/blog/*.json | grep -o "random=[0-9]*" | sort -t= -k2 -n | tail -1`
   - Use next number (e.g., if highest is 44, use 45)

4. **Register in blog system**:
   - **File**: `src/data/blog/index.ts`
     - Add import statement at top: `import <camelCaseName>Posts from "./<filename>.json";`
     - Add entry to `blogPostsByTopic` object: `<topic_id>: <camelCaseName>Posts as BlogPosts,`
   - **File**: `src/content/topics.ts`
     - Add topic entry to `topics` array with `id` (filename without .json), `label` (human-readable title), and `description`

5. **Verify**:
   - Run `npm test -- --run`
   - Check for linting errors: `read_lints` on modified files
   - Verify unique ID assignment
   - Ensure all tests pass

**Command Examples** (all trigger the same process):
- "Please add the interview_example.json file"
- "Please incorporate interview_example.json"
- "Please integrate @interview_example.json"
- "Please add @src/data/blog/interview_example.json"

**Important Notes**:
- Blog post IDs must be **unique across all posts** (not just within topics) because `getRelatedPosts()` uses `findIndex((p) => p.id === currentPostId)` to locate posts
- Tags should match existing category names where possible (e.g., use "Frontend Architecture" if the post is about frontend architecture)
- Category must exist in `ALL_CATEGORIES` array in `src/data/blog/categories.ts` (or you must add it there first)
- Topic ID in `topics.ts` must match the filename (without `.json` extension)

---

## Theming System

### 10. Theming System Architecture

**Current Stage: Stage 2 Complete**

The theming system has been fully implemented through Stage 2:

- ‚úÖ **Stage 1 Complete**: All colors migrated to semantic CSS variables
- ‚úÖ **Stage 2 Complete**: ThemePicker component with presets and contrast checking
- üîÑ **Stage 3 Pending**: Advanced color picker integration

**Core Architecture:**

The theming system follows a clear separation of concerns:

1. **CSS Variables Layer** (`src/design/tokens.css`):
   - **Themeable colors** are defined on `#root` (e.g., `--color-bg`, `--color-primary`)
   - **Non-themeable tokens** (fonts, spacing, layout) are defined on `:root`
   - All components use `var(--color-*)` tokens instead of hardcoded colors
   - This allows React to dynamically update colors by modifying CSS variables on `#root`

2. **React State Layer** (`src/context/ThemeContext.tsx`):
   - Manages theme state as a JavaScript object (`Theme` type)
   - Provides `ThemeProvider` that wraps the app
   - `useTheme()` hook for accessing/updating theme
   - Applies theme changes to DOM by updating CSS variables on `#root` element
   - Persists theme to `localStorage` for no-flicker loading
   - Handles preset management (built-in + custom presets)

3. **UI Layer** (`src/components/ThemePicker/`):
   - Floating color picker UI (fixed position, bottom-left corner)
   - Allows users to customize colors in real-time
   - Saves/loads presets, exports/imports themes
   - Uses fixed colors for UI (theme-agnostic) so picker remains visible regardless of theme

4. **Utility Layer** (`src/utils/contrast.ts`):
   - WCAG contrast checking utilities
   - Validates text readability on backgrounds and gradients
   - Provides warnings for accessibility issues

**Key Files:**
- `src/design/tokens.css` - CSS variable definitions (themeable on `#root`, non-themeable on `:root`)
- `src/context/ThemeContext.tsx` - Theme state management, presets, persistence, DOM application
- `src/components/ThemePicker/` - Floating color picker UI with preset management (positioned bottom-left)
- `src/utils/contrast.ts` - WCAG contrast checking with detailed warnings
- `src/design/theming-goals.md` - Original theming architecture documentation

**Documentation Structure:**

Documentation is organized into subfolders:
- `docs/blog/` - Blog post integration guides
- `docs/theming/` - Theme picker and theming system documentation
- `docs/workflow/` - Workflow and methodology guides
- `docs/reference/` - Historical reference documentation
- `docs/PROJECT_SUMMARY.md` - Main project overview (root level)

**Documentation Files (READ THESE FOR THEME PICKER WORK):**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** - Complete guide for React package usage, customization, token creation, preset management, accessibility checks, image-based themes, and adapting to existing codebases
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan for npm package with TDD approach, phases, and architecture decisions
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for adding theme picker to new projects
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan for npm package extraction
- `src/design/theming-goals.md` - Architecture overview and design decisions

**When working on theme picker related tasks, ALWAYS read:**
1. `docs/theming/REACT_PACKAGE_GUIDE.md` - For user-facing features, customization, and API usage
2. `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - For extraction/package development work
3. `docs/theming/COLOR_PICKER_INTEGRATION.md` - For integration patterns and file structure

**Built-in Preset Themes (31 total):**
1. **Default** - Dark theme with blue accents (Midnight Blue)
2. **Cedar Oak** - Warm earth tones (browns/greens)
3. **Mark43** - Original Mark43-inspired theme (orange/blue) - *Commented out in UI but code preserved*
4. **Sage Green** - Light theme with green tones
5. **Crimson Flame** - Fire fighter inspired (red/orange)
6. **Vapor Wave** - 80s aesthetic (magenta/cyan)
7. **Gothic** - Dark theme with purple accents
8. **Horror** - Dark theme with red accents
9. **Pride** - Progress Pride Flag colors (rainbow stripes: red, orange, yellow, green, blue, purple; chevron: white, pink, light blue, brown, black)
10. **Yuko** - Vibrant kaiju-inspired theme (hot pink, neon yellow, crimson red, light blue)
11. **Hokusai** - Japanese woodblock print inspired (deep blue-teal, pale yellow-orange, burnt orange, light blue accents)
12. **Noname** - Vibrant digital art inspired (light purple, bright blue, green, yellow, red accents)
13. **Sadikovic** - Boxing arena inspired (dark blue-black, electric blue, purple, gold, red accents)
14. **AFB** - Boxing gloves inspired (royal blue, metallic purple, gold, crimson red accents)
15. **TUF** - Athletic gear inspired (royal blue tank top, black base, red accents, silver/metallic grey gloves)
16. **Royboy** - Warm sepia portrait inspired (dark brown-black, muted reddish-brown, warm cream/blonde)
17. **Dalmatian** - High contrast black and white with warm blonde accents (diagonal split hoodie, minimalist)
18. **Querida** - Modern gray base with vibrant lime green accents (modern building, clean aesthetic)
19. **Ris** - Bright yellow background with light blue, red, purple, and brown accents (whimsical cartoon art)
20. **Gulu** - Warm beagle-inspired theme (cream, tan, rich browns)
21. **Maxine** - Vibrant portrait-inspired theme (platinum blonde, purple, orange, pink)
22. **Sunrise** - Coastal sunrise theme (light blue, teal, orange, purple)
23. **Noir** - Classic black and white photography theme (grayscale)
24. **Hatsune** - Anime-inspired theme (bright teal, light blue, purple, pink)
25. **Scotland** - Rugged valley landscape theme (pale grey-blue sky, dark blue-grey river, golden brown heather, muted greens)
26. **PBR** - Pabst Blue Ribbon inspired theme (PBR blue #003DA5, red accents, light blue-tinted backgrounds, dark blue footer)
27. **Reeses** - Reese's Pieces candy inspired theme (bright orange #B34D00, yellow accents, light orange-tinted backgrounds, dark brown-black footer)
28. **Fallout** - Vault-Tec inspired theme (Vault-Tec blue #0066CC, gold accents #FFD700, light blue-tinted backgrounds, dark blue footer, purple-blue hero radial #434fad)
29. **Berg√©** - Vibrant fashion-inspired theme (forest green #1F7A1F primary, hot pink #FF1493 accents, light green-tinted backgrounds, dark green footer)
30. **Pink** - Soft pink gerbera daisy inspired theme (soft peach-pink background, vibrant rose accents #ff66a3, WCAG AA compliant)
31. **King** - Dignified portrait-inspired theme (dark brown/charcoal base, warm golden-brown accents, muted green secondary elements, white/cream text) - *Built-in theme with audio easter egg (I Have a Dream speech)*

**Important Theme Picker Rules:**
- **Built-in themes MUST NOT have trash/delete icons** - Only custom user-created presets can be deleted
- Built-in themes include: Default, Cedar Oak, Sage Green, Crimson Flame, Vapor Wave, Gothic, Horror, Pride, Yuko, Hokusai, Noname, Sadikovic, AFB, TUF, Royboy, Dalmatian, Querida, Ris, Gulu, Maxine, Sunrise, Noir, Hatsune, Trippie, Scotland, PBR, Reeses, Fallout, Berg√©, Pink, Dayglow, and **King**
- When adding new built-in themes, ensure they are added to the `isBuiltIn` check in `ThemePicker.tsx` (around line 406)
- Do NOT add delete/trash functionality for built-in themes unless explicitly requested by the user
- The trash icon is conditionally rendered based on `!isBuiltIn` check - built-in themes should never show delete buttons

**Important Implementation Notes:**
- **CSS variables are the styling layer**: All color styling happens via CSS variables (`var(--color-*)`)
- **React manages the data**: ThemeContext holds theme state and applies it to DOM
- **Semantic tokens**: Colors use semantic names (e.g., `--color-primary`, `--color-text`) not raw colors
- **Themeable colors on `#root`**: Allows nested theme overrides in the future
- **Non-themeable tokens on `:root`**: Fonts, spacing, and layout values are static
- All preset themes meet WCAG AA contrast requirements (‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic) so it doesn't change with theme
- ThemePicker positioned bottom-left corner (matching Mark43 design)
- Contrast checker validates text on gradients by checking both start and end colors
- Semi-transparent colors are blended with backgrounds before contrast calculation
- Custom presets are stored in separate `localStorage` key from active theme
- Theme is applied to DOM before React render to prevent flicker on page load

### 11. Theme Picker Documentation & npm Package

**For Theme Picker Development & Customization:**

When working on theme picker features, customization, or npm package extraction:

1. **Read Primary Documentation:**
   - `docs/theming/REACT_PACKAGE_GUIDE.md` - Complete user guide covering:
     - Installation & setup
     - Token creation & theme definition
     - Adding theme presets
     - Adding accessibility checks (with code examples)
     - Creating themes from images
     - Customization (button colors, categories, CSS variables)
     - Adapting to existing codebases
     - Cursor rules & AI prompts for users
     - API reference
     - Troubleshooting

2. **For npm Package Extraction:**
   - `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan with:
     - TDD approach (tests in `src/__tests__/`)
     - Phase-by-phase extraction plan
     - Package architecture
     - Testing strategy
     - Publishing checklist

3. **For Integration:**
   - `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for:
     - File structure
     - Dependencies
     - Step-by-step integration
     - API reference

**Key Principles:**
- All theme colors must be on `#root` (not `:root`)
- CSS variables follow pattern: `--color-{kebab-case-key}`
- Always check contrast ratios (WCAG AA: ‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic)
- Tests should be written first (TDD approach)
- Documentation should be comprehensive and user-friendly

**When Adding New Features:**
- Update relevant documentation files
- Add tests following TDD approach
- Update API reference if needed
- Provide examples in documentation

---

## Summary Checklist

Before merging or publishing:
- [ ] Interview question stated in intro
- [ ] `.explanation` present
- [ ] `.example` present
- [ ] Final `.takeaway` present and interview-ready
- [ ] Paragraph-driven, list-light writing
- [ ] Valid HTML compatible with `html-react-parser`

---

## Website Domain Information

**Production Domain:** `floatingpla.net`
- All meta tags, sitemaps, and external URLs should use `https://floatingpla.net`
- When updating robots.txt, Open Graph tags, or canonical URLs, use this domain
- The website is deployed at: `https://floatingpla.net`

---

## Agent Session Checklist

**Before starting work, ensure you have:**
- [ ] Read `README.md` to understand current TODOs and priorities
- [ ] Read `docs/PROJECT_SUMMARY.md` for project overview
- [ ] Reviewed `docs/README.md` for documentation structure
- [ ] Understood the current priority (check README.md "üéØ Next Priority" section)
- [ ] Located relevant documentation for your task type
- [ ] Familiarized yourself with key code files mentioned in PROJECT_SUMMARY.md

---

## Test Driven Development (TDD) Environment

### 12. TDD Workflow & Testing Standards

**This project operates in a Test Driven Development (TDD) environment.**

**Core TDD Principles:**
- **Write tests first** - Tests should be written before or alongside implementation
- **Red-Green-Refactor cycle** - Write failing test ‚Üí Make it pass ‚Üí Refactor
- **Test coverage is important** - Aim for high coverage of business logic and critical paths
- **Tests document behavior** - Tests serve as living documentation of expected behavior

**Testing Stack:**
- **Vitest** - Test runner and framework
- **@testing-library/react** - React component testing utilities
- **@testing-library/jest-dom** - Custom DOM matchers
- **@vitest/coverage-v8** - Code coverage reporting (v8 provider)

**Test Commands:**
- `npm test` - Run tests in watch mode (development)
- `npm run test:coverage` - Run tests once with coverage report
- `npm run test:ui` - Open Vitest UI for interactive test running and debugging

**Useful Terminal Commands for Testing & Coverage Analysis:**

1. **Run specific test file:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run
   ```

2. **Check coverage for specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx
   ```

3. **Get test summary (pass/fail counts):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -E "(Test Files|Tests )" | head -2
   ```

4. **Get coverage stats for specific source file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | head -1
   ```

5. **View detailed test output (last 30 lines):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | tail -30
   ```

6. **Check for specific test failures:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -A 10 "FAIL"
   ```

7. **Get coverage percentage for a specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | grep -oE "[0-9]+\.[0-9]+"
   ```

8. **Check linting errors for test file:**
   ```bash
   # Use read_lints tool in Cursor, or:
   npm run lint -- src/__tests__/ComponentName.test.tsx
   ```

**Identifying Coverage Gaps:**
- After running coverage, check `coverage/index.html` for line-by-line coverage
- Look for red/yellow lines indicating uncovered code
- Use the grep commands above to quickly check coverage percentages
- Focus on uncovered branches (if statements, ternary operators, etc.)

**When Writing or Modifying Code:**

1. **Before implementing a feature:**
   - Consider what tests are needed
   - Write test cases that describe the expected behavior
   - Run tests to see them fail (Red)

2. **During implementation:**
   - Write minimal code to make tests pass (Green)
   - Refactor while keeping tests green (Refactor)

3. **After implementation:**
   - **ALWAYS run test coverage** to verify coverage:
     ```bash
     npm run test:coverage
     ```
   - Review coverage report in `coverage/index.html` or terminal output
   - Identify any uncovered code paths
   - Add tests for edge cases and error handling

**Code Coverage Standards:**

**Minimum Coverage Targets:**
- **Statements: 80%**
- **Lines: 80%**
- **Functions: 80%**
- **Branches: 65%**

These thresholds represent a practical, professional baseline for a frontend React project.

**Coverage Guidelines:**
- Coverage should reflect **meaningful, behavior-focused tests**‚Äînot artificially inflated metrics
- **Prioritize testing:**
  - Core utilities and business logic
  - Critical user flows
  - Error and edge cases that can realistically occur
- **Avoid writing contrived tests** solely to reach 100% coverage

**Acceptable Exceptions:**
Some branches may remain uncovered when they:
- Represent defensive guards unlikely to occur in real usage
- Depend on browser or third-party behaviors difficult to simulate
- Require unnatural hacks that reduce test quality

**Target Philosophy:**
- **Utilities:** strive for 90%+ coverage
- **Components:** 75‚Äì85% is acceptable
- **Branch coverage** will naturally be lower than statements

**When Reviewing Code:**
- New features should maintain or improve existing coverage
- Large logic changes must include updated tests
- Refactors should not reduce overall coverage without justification

**Exclude from coverage** (already configured in `vitest.config.ts`):
- Type definition files (`src/**/types.ts`)
- Pure constant data files (`src/data/blog/categories.ts`)
- Context instance files (`src/context/ThemeContextInstance.ts`)
- Test files themselves
- Setup files

**Test File Structure:**
- Test files live in `src/__tests__/` directory
- Naming: `ComponentName.test.tsx` or `feature.test.tsx`
- Use `describe` blocks to group related tests
- Use `it` or `test` for individual test cases
- Follow AAA pattern: Arrange, Act, Assert

**Example Test Structure:**
```typescript
import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import { Component } from "@/components/Component";
import { ThemeProvider } from "@/context/ThemeContext";

describe("Component", () => {
  it("renders correctly", () => {
    render(
      <ThemeProvider>
        <Component />
      </ThemeProvider>
    );
    expect(screen.getByText("Expected Text")).toBeTruthy();
  });
});
```

**When AI Assistant Should Suggest Running Coverage:**

The AI assistant should **automatically suggest running test coverage** in these scenarios:

1. **After creating new test files:**
   - "I've created tests for ComponentX. Run `npm run test:coverage` to see the coverage improvement."

2. **After implementing new features:**
   - "Feature implementation complete. Run `npm run test:coverage` to verify test coverage."

3. **After modifying existing code:**
   - "Code changes complete. Run `npm run test:coverage` to ensure existing tests still pass and coverage is maintained."

4. **When user asks about test coverage:**
   - "To check current test coverage, run: `npm run test:coverage`"
   - "The coverage report will show in the terminal and be saved to `coverage/index.html` for detailed analysis."

5. **When identifying low coverage areas:**
   - "I notice ComponentX has low coverage. After adding tests, run `npm run test:coverage` to verify improvement."

**Coverage Report Locations:**
- **Terminal output** - Summary statistics (statements, branches, functions, lines)
- **`coverage/index.html`** - Interactive HTML report with line-by-line coverage
- **`coverage/coverage-summary.json`** - Machine-readable JSON report

**Best Practices:**
- Run `npm run test:coverage` **before committing** significant changes
- Review coverage reports to identify untested code paths
- Focus on testing **user-facing behavior** rather than implementation details
- Use `ThemeProvider` wrapper in tests for components that use `useTheme()`
- Use `BrowserRouter` wrapper for components that use React Router
- Mock external dependencies (APIs, browser APIs like Audio) appropriately
- Clean up after tests (clear localStorage, restore mocks, etc.)

**Common Testing Patterns & Gotchas:**

1. **Testing Components with `useParams` (React Router):**
   - **Problem:** `useParams()` returns `undefined` if the component isn't rendered within a matching route
   - **Solution:** Wrap component in `<Routes><Route>` to match the route pattern:
     ```tsx
     render(
       <MemoryRouter initialEntries={['/resources/blog/my-slug']}>
         <Routes>
           <Route path="/resources/blog/:slug" element={<BlogPost />} />
         </Routes>
       </MemoryRouter>
     );
     ```
   - **Don't:** Just use `<MemoryRouter>` with the path - this won't match the route and `useParams` will be undefined

2. **Testing Components with ThemeProvider:**
   - **Problem:** `currentPresetId` is derived by matching the saved theme object to presets, not read directly from localStorage
   - **Solution:** Set the actual theme object in localStorage (not just a preset ID):
     ```tsx
     import { builtInPresets } from "@/context/themeData";
     const noirPreset = builtInPresets.find(p => p.id === 'noir');
     if (noirPreset) {
       localStorage.setItem('user-theme', JSON.stringify(noirPreset.theme));
     }
     ```
   - **Why:** ThemeProvider matches the saved theme to find the preset ID, so the theme object must match exactly

3. **Mocking Browser APIs (Image, Audio, etc.):**
   - **Problem:** Constructor mocks need to return the same object instance for property assignments to work
   - **Solution:** Use a consistent mock object with getter/setter for properties:
     ```tsx
     let mockImage = {
       onload: null,
       onerror: null,
       get src() { return this._src || ''; },
       set src(value) { this._src = value; },
       complete: false,
     };
     global.Image = vi.fn(() => mockImage) as any;
     ```
   - **Why:** When code does `img.src = url`, it needs to set the property on the returned mock object

4. **Debugging Test Failures - Systematic Approach:**
   - **Start with simpler tests:** Fix basic rendering tests before complex hook/effect tests
   - **Identify root cause:** If many tests fail, find the common issue (e.g., route matching, context initialization)
   - **Verify assumptions:** Check if mocks are set up correctly, if context providers are initialized, if routes match
   - **Use human-in-the-loop:** After 2-3 attempts, ask for guidance rather than continuing to guess

5. **Testing Custom Hooks:**
   - **Isolation tests:** Test hooks with `renderHook` to verify they work in isolation
   - **Component integration:** If hook works in isolation but fails in component, check:
     - Is the hook receiving correct parameters?
     - Is the component's context/provider initialized?
     - Are effects running (may need `act()` or `waitFor()`)?
   - **Common issue:** Hook works standalone but fails in component = context/initialization problem, not hook problem

**Test Coverage Configuration:**
- Coverage provider: `v8` (fast, modern)
- Reporters: `text` (terminal), `json` (machine-readable), `html` (browsable)
- Coverage includes: `src/**/*.{ts,tsx}`
- Exclusions configured in `vitest.config.ts` for non-testable files

---

### 13. Cyclomatic Complexity Standards

**This project uses JS-Friendly Cyclomatic Complexity rules for JavaScript/TypeScript.**

**You are writing JavaScript/TypeScript using JS-friendly cyclomatic complexity rules. Follow these rules strictly:**

**Base Rule:**
- Every function starts with complexity = 1 (base).
- Base values do NOT stack across function boundaries.

**What Increases Complexity (+1 each):**

**Control Flow:**
- `if`, `else if`
- `for`, `while`, `do...while`
- `switch` ‚Üí each `case`
- `catch`
- Early return guarded by a condition

**Expressions:**
- Ternary operator: `cond ? a : b`
- Logical operators: `&&`, `||`, `??`

**Important:** Each logical operator counts independently:
- `a && b && c` ‚Üí +2 complexity (two `&&` operators)
- `a || b` ‚Üí +1 complexity (one `||` operator)

**What Does NOT Increase Complexity:**
- Function calls (including `setTimeout`, `requestAnimationFrame`)
- `async` / `await`
- JSX rendering
- `.map`, `.forEach`, `.filter` (unless they contain decision points)
- Boolean comparisons passed as arguments: `setState(x > 10)` does NOT add complexity
- Sequential statements (assignments, calls, logging, object/array literals, destructuring, arithmetic/string ops, unconditional return)
- TypeScript types/interfaces/generics (compile-time only)

**Per-Function Accounting (Critical Rule):**
- Cyclomatic complexity is **per function**, not per file or component.
- **Correct:** Parent function: 3, Nested callback: 4 (each measured independently)
- **Incorrect:** Parent function: 7 ‚ùå (do NOT auto-sum children)
- If rollups are shown, they must be explicitly labeled (e.g., "tree sum").

**JSX-Specific Rules:**
- JSX volume ‚â† complexity
- Skeleton / layout components are usually complexity = 1
- Inline callbacks (`onClick={() => ...}`) are:
  - complexity = 1 (base)
  - optional to include in reports

**Complexity Targets:**
- **Default:** Keep cyclomatic complexity ‚â§ 10 per function/method
- **UI Components, Hooks, Event Handlers:** Prefer ‚â§ 6
- **Exceptions:** Any function expected to exceed 10 must be intentionally refactored or split unless there is a strong reason (documented inline)

**Design Constraints to Keep Complexity Low:**

When generating code, prefer patterns that naturally reduce branching:

1. **Early returns / guard clauses** to avoid deep nesting
2. **Extract helpers** when logic branches: move a branchy block into a named function with a focused purpose
3. **Replace long if/else chains** with:
   - A lookup map/object of handlers (`const handlers = { ... }`)
   - Strategy functions
   - Small pure functions that return a value (then render/use the value)
4. **Split "do everything" functions** into:
   - Parsing/validation (pure)
   - Decision logic (pure)
   - Side effects (isolated)
5. **Keep callbacks small** (`map`, `filter`, `reduce`, event handlers); if branching appears, extract to a named function
6. **Prefer data-driven configuration** over branching (e.g., arrays of rules, tables of constants)
7. **Prefer early returns and simple expressions** to reduce decision density
8. **Avoid chaining multiple `&&` / `||`** in a single expression when clarity suffers
9. **When complexity exceeds 5, consider refactoring** into smaller functions

**Testing / Maintainability Requirements:**
- Keep decision logic in pure functions (easy to unit test)
- Components should mostly compose UI; non-trivial conditional logic belongs in helpers/hooks
- Limit nesting depth (aim ‚â§ 2) and avoid combining multiple concerns in one function

**Recommended Report Fields (for clarity):**
For each function:
- **CC (self)** ‚Äì complexity of the function itself
- **Decision sources** ‚Äì `if`, `?:`, `&&`, `||`
- **Nested max CC** ‚Äì highest child complexity (optional)
- **Tree sum CC** ‚Äì sum of all nested functions (optional, custom)

**ESLint Enforcement:**
- Complexity rule is configured in `eslint.config.js`
- Current threshold: `max: 10` with `variant: "classic"` (warn level)
- Use `npm run lint` to check for complexity violations
- Use `npm run lint:complexity` to generate an HTML complexity report

**Complexity Report Generation:**

The project includes a custom complexity report generator that creates an interactive HTML report mimicking Vitest's coverage UI. The report displays all functions (not just those exceeding the threshold) with comprehensive metrics and folder-based navigation.

**Script Location:**
- `scripts/generate-complexity-report.js` - Custom Node.js script that generates HTML complexity reports

**Current Status: ‚úÖ Core Features Complete**

**Completed Features:**
- ‚úÖ **Folder-based navigation** - Hierarchical structure matching Vitest (`complexity/index.html` ‚Üí `complexity/src/components/index.html`)
- ‚úÖ **All functions displayed** - Shows all functions, not just those exceeding threshold (configurable via `--show-all` flag)
- ‚úÖ **Vitest-style UI** - Matches Vitest coverage report visual design:
  - Progress bars with color-coded levels (high/medium/low)
  - Table styling with `rgb(230, 245, 208)` background
  - Sortable columns with toggle icons (‚Üï, ‚Üë, ‚Üì)
  - Right-aligned sort icons for progress bar and percentage columns
  - Borderless headers matching Vitest design
- ‚úÖ **Comprehensive sorting** - Sortable by File, Function, Complexity, Line, and Functions (ratio)
  - Functions column sorts by ratio first, then by total count (denominator) when ratios are equal
  - Default sort direction: descending for functions/percentage columns (most to least)
- ‚úÖ **Filtering** - Checkbox to toggle between all functions and only those exceeding threshold
- ‚úÖ **Function name extraction** - Extracts function names from source code using regex patterns
- ‚úÖ **Deduplication** - Prevents duplicate function entries (keeps highest complexity)
- ‚úÖ **Test file exclusion** - Automatically excludes `__tests__` directories from analysis

**How It Works:**

1. **ESLint Integration:**
   - Creates temporary `eslint.config.temp.js` with `complexity: ["warn", { max: 0, variant: "classic" }]` to capture all functions
   - Sets `globalIgnores` to exclude `__tests__` directories
   - Executes ESLint with JSON output format
   - Cleans up temporary config file after execution

2. **Report Generation:**
   - Parses ESLint JSON output to extract all function complexity data
   - Extracts function names from source files using regex patterns
   - Deduplicates functions based on `filePath:functionName` (keeps highest complexity)
   - Organizes functions by folder/directory structure
   - Calculates folder-level statistics (total functions, within threshold, percentage)
   - Generates separate HTML files for each folder (folder-based navigation)

3. **HTML Report Output:**
   - **Main report**: `complexity/index.html` - Shows folder-level summary with:
     - File column (clickable links to folder pages)
     - Progress bar column (sortable, right-aligned sort icon)
     - Functions percentage column (sortable, left-aligned with "Functions" label)
     - Functions fraction column (sortable, right-aligned sort icon)
   - **Folder pages**: `complexity/<folder_path>/index.html` - Shows function-level details with:
     - File, Function, Complexity, Line columns
     - Progress bar column (sortable by complexity)
     - Checkbox filter to show all functions or only those exceeding threshold
   - Uses CSS styling matching Vitest's coverage report design
   - Color-coded progress bars:
     - **High (‚â•80%)**: Dark green (`rgb(77,146,33)`)
     - **Medium (‚â•40%)**: Yellow/gold (`#f9cd0b`)
     - **Low (<40%)**: Dark red (`#C21F39`)

4. **Dependencies & Packages:**
   - **ESLint** - Core linting engine (already in devDependencies)
   - **complexity-report-html** (v0.0.3) - Listed in devDependencies but **not actively used** (evaluated but custom solution preferred)
   - **eslintcc** (v0.8.3) - Listed in devDependencies but **not actively used** (alternative tool, kept for potential future use)

**Command:**
```bash
npm run lint:complexity          # Generate report (default: show only functions > 10)
npm run lint:complexity:all      # Generate report with all functions visible by default
```

**Output Files:**
- `complexity/index.html` - Main report (folder-level summary)
- `complexity/<folder_path>/index.html` - Folder-specific reports (function-level details)
- `complexity-report.json` - Intermediate ESLint JSON output (gitignored, cleaned up after parsing)

**Report Features:**
- ‚úÖ Visual progress bars showing complexity levels (horizontal bars with filled/empty segments on single line)
- ‚úÖ Color-coded rows matching complexity severity
- ‚úÖ Clickable folder links (navigate to folder-specific pages)
- ‚úÖ Line number references to locate functions in source code
- ‚úÖ Summary statistics (function count, max complexity, average complexity)
- ‚úÖ Sortable columns with visual indicators (‚Üï inactive, ‚Üë/‚Üì active)
- ‚úÖ Filter checkbox to toggle function visibility
- ‚úÖ Right-aligned percentage values and sort icons
- ‚úÖ Borderless table headers matching Vitest design

**CSS Styling:**
- Matches Vitest coverage report color scheme and layout
- Progress bars render on single line using `font-size: 0`, `white-space: nowrap`, and `vertical-align: top`
- Table cell padding: `10px` (standardized)
- Progress bar column: `min-width: 120px`
- Table row background: `rgb(230, 245, 208)`
- Headers: `border: none !important` (borderless design)

**Future Enhancements (TODOs):**

1. **Function Source Code Viewing:**
   - [ ] Enable clicking into each function to view the entire function source code
   - [ ] Display full function implementation with syntax highlighting
   - [ ] Highlight complexity decision paths (if/else, loops, switch statements, ternary operators)
   - [ ] Show visual indicators for each branch point that contributes to complexity
   - [ ] Generate separate HTML files for each source file (similar to Vitest's `.tsx.html` files)
   - [ ] Add a click-in feature for each individual file to show the code for each file

2. **Enhanced Interactivity:**
   - [ ] Add expandable/collapsible function details
   - [ ] Show detailed complexity breakdown (which specific constructs contribute most to complexity)
   - [ ] Add search/filter functionality (beyond current checkbox)
   - [ ] Add filter by complexity range (e.g., show only functions with complexity 15-20)

3. **Integration Improvements:**
   - [ ] Consider integrating with test coverage reports (show complexity alongside coverage)
   - [ ] Add CI/CD integration (fail builds if complexity exceeds thresholds)
   - [ ] Generate historical trends (track complexity over time)
   - [ ] Export to various formats (JSON, CSV) for further analysis
   - [ ] Add comparison view (compare complexity between commits/branches)
   - [ ] **Package complexity report generator as npm package** - Extract the complexity report generator into a reusable npm package for use in other projects

4. **UI/UX Enhancements:**
   - [ ] Add keyboard navigation support
   - [ ] Improve mobile responsiveness of report UI
   - [ ] Add tooltips explaining complexity metrics
   - [ ] Add export functionality (download report as HTML/PDF)
   - [ ] Adjust styles to mirror coverage styles from Vitest more closely
   - [ ] Adjust headers more (refine header styling and layout)
   - [ ] Begin identifying way to color code decision paths but need to decide first what to do and how, for example, hints or something similar to what Vitest coverage does

5. **Styling & Highlighting Improvements:**
   - [ ] Continue fixing areas that aren't properly highlighted in the complexity report
   - [ ] Ensure all decision points are correctly identified and visually highlighted
   - [ ] Improve visual consistency of highlighting across different decision point types

6. **Decision Path Tracking:**
   - [ ] Add features to numerically track decision paths per file (e.g., count of if statements, else statements, ternaries, loops, etc.)
   - [ ] Decide on categorization: track individually (if, else, ternary, etc.) or chunked into groups (statements, loops, ternaries, etc.)
   - [ ] Display decision path statistics at file and folder levels

7. **Complexity Calculation Investigation:**
   - [x] Investigate why `ScrollToTop.tsx.html` seems to mis-track complexity - the breakdown shows `(1 base + 2 if)` which equals 3, but the reported complexity is 2
     - **Fixed**: Decision points are now assigned to the innermost function that contains them, and arrow function boundaries are detected correctly
   - [x] Understand why `if` statements within `useEffect` hooks are being counted in the breakdown, but the base function declaration containing them doesn't seem to be included in the total correctly
     - **Fixed**: Decision points within nested functions (like useEffect callbacks) are now correctly assigned to those nested functions, not the outer function
   - [x] Verify ESLint's complexity calculation matches our breakdown calculation for edge cases (nested functions, hooks, callbacks)
     - **Fixed**: Breakdowns now match ESLint's complexity scores for nested functions

8. **Documentation Updates:**
   - [ ] Update `complexity/about.html` to clarify why some constructs that seem like decision paths are not counted (e.g., `try` blocks don't add complexity, only `catch` blocks do; `else` blocks don't add complexity independently, they're part of the `if` statement's complexity)

9. **Code Refactoring - Complexity Report Generator:**
   - [ ] **PRIORITY: Split `scripts/generate-complexity-report.js` into smaller, focused modules**
     - **Problem:** File has grown to 3,000+ lines, causing hallucinations, Cursor struggling, worse refactors, and making mistakes
     - **Goal:** Split into appropriate files closer to 1,000 lines each
     - **Approach:**
       - Extract decision point parsing functions into separate module
       - Extract HTML generation functions into separate module
       - Extract function boundary detection into separate module
       - Extract complexity breakdown calculation into separate module
       - Keep main orchestration logic in primary file
     - **Benefits:** Better maintainability, easier to understand, reduces AI confusion, improves refactoring quality