# Cursor Content Rules ‚Äî Interview Blog Articles

## üöÄ Quick Start for Agents

**When starting a new session, read these files in order to understand the project:**

### 1. Current Status & TODOs
- **`README.md`** - **START HERE** - Contains current TODO list and next priority (currently: Mobile Responsiveness)
  - See section "üéØ Next Priority: Mobile Responsiveness" for current focus
  - See "TODO: Lighthouse 100 Score & SEO Optimization" for remaining tasks
  - Review "Notes" section for important implementation details

### 2. Project Overview
- **`docs/PROJECT_SUMMARY.md`** - Complete project overview, architecture, and current state
  - Project structure and tech stack
  - Key features (Content System, Blog System, Theming System)
  - Important files to read for each feature
  - Current status and next steps

### 3. Documentation Index
- **`docs/README.md`** - Documentation structure and quick links
  - Organized by topic (blog, theming, workflow, reference)
  - Quick links to relevant documentation

### 4. Key Documentation by Task Type

**For Blog Work:**
- `docs/blog/BLOG_POST_INTEGRATION.md` - Blog post integration process

**For Theming Work:**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** for theme picker
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Package extraction plan
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan

**For Workflow/Methodology:**
- `docs/workflow/SCALABLE_CURSOR_WEBSITE_REBUILD_WORKFLOW.md` - General methodology

**For Historical Reference:**
- `docs/reference/` - Mark43 reference materials (historical)

### 5. Code Structure Understanding
- **`src/design/tokens.css`** - CSS variables and design tokens
- **`src/context/ThemeContext.tsx`** - Theme state management
- **`src/components/ThemePicker/`** - Theme picker UI component
- **`src/data/blog/`** - Blog post data and utilities
- **`src/pages/`** - Page components (Home, Blog, BlogPost)
- **`src/sections/`** - Reusable section components

### 5a. Path Aliases
- **Path alias `@/` is configured** - Maps to `src/` directory
- **Configuration:**
  - `vite.config.ts` - Vite resolve alias: `"@": path.resolve(__dirname, "./src")`
  - `tsconfig.app.json` - TypeScript path mapping: `"@/*": ["./src/*"]`
- **Usage:** Always use `@/` prefix for imports from `src/` directory
  - ‚úÖ `import { Header } from "@/sections/Header";`
  - ‚úÖ `import { useTheme } from "@/context/useTheme";`
  - ‚ùå `import { Header } from "../sections/Header";` (avoid relative paths)
- **Benefits:** Cleaner imports, easier refactoring, better maintainability

### 6. Mobile Responsiveness - ‚úÖ COMPLETED
**Status:** Mobile responsiveness has been fully implemented across all components.

**Completed Work:**
- All core layout components (Header, Hero, Footer)
- Complete blog system (BlogPost, Blog listing, FeaturedBlogPost, BlogFilters, BlogGrid, LatestBlogs/LatestNews)
- Responsive breakpoints implemented: Mobile (< 768px), Tablet (768px-990px), iPad Landscape (768px-1024px), Desktop (> 990px)
- Accessibility improvements (touch targets, descriptive links, form attributes)
- SEO improvements (valid robots.txt)

**See `README.md` section "‚úÖ Mobile Responsiveness - COMPLETED" for full details.**

---

These rules enforce writing quality, structure, and consistency for interview-style blog articles rendered via `html-react-parser`.

---

## Purpose

Ensure all generated or edited articles:
- Are junior-friendly but senior-accurate
- Are paragraph-driven (Mark43-style), not list-heavy
- Encode semantic intent using HTML + CSS classes
- End with a clear interview-ready takeaway

These rules apply to **all blog article content files**.

---

## Required Structure Rules

### 1. Introduction
- The article **must explicitly state the interview question** in the introduction.
- This must appear within the first 1‚Äì2 paragraphs.
- Example phrasing:
  > ‚ÄúThis article answers the interview question: ‚Äò‚Ä¶‚Äô‚Äù

---

### 2. Semantic HTML Classes (Mandatory)

Articles must use the following semantic wrappers:

- `<div class="explanation">`  
  For conceptual explanations and reasoning.

- `<div class="example">`  
  For concrete scenarios, real-world illustrations, or case studies.

- `<div class="takeaway">`  
  For actionable guidance, heuristics, or interview-ready summaries.

**Rules:**
- Every article must contain **at least one** `.explanation` block.
- Every article must contain **at least one** `.example` block.
- Every article must end with a `.takeaway` block.

---

### 3. Code Examples
- All code must be wrapped in:
  ```html
  <pre><code>...</code></pre>
  ```
- Do not embed code inline inside paragraphs.

---

## Writing Style Rules

### 4. Paragraph-First Writing
- Default to paragraphs, not lists.
- Paragraphs should be **2‚Äì4 sentences**.
- Lists are allowed **only** for:
  - Step-by-step procedures
  - Checklists
  - Explicit enumerations after explanation

**Anti-pattern:** Long explanatory bullet lists.

---

### 5. Bold Lead-Ins
- Key ideas should begin with a **bold lead-in sentence fragment**, followed by explanation.
- Example:
  ```html
  <p><strong>Stability matters more than reuse.</strong> A shared component that changes weekly...</p>
  ```

---

### 6. Junior-Friendly Clarity
When reviewing content:
- If a term is introduced, ensure it is explained plainly.
- If a decision is described, ensure the *reasoning* is stated.
- If tradeoffs exist, they must be acknowledged.

---

## Required Closing Section

### 7. Final Takeaway (Hard Requirement)
The article **must end** with a `<div class="takeaway">` that includes:
- A plain-language summary of the core idea
- A concise, interview-ready answer (1‚Äì2 short paragraphs max)

This section should answer:
> ‚ÄúWhat would you actually say out loud in an interview?‚Äù

---

## Editing & Review Rules

### 8. Editor Pass Expectations
When editing or refactoring articles:
- Convert list-heavy explanations into paragraphs
- Preserve meaning; do not introduce new concepts
- Improve clarity where ideas are implied but not stated
- Ensure all structural requirements still pass

---

## Non-Goals
These rules do NOT require:
- Mentioning SEO, Google, or ranking considerations
- Marketing language or calls-to-action
- Overly verbose explanations

Focus on clarity, correctness, and usefulness.

---

## Blog Post Integration

### 9. Standard Blog Integration Command

When the user says "Please add/integrate/incorporate the <filename>.json file" or similar, follow this process:

**Reference**: Full details in `docs/blog/BLOG_POST_INTEGRATION.md`

**Quick Integration Steps**:

1. **Update JSON file format** (if needed):
   - Ensure `id` is a **number** (must be unique across ALL posts - check existing IDs)
   - Convert `date` to human-readable format: "January 11, 2026" (not ISO format like "2026-01-11")
   - Update `image` to: `https://picsum.photos/367/197?random=N` (find next available number)
   - Add `slug` field if missing (generate from title if needed)
   - Format `tags` as Title Case with spaces (e.g., "React", "Component Design", "State Management & Data Flow")
   - Ensure `category` matches existing category from `src/data/blog/categories.ts`
   - Verify `content` is HTML (not Markdown) - all code must be in `<pre><code>...</code></pre>` blocks
   - Format code blocks with proper line breaks for readability

2. **Find next unique ID**:
   - Check all existing blog post IDs: `grep '"id":' src/data/blog/*.json`
   - Assign next sequential number (e.g., if highest is 7, use 8)
   - **Critical**: IDs must be unique across ALL posts (not just within topics) because `getRelatedPosts()` uses IDs

3. **Find next available image random number**:
   - Check existing random numbers: `grep -h "random=" src/data/blog/*.json | grep -o "random=[0-9]*" | sort -t= -k2 -n | tail -1`
   - Use next number (e.g., if highest is 44, use 45)

4. **Register in blog system**:
   - **File**: `src/data/blog/index.ts`
     - Add import statement at top: `import <camelCaseName>Posts from "./<filename>.json";`
     - Add entry to `blogPostsByTopic` object: `<topic_id>: <camelCaseName>Posts as BlogPosts,`
   - **File**: `src/content/topics.ts`
     - Add topic entry to `topics` array with `id` (filename without .json), `label` (human-readable title), and `description`

5. **Verify**:
   - Run `npm test -- --run`
   - Check for linting errors: `read_lints` on modified files
   - Verify unique ID assignment
   - Ensure all tests pass

**Command Examples** (all trigger the same process):
- "Please add the interview_example.json file"
- "Please incorporate interview_example.json"
- "Please integrate @interview_example.json"
- "Please add @src/data/blog/interview_example.json"

**Important Notes**:
- Blog post IDs must be **unique across all posts** (not just within topics) because `getRelatedPosts()` uses `findIndex((p) => p.id === currentPostId)` to locate posts
- Tags should match existing category names where possible (e.g., use "Frontend Architecture" if the post is about frontend architecture)
- Category must exist in `ALL_CATEGORIES` array in `src/data/blog/categories.ts` (or you must add it there first)
- Topic ID in `topics.ts` must match the filename (without `.json` extension)

---

## Theming System

### 10. Theming System Architecture

**Current Stage: Stage 2 Complete**

The theming system has been fully implemented through Stage 2:

- ‚úÖ **Stage 1 Complete**: All colors migrated to semantic CSS variables
- ‚úÖ **Stage 2 Complete**: ThemePicker component with presets and contrast checking
- üîÑ **Stage 3 Pending**: Advanced color picker integration

**Core Architecture:**

The theming system follows a clear separation of concerns:

1. **CSS Variables Layer** (`src/design/tokens.css`):
   - **Themeable colors** are defined on `#root` (e.g., `--color-bg`, `--color-primary`)
   - **Non-themeable tokens** (fonts, spacing, layout) are defined on `:root`
   - All components use `var(--color-*)` tokens instead of hardcoded colors
   - This allows React to dynamically update colors by modifying CSS variables on `#root`

2. **React State Layer** (`src/context/ThemeContext.tsx`):
   - Manages theme state as a JavaScript object (`Theme` type)
   - Provides `ThemeProvider` that wraps the app
   - `useTheme()` hook for accessing/updating theme
   - Applies theme changes to DOM by updating CSS variables on `#root` element
   - Persists theme to `localStorage` for no-flicker loading
   - Handles preset management (built-in + custom presets)

3. **UI Layer** (`src/components/ThemePicker/`):
   - Floating color picker UI (fixed position, bottom-left corner)
   - Allows users to customize colors in real-time
   - Saves/loads presets, exports/imports themes
   - Uses fixed colors for UI (theme-agnostic) so picker remains visible regardless of theme

4. **Utility Layer** (`src/utils/contrast.ts`):
   - WCAG contrast checking utilities
   - Validates text readability on backgrounds and gradients
   - Provides warnings for accessibility issues

**Key Files:**
- `src/design/tokens.css` - CSS variable definitions (themeable on `#root`, non-themeable on `:root`)
- `src/context/ThemeContext.tsx` - Theme state management, presets, persistence, DOM application
- `src/components/ThemePicker/` - Floating color picker UI with preset management (positioned bottom-left)
- `src/utils/contrast.ts` - WCAG contrast checking with detailed warnings
- `src/design/theming-goals.md` - Original theming architecture documentation

**Documentation Structure:**

Documentation is organized into subfolders:
- `docs/blog/` - Blog post integration guides
- `docs/theming/` - Theme picker and theming system documentation
- `docs/workflow/` - Workflow and methodology guides
- `docs/reference/` - Historical reference documentation
- `docs/PROJECT_SUMMARY.md` - Main project overview (root level)

**Documentation Files (READ THESE FOR THEME PICKER WORK):**
- `docs/theming/REACT_PACKAGE_GUIDE.md` - **PRIMARY REFERENCE** - Complete guide for React package usage, customization, token creation, preset management, accessibility checks, image-based themes, and adapting to existing codebases
- `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan for npm package with TDD approach, phases, and architecture decisions
- `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for adding theme picker to new projects
- `docs/theming/THEME_PICKER_TRANSITION_PLAN.md` - Transition plan for npm package extraction
- `src/design/theming-goals.md` - Architecture overview and design decisions

**When working on theme picker related tasks, ALWAYS read:**
1. `docs/theming/REACT_PACKAGE_GUIDE.md` - For user-facing features, customization, and API usage
2. `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - For extraction/package development work
3. `docs/theming/COLOR_PICKER_INTEGRATION.md` - For integration patterns and file structure

**Built-in Preset Themes (31 total):**
1. **Default** - Dark theme with blue accents (Midnight Blue)
2. **Cedar Oak** - Warm earth tones (browns/greens)
3. **Mark43** - Original Mark43-inspired theme (orange/blue) - *Commented out in UI but code preserved*
4. **Sage Green** - Light theme with green tones
5. **Crimson Flame** - Fire fighter inspired (red/orange)
6. **Vapor Wave** - 80s aesthetic (magenta/cyan)
7. **Gothic** - Dark theme with purple accents
8. **Horror** - Dark theme with red accents
9. **Pride** - Progress Pride Flag colors (rainbow stripes: red, orange, yellow, green, blue, purple; chevron: white, pink, light blue, brown, black)
10. **Yuko** - Vibrant kaiju-inspired theme (hot pink, neon yellow, crimson red, light blue)
11. **Hokusai** - Japanese woodblock print inspired (deep blue-teal, pale yellow-orange, burnt orange, light blue accents)
12. **Noname** - Vibrant digital art inspired (light purple, bright blue, green, yellow, red accents)
13. **Sadikovic** - Boxing arena inspired (dark blue-black, electric blue, purple, gold, red accents)
14. **AFB** - Boxing gloves inspired (royal blue, metallic purple, gold, crimson red accents)
15. **TUF** - Athletic gear inspired (royal blue tank top, black base, red accents, silver/metallic grey gloves)
16. **Royboy** - Warm sepia portrait inspired (dark brown-black, muted reddish-brown, warm cream/blonde)
17. **Dalmatian** - High contrast black and white with warm blonde accents (diagonal split hoodie, minimalist)
18. **Querida** - Modern gray base with vibrant lime green accents (modern building, clean aesthetic)
19. **Ris** - Bright yellow background with light blue, red, purple, and brown accents (whimsical cartoon art)
20. **Gulu** - Warm beagle-inspired theme (cream, tan, rich browns)
21. **Maxine** - Vibrant portrait-inspired theme (platinum blonde, purple, orange, pink)
22. **Sunrise** - Coastal sunrise theme (light blue, teal, orange, purple)
23. **Noir** - Classic black and white photography theme (grayscale)
24. **Hatsune** - Anime-inspired theme (bright teal, light blue, purple, pink)
25. **Scotland** - Rugged valley landscape theme (pale grey-blue sky, dark blue-grey river, golden brown heather, muted greens)
26. **PBR** - Pabst Blue Ribbon inspired theme (PBR blue #003DA5, red accents, light blue-tinted backgrounds, dark blue footer)
27. **Reeses** - Reese's Pieces candy inspired theme (bright orange #B34D00, yellow accents, light orange-tinted backgrounds, dark brown-black footer)
28. **Fallout** - Vault-Tec inspired theme (Vault-Tec blue #0066CC, gold accents #FFD700, light blue-tinted backgrounds, dark blue footer, purple-blue hero radial #434fad)
29. **Berg√©** - Vibrant fashion-inspired theme (forest green #1F7A1F primary, hot pink #FF1493 accents, light green-tinted backgrounds, dark green footer)
30. **Pink** - Soft pink gerbera daisy inspired theme (soft peach-pink background, vibrant rose accents #ff66a3, WCAG AA compliant)
31. **King** - Dignified portrait-inspired theme (dark brown/charcoal base, warm golden-brown accents, muted green secondary elements, white/cream text) - *Built-in theme with audio easter egg (I Have a Dream speech)*

**Important Theme Picker Rules:**
- **Built-in themes MUST NOT have trash/delete icons** - Only custom user-created presets can be deleted
- Built-in themes include: Default, Cedar Oak, Sage Green, Crimson Flame, Vapor Wave, Gothic, Horror, Pride, Yuko, Hokusai, Noname, Sadikovic, AFB, TUF, Royboy, Dalmatian, Querida, Ris, Gulu, Maxine, Sunrise, Noir, Hatsune, Trippie, Scotland, PBR, Reeses, Fallout, Berg√©, Pink, Dayglow, and **King**
- When adding new built-in themes, ensure they are added to the `isBuiltIn` check in `ThemePicker.tsx` (around line 406)
- Do NOT add delete/trash functionality for built-in themes unless explicitly requested by the user
- The trash icon is conditionally rendered based on `!isBuiltIn` check - built-in themes should never show delete buttons

**Important Implementation Notes:**
- **CSS variables are the styling layer**: All color styling happens via CSS variables (`var(--color-*)`)
- **React manages the data**: ThemeContext holds theme state and applies it to DOM
- **Semantic tokens**: Colors use semantic names (e.g., `--color-primary`, `--color-text`) not raw colors
- **Themeable colors on `#root`**: Allows nested theme overrides in the future
- **Non-themeable tokens on `:root`**: Fonts, spacing, and layout values are static
- All preset themes meet WCAG AA contrast requirements (‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic) so it doesn't change with theme
- ThemePicker positioned bottom-left corner (matching Mark43 design)
- Contrast checker validates text on gradients by checking both start and end colors
- Semi-transparent colors are blended with backgrounds before contrast calculation
- Custom presets are stored in separate `localStorage` key from active theme
- Theme is applied to DOM before React render to prevent flicker on page load

### 11. Theme Picker Documentation & npm Package

**For Theme Picker Development & Customization:**

When working on theme picker features, customization, or npm package extraction:

1. **Read Primary Documentation:**
   - `docs/theming/REACT_PACKAGE_GUIDE.md` - Complete user guide covering:
     - Installation & setup
     - Token creation & theme definition
     - Adding theme presets
     - Adding accessibility checks (with code examples)
     - Creating themes from images
     - Customization (button colors, categories, CSS variables)
     - Adapting to existing codebases
     - Cursor rules & AI prompts for users
     - API reference
     - Troubleshooting

2. **For npm Package Extraction:**
   - `docs/theming/THEME_PICKER_NPM_PACKAGE_PLAN.md` - Extraction plan with:
     - TDD approach (tests in `src/__tests__/`)
     - Phase-by-phase extraction plan
     - Package architecture
     - Testing strategy
     - Publishing checklist

3. **For Integration:**
   - `docs/theming/COLOR_PICKER_INTEGRATION.md` - Integration reference for:
     - File structure
     - Dependencies
     - Step-by-step integration
     - API reference

**Key Principles:**
- All theme colors must be on `#root` (not `:root`)
- CSS variables follow pattern: `--color-{kebab-case-key}`
- Always check contrast ratios (WCAG AA: ‚â•4.5:1)
- ThemePicker UI uses fixed colors (theme-agnostic)
- Tests should be written first (TDD approach)
- Documentation should be comprehensive and user-friendly

**When Adding New Features:**
- Update relevant documentation files
- Add tests following TDD approach
- Update API reference if needed
- Provide examples in documentation

---

## Summary Checklist

Before merging or publishing:
- [ ] Interview question stated in intro
- [ ] `.explanation` present
- [ ] `.example` present
- [ ] Final `.takeaway` present and interview-ready
- [ ] Paragraph-driven, list-light writing
- [ ] Valid HTML compatible with `html-react-parser`

---

## Website Domain Information

**Production Domain:** `floatingpla.net`
- All meta tags, sitemaps, and external URLs should use `https://floatingpla.net`
- When updating robots.txt, Open Graph tags, or canonical URLs, use this domain
- The website is deployed at: `https://floatingpla.net`

---

## Agent Session Checklist

**Before starting work, ensure you have:**
- [ ] Read `README.md` to understand current TODOs and priorities
- [ ] Read `docs/PROJECT_SUMMARY.md` for project overview
- [ ] Reviewed `docs/README.md` for documentation structure
- [ ] Understood the current priority (check README.md "üéØ Next Priority" section)
- [ ] Located relevant documentation for your task type
- [ ] Familiarized yourself with key code files mentioned in PROJECT_SUMMARY.md

---

## Test Driven Development (TDD) Environment

### 12. TDD Workflow & Testing Standards

**This project operates in a Test Driven Development (TDD) environment.**

**Core TDD Principles:**
- **Write tests first** - Tests should be written before or alongside implementation
- **Red-Green-Refactor cycle** - Write failing test ‚Üí Make it pass ‚Üí Refactor
- **Test coverage is important** - Aim for high coverage of business logic and critical paths
- **Tests document behavior** - Tests serve as living documentation of expected behavior

**Testing Stack:**
- **Vitest** - Test runner and framework
- **@testing-library/react** - React component testing utilities
- **@testing-library/jest-dom** - Custom DOM matchers
- **@vitest/coverage-v8** - Code coverage reporting (v8 provider)

**Test Commands:**
- `npm test` - Run tests in watch mode (development)
- `npm run test:coverage` - Run tests once with coverage report
- `npm run test:ui` - Open Vitest UI for interactive test running and debugging

**Useful Terminal Commands for Testing & Coverage Analysis:**

1. **Run specific test file:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run
   ```

2. **Check coverage for specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx
   ```

3. **Get test summary (pass/fail counts):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -E "(Test Files|Tests )" | head -2
   ```

4. **Get coverage stats for specific source file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | head -1
   ```

5. **View detailed test output (last 30 lines):**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | tail -30
   ```

6. **Check for specific test failures:**
   ```bash
   npm test -- src/__tests__/ComponentName.test.tsx --run 2>&1 | grep -A 10 "FAIL"
   ```

7. **Get coverage percentage for a specific file:**
   ```bash
   npm run test:coverage -- src/__tests__/ComponentName.test.tsx 2>&1 | grep -E "SourceFile\.tsx.*\|" | grep -oE "[0-9]+\.[0-9]+"
   ```

8. **Check linting errors for test file:**
   ```bash
   # Use read_lints tool in Cursor, or:
   npm run lint -- src/__tests__/ComponentName.test.tsx
   ```

**Identifying Coverage Gaps:**
- After running coverage, check `coverage/index.html` for line-by-line coverage
- Look for red/yellow lines indicating uncovered code
- Use the grep commands above to quickly check coverage percentages
- Focus on uncovered branches (if statements, ternary operators, etc.)

**When Writing or Modifying Code:**

1. **Before implementing a feature:**
   - Consider what tests are needed
   - Write test cases that describe the expected behavior
   - Run tests to see them fail (Red)

2. **During implementation:**
   - Write minimal code to make tests pass (Green)
   - Refactor while keeping tests green (Refactor)

3. **After implementation:**
   - **ALWAYS run test coverage** to verify coverage:
     ```bash
     npm run test:coverage
     ```
   - Review coverage report in `coverage/index.html` or terminal output
   - Identify any uncovered code paths
   - Add tests for edge cases and error handling

**Code Coverage Standards:**

**Minimum Coverage Targets:**
- **Statements: 80%**
- **Lines: 80%**
- **Functions: 80%**
- **Branches: 65%**

These thresholds represent a practical, professional baseline for a frontend React project.

**Coverage Guidelines:**
- Coverage should reflect **meaningful, behavior-focused tests**‚Äînot artificially inflated metrics
- **Prioritize testing:**
  - Core utilities and business logic
  - Critical user flows
  - Error and edge cases that can realistically occur
- **Avoid writing contrived tests** solely to reach 100% coverage

**Acceptable Exceptions:**
Some branches may remain uncovered when they:
- Represent defensive guards unlikely to occur in real usage
- Depend on browser or third-party behaviors difficult to simulate
- Require unnatural hacks that reduce test quality

**Target Philosophy:**
- **Utilities:** strive for 90%+ coverage
- **Components:** 75‚Äì85% is acceptable
- **Branch coverage** will naturally be lower than statements

**When Reviewing Code:**
- New features should maintain or improve existing coverage
- Large logic changes must include updated tests
- Refactors should not reduce overall coverage without justification

**Exclude from coverage** (already configured in `vitest.config.ts`):
- Type definition files (`src/**/types.ts`)
- Pure constant data files (`src/data/blog/categories.ts`)
- Context instance files (`src/context/ThemeContextInstance.ts`)
- Test files themselves
- Setup files

**Test File Structure:**
- Test files live in `src/__tests__/` directory
- Naming: `ComponentName.test.tsx` or `feature.test.tsx`
- Use `describe` blocks to group related tests
- Use `it` or `test` for individual test cases
- Follow AAA pattern: Arrange, Act, Assert

**Example Test Structure:**
```typescript
import { describe, it, expect } from "vitest";
import { render, screen } from "@testing-library/react";
import { Component } from "@/components/Component";
import { ThemeProvider } from "@/context/ThemeContext";

describe("Component", () => {
  it("renders correctly", () => {
    render(
      <ThemeProvider>
        <Component />
      </ThemeProvider>
    );
    expect(screen.getByText("Expected Text")).toBeTruthy();
  });
});
```

**When AI Assistant Should Suggest Running Coverage:**

The AI assistant should **automatically suggest running test coverage** in these scenarios:

1. **After creating new test files:**
   - "I've created tests for ComponentX. Run `npm run test:coverage` to see the coverage improvement."

2. **After implementing new features:**
   - "Feature implementation complete. Run `npm run test:coverage` to verify test coverage."

3. **After modifying existing code:**
   - "Code changes complete. Run `npm run test:coverage` to ensure existing tests still pass and coverage is maintained."

4. **When user asks about test coverage:**
   - "To check current test coverage, run: `npm run test:coverage`"
   - "The coverage report will show in the terminal and be saved to `coverage/index.html` for detailed analysis."

5. **When identifying low coverage areas:**
   - "I notice ComponentX has low coverage. After adding tests, run `npm run test:coverage` to verify improvement."

**Coverage Report Locations:**
- **Terminal output** - Summary statistics (statements, branches, functions, lines)
- **`coverage/index.html`** - Interactive HTML report with line-by-line coverage
- **`coverage/coverage-summary.json`** - Machine-readable JSON report

**Best Practices:**
- Run `npm run test:coverage` **before committing** significant changes
- Review coverage reports to identify untested code paths
- Focus on testing **user-facing behavior** rather than implementation details
- Use `ThemeProvider` wrapper in tests for components that use `useTheme()`
- Use `BrowserRouter` wrapper for components that use React Router
- Mock external dependencies (APIs, browser APIs like Audio) appropriately
- Clean up after tests (clear localStorage, restore mocks, etc.)

**Test Coverage Configuration:**
- Coverage provider: `v8` (fast, modern)
- Reporters: `text` (terminal), `json` (machine-readable), `html` (browsable)
- Coverage includes: `src/**/*.{ts,tsx}`
- Exclusions configured in `vitest.config.ts` for non-testable files

---

### 13. Cyclomatic Complexity Standards

**This project enforces cyclomatic complexity limits to maintain code quality and testability.**

**Complexity Targets:**
- **Default:** Keep cyclomatic complexity ‚â§ 10 per function/method
- **UI Components, Hooks, Event Handlers:** Prefer ‚â§ 6
- **Exceptions:** Any function expected to exceed 10 must be intentionally refactored or split unless there is a strong reason (documented inline)

**What Counts as Complexity:**
Cyclomatic complexity is 1 (base path) plus +1 for each decision/branch point. These count as decision points:
- `if`, each `else if`
- Conditional (ternary): `cond ? a : b`
- Loops: `for`, `for...of`, `for...in`, `while`, `do...while`
- `switch`: treat each `case`/`default` as a branch (tool-dependent; assume strict counting unless configured otherwise)
- `catch` blocks (`try` itself does not add a branch)
- Short-circuit boolean logic that changes flow: `&&`, `||` (especially in conditions and JSX)

**What Does NOT Count:**
These do not add cyclomatic complexity:
- Sequential statements (assignments, calls, logging, object/array literals, destructuring, arithmetic/string ops, unconditional return)
- JSX structure/layout without conditional logic
- Hook calls (e.g., `useState`, `useEffect`) as calls; only branching inside their callbacks/components counts
- TypeScript types/interfaces/generics (compile-time only)
- React itself does not change the rules; conditional rendering (`&&`, ternary) does add branches

**Design Constraints to Keep Complexity Low:**

When generating code, prefer patterns that naturally reduce branching:

1. **Early returns / guard clauses** to avoid deep nesting
2. **Extract helpers** when logic branches: move a branchy block into a named function with a focused purpose
3. **Replace long if/else chains** with:
   - A lookup map/object of handlers (`const handlers = { ... }`)
   - Strategy functions
   - Small pure functions that return a value (then render/use the value)
4. **Split "do everything" functions** into:
   - Parsing/validation (pure)
   - Decision logic (pure)
   - Side effects (isolated)
5. **Keep callbacks small** (`map`, `filter`, `reduce`, event handlers); if branching appears, extract to a named function
6. **Prefer data-driven configuration** over branching (e.g., arrays of rules, tables of constants)

**Testing / Maintainability Requirements:**
- Keep decision logic in pure functions (easy to unit test)
- Components should mostly compose UI; non-trivial conditional logic belongs in helpers/hooks
- Limit nesting depth (aim ‚â§ 2) and avoid combining multiple concerns in one function

**Exceptions:**
If complexity > 10 is unavoidable:
- Add an inline comment explaining why (domain complexity, performance constraints, etc.)
- Ensure the function is well-covered by tests
- Split internal logic into clearly named helpers where possible

**ESLint Enforcement:**
- Complexity rule is configured in `eslint.config.js`
- Current threshold: `max: 10` with `variant: "classic"` (warn level)
- Use `npm run lint` to check for complexity violations
- Use `npm run lint:complexity` to generate an HTML complexity report

**Complexity Report Generation:**

The project includes a custom complexity report generator that creates an interactive HTML report of functions exceeding the complexity threshold.

**Script Location:**
- `scripts/generate-complexity-report.js` - Custom Node.js script that generates HTML complexity reports

**How It Works:**

1. **ESLint Integration:**
   - Uses ESLint's built-in `complexity` rule (configured in `eslint.config.js`)
   - Executes ESLint with JSON output format: `npx eslint . --format=json --output-file=complexity-report.json`
   - Parses the JSON output to extract complexity warnings (severity 1)

2. **Report Generation:**
   - Filters messages for `ruleId === 'complexity'` and `severity === 1`
   - Extracts complexity values from warning messages using regex pattern matching
   - Sorts functions by complexity (highest first)
   - Calculates visual progress bars based on complexity percentage (complexity 10 = 0%, complexity 30+ = 100%)
   - Color-codes functions by complexity level:
     - **Low (‚â•20)**: Dark red background (`#C21F39`)
     - **Medium (‚â•15)**: Yellow/gold background (`#f9cd0b`)
     - **High (11-14)**: Dark green background (`rgb(77,146,33)`)

3. **HTML Report Output:**
   - Generates `complexity-report.html` in project root
   - Uses CSS styling based on Istanbul/NYC coverage report design (familiar color scheme)
   - Displays table with columns: File, Complexity, Level (progress bar), Line number
   - Includes summary statistics (count, max, average complexity)
   - Shows success message if no complexity issues found

4. **Dependencies & Packages:**
   - **ESLint** - Core linting engine (already in devDependencies)
   - **complexity-report-html** (v0.0.3) - Listed in devDependencies but **not actively used** in our custom script (evaluated for potential use but custom solution was preferred)
   - **eslintcc** (v0.8.3) - Listed in devDependencies but **not actively used** (alternative complexity analysis tool, kept for potential future use)

**Command:**
```bash
npm run lint:complexity
```

**Output Files:**
- `complexity-report.html` - HTML report (gitignored, regenerated each run)
- `complexity-report.json` - Intermediate ESLint JSON output (gitignored, cleaned up after parsing)

**Report Features:**
- Visual progress bars showing complexity levels (horizontal bars with filled/empty segments)
- Color-coded rows matching complexity severity
- Clickable file links (currently placeholder `#` hrefs)
- Line number references to locate complex functions
- Summary statistics (function count, max complexity, average complexity)

**CSS Styling:**
- Matches Istanbul/NYC coverage report color scheme for familiarity
- Fixed bar alignment issue: white (unfilled) segments now appear on same line as colored (filled) segments
- Uses `inline-block` with `vertical-align: top` and `font-size: 0` on container to prevent vertical stacking

**Future Enhancements (TODOs):**

1. **Function Source Code Viewing:**
   - Enable clicking into each function to view the entire function source code
   - Display full function implementation with syntax highlighting
   - Highlight complexity decision paths (if/else, loops, switch statements, ternary operators)
   - Show visual indicators for each branch point that contributes to complexity

2. **Comprehensive Function Listing:**
   - Include **all function files being tested**, not just ones exceeding complexity threshold
   - Show complexity metrics for all functions (even those under threshold)
   - Allow filtering/sorting by complexity level (all functions, high, medium, low)
   - Provide baseline metrics showing project-wide complexity distribution

3. **Enhanced Interactivity:**
   - Make file links functional (navigate to source code, possibly with line highlighting)
   - Add expandable/collapsible function details
   - Show complexity breakdown (which specific constructs contribute most to complexity)
   - Add search/filter functionality

4. **Integration Improvements:**
   - Consider integrating with test coverage reports (show complexity alongside coverage)
   - Add CI/CD integration (fail builds if complexity exceeds thresholds)
   - Generate historical trends (track complexity over time)
   - Export to various formats (JSON, CSV) for further analysis